#!/usr/bin/env node

if (parseInt(process.versions.node.split('.')[0]) < 20) {
  throw new Error("This program requires Node v20 or later to run")
}

try {
(function(scope){
'use strict';

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}

function F2(fun) {
  return F(2, fun, function(a) { return function(b) { return fun(a,b); }; })
}
function F3(fun) {
  return F(3, fun, function(a) {
    return function(b) { return function(c) { return fun(a, b, c); }; };
  });
}
function F4(fun) {
  return F(4, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return fun(a, b, c, d); }; }; };
  });
}
function F5(fun) {
  return F(5, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
  });
}
function F6(fun) {
  return F(6, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return fun(a, b, c, d, e, f); }; }; }; }; };
  });
}
function F7(fun) {
  return F(7, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
  });
}
function F8(fun) {
  return F(8, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) {
    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
  });
}
function F9(fun) {
  return F(9, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) { return function(i) {
    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
  });
}

function A2(fun, a, b) {
  return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
}
function A3(fun, a, b, c) {
  return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
}
function A4(fun, a, b, c, d) {
  return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
}
function A5(fun, a, b, c, d, e) {
  return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
}
function A6(fun, a, b, c, d, e, f) {
  return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
}
function A7(fun, a, b, c, d, e, f, g) {
  return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
}
function A8(fun, a, b, c, d, e, f, g, h) {
  return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
}
function A9(fun, a, b, c, d, e, f, g, h, i) {
  return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
}

var $gren_lang$node$Node$InitDone = function (a) {
	return { $: 'InitDone', a: a };
};
var $gren_lang$node$Node$Uninitialized = { $: 'Uninitialized' };


// TASKS

function _Scheduler_succeed(value) {
  return {
    $: 0,
    a: value,
  };
}

function _Scheduler_fail(error) {
  return {
    $: 1,
    a: error,
  };
}

function _Scheduler_binding(callback) {
  return {
    $: 2,
    b: callback,
    c: null,
  };
}

var _Scheduler_andThen = F2(function (callback, task) {
  return {
    $: 3,
    b: callback,
    d: task,
  };
});

var _Scheduler_onError = F2(function (callback, task) {
  return {
    $: 4,
    b: callback,
    d: task,
  };
});

function _Scheduler_receive(callback) {
  return {
    $: 5,
    b: callback,
  };
}

function _Scheduler_concurrent(tasks) {
  if (tasks.length === 0) return _Scheduler_succeed([]);

  return _Scheduler_binding(function (callback) {
    let count = 0;
    let results = new Array(tasks.length);
    let procs;

    function killAll() {
      procs.forEach(_Scheduler_rawKill);
    }

    function onError(e) {
      killAll();
      callback(_Scheduler_fail(e));
    }

    procs = tasks.map((task, i) => {
      function onSuccess(res) {
        results[i] = res;
        count++;
        if (count === tasks.length) {
          callback(_Scheduler_succeed(results));
        }
      }
      const success = A2(_Scheduler_andThen, onSuccess, task);
      const handled = A2(_Scheduler_onError, onError, success);
      return _Scheduler_rawSpawn(handled);
    });

    return killAll;
  });
}

var _Scheduler_map2 = F3(function (callback, taskA, taskB) {
  function combine([resA, resB]) {
    return _Scheduler_succeed(A2(callback, resA, resB));
  }
  return A2(_Scheduler_andThen, combine, _Scheduler_concurrent([taskA, taskB]));
});

// PROCESSES

var _Scheduler_guid = 0;

function _Scheduler_rawSpawn(task) {
  var proc = {
    $: 0,
    e: _Scheduler_guid++,
    f: task,
    g: null,
    h: [],
  };

  _Scheduler_enqueue(proc);

  return proc;
}

function _Scheduler_spawn(task) {
  return _Scheduler_binding(function (callback) {
    callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
  });
}

function _Scheduler_rawSend(proc, msg) {
  proc.h.push(msg);
  _Scheduler_enqueue(proc);
}

var _Scheduler_send = F2(function (proc, msg) {
  return _Scheduler_binding(function (callback) {
    _Scheduler_rawSend(proc, msg);
    callback(_Scheduler_succeed({}));
  });
});

function _Scheduler_kill(proc) {
  return _Scheduler_binding(function (callback) {
    _Scheduler_rawKill(proc);

    callback(_Scheduler_succeed({}));
  });
}

function _Scheduler_rawKill(proc) {
  var task = proc.f;
  if (task && task.$ === 2 && task.c) {
    task.c();
  }

  proc.f = null;
}

/* STEP PROCESSES

type alias Process =
  { $ : tag
  , id : unique_id
  , root : Task
  , stack : null | { $: SUCCEED | FAIL, a: callback, b: stack }
  , mailbox : [msg]
  }

*/

var _Scheduler_working = false;
var _Scheduler_queue = [];

function _Scheduler_enqueue(proc) {
  _Scheduler_queue.push(proc);
  if (_Scheduler_working) {
    return;
  }
  _Scheduler_working = true;
  // Make sure tasks created during _step are run
  while (_Scheduler_queue.length > 0) {
    const activeProcs = _Scheduler_queue;
    _Scheduler_queue = [];

    for (const proc of activeProcs) {
      _Scheduler_step(proc);
    }
  }
  _Scheduler_working = false;
}

function _Scheduler_step(proc) {
  while (proc.f) {
    var rootTag = proc.f.$;
    if (rootTag === 0 || rootTag === 1) {
      while (proc.g && proc.g.$ !== rootTag) {
        proc.g = proc.g.i;
      }
      if (!proc.g) {
        return;
      }
      proc.f = proc.g.b(proc.f.a);
      proc.g = proc.g.i;
    } else if (rootTag === 2) {
      proc.f.c = proc.f.b(function (newRoot) {
        proc.f = newRoot;
        _Scheduler_enqueue(proc);
      });
      return;
    } else if (rootTag === 5) {
      if (proc.h.length === 0) {
        return;
      }
      proc.f = proc.f.b(proc.h.shift());
    } // if (rootTag === 3 || rootTag === 4)
    else {
      proc.g = {
        $: rootTag === 3 ? 0 : 1,
        b: proc.f.b,
        i: proc.g,
      };
      proc.f = proc.f.d;
    }
  }
}
var $gren_lang$core$Task$andThen = _Scheduler_andThen;
var $gren_lang$core$Basics$apL$ = function(f, x) {
	return f(x);
};
var $gren_lang$core$Basics$apL = F2($gren_lang$core$Basics$apL$);
var $gren_lang$core$Basics$apR$ = function(x, f) {
	return f(x);
};
var $gren_lang$core$Basics$apR = F2($gren_lang$core$Basics$apR$);


var stream = require("node:stream");
var process = require("node:process");

var _Node_log = F2(function (text, args) {
  // This function is used for simple applications where the main function returns String
  // NOTE: this function needs _Platform_export available to work
  console.log(text);
  return {};
});

var _Node_init = _Scheduler_binding(function (callback) {
  if (process.stdin.unref) {
    // Don't block program shutdown if this is the only
    // stream being listened to
    process.stdin.unref();
  }

  const stdinStream = stream.Readable.toWeb(process.stdin);
  const stdinProxy = !process.stdin.ref
    ? stdinStream
    : _Node_makeProxyOfStdin(stdinStream);

  callback(
    _Scheduler_succeed({
      applicationPath: _FilePath_fromString(
        typeof module !== "undefined" ? module.filename : process.execPath,
      ),
      arch: process.arch,
      args: process.argv,
      platform: process.platform,
      stderr: stream.Writable.toWeb(process.stderr),
      stdin: stdinProxy,
      stdout: stream.Writable.toWeb(process.stdout),
    }),
  );
});

function _Node_makeProxyOfStdin(stdinStream) {
  return new Proxy(stdinStream, {
    get(target, prop, receiver) {
      if (prop === "getReader") {
        // Make sure to keep program alive if we're waiting for
        // user input
        process.stdin.ref();

        const reader = Reflect.get(target, prop, receiver);
        return _Node_makeProxyOfReader(reader);
      }

      if (prop === "pipeThrough") {
        process.stdin.ref();
      }

      return Reflect.get(target, prop, receiver);
    },
  });
}

function _Node_makeProxyOfReader(reader) {
  return new Proxy(reader, {
    get(target, prop, receiver) {
      if (prop === "releaseLock") {
        process.stdin.unref();
      }

      return Reflect.get(target, prop, receiver);
    },
  });
}

var _Node_getPlatform = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(process.platform));
});

var _Node_getCpuArchitecture = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(process.arch));
});

var _Node_getEnvironmentVariables = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(_Node_objToDict(process.env)));
});

var _Node_exitWithCode = function (code) {
  return A2(
    $gren_lang$core$Task$perform,
    $gren_lang$core$Basics$never,
    _Scheduler_binding(function (callback) {
      process.exit(code);
    }),
  );
};

var _Node_setExitCode = function (code) {
  return _Scheduler_binding(function (callback) {
    process.exitCode = code;
    callback(_Scheduler_succeed({}));
  });
};

// Subs

var _Node_attachEmptyEventLoopListener = function (selfMsg) {
  return _Scheduler_binding(function (_callback) {
    var listener = function () {
      _Scheduler_rawSpawn(selfMsg);
    };

    process.on("beforeExit", listener);

    return function () {
      process.off("beforeExit", listener);
    };
  });
};

var _Node_attachSignalInterruptListener = function (selfMsg) {
  return _Scheduler_binding(function (_callback) {
    var listener = function () {
      _Scheduler_rawSpawn(selfMsg);
    };

    process.on("SIGINT", listener);

    return function () {
      process.off("SIGINT", listener);
    };
  });
};

var _Node_attachSignalTerminateListener = function (selfMsg) {
  return _Scheduler_binding(function (_callback) {
    var listener = function () {
      _Scheduler_rawSpawn(selfMsg);
    };

    process.on("SIGTERM", listener);

    return function () {
      process.off("SIGTERM", listener);
    };
  });
};

// Helpers

function _Node_objToDict(obj) {
  var dict = $gren_lang$core$Dict$empty;

  for (var key in obj) {
    dict = A3($gren_lang$core$Dict$set, key, obj[key], dict);
  }

  return dict;
}


var path = require("node:path");
var process = require("node:process");

var _FilePath_fromPosix = function (str) {
  return _FilePath_parse(path.posix, str);
};

var _FilePath_fromWin32 = function (str) {
  return _FilePath_parse(path.win32, str);
};

var _FilePath_fromString = function (str) {
  return _FilePath_parse(path, str);
};

var _FilePath_parse = function (pathMod, str) {
  const result = pathMod.parse(pathMod.normalize(str));

  const root = result.root;

  let dirStr = result.dir.startsWith(root)
    ? result.dir.substring(root.length)
    : result.dir;

  if (str.startsWith(`.${path.sep}`)) {
    dirStr = `.${path.sep}` + dirStr;
  }

  const filename =
    result.name === "." && result.ext.length === 0 ? "" : result.name;

  return {
    directory:
      dirStr === ""
        ? []
        : dirStr.split(pathMod.sep).filter((dir) => dir.length > 0),
    extension: result.ext.length > 0 ? result.ext.substring(1) : "",
    filename: filename,
    root: result.root,
  };
};

var _FilePath_toPosix = function (filePath) {
  if (_FilePath_isEmpty(filePath)) {
    return ".";
  }

  if (filePath.root !== "" && filePath.root !== "/") {
    filePath = { ...filePath, root: "/" };
  }

  return _FilePath_format(path.posix, filePath);
};

var _FilePath_toWin32 = function (filePath) {
  if (_FilePath_isEmpty(filePath)) {
    return ".";
  }

  return _FilePath_format(path.win32, filePath);
};

var _FilePath_toString = function (filePath) {
  if (process.platform.toLowerCase() === "win32") {
    return _FilePath_toWin32(filePath);
  }

  return _FilePath_toPosix(filePath);
};

var _FilePath_isEmpty = function (filePath) {
  return (
    filePath.root === "" &&
    filePath.directory.length === 0 &&
    filePath.filename === "" &&
    filePath.extension === ""
  );
};

var _FilePath_format = function (pathMod, filePath) {
  const filename =
    filePath.extension.length > 0
      ? filePath.filename + "." + filePath.extension
      : filePath.filename;

  let pathArray = null;
  if (filename === "") {
    pathArray = filePath.directory;
  } else {
    pathArray = filePath.directory.concat(filename);
  }

  return filePath.root + pathArray.join(pathMod.sep);
};


// PROGRAMS

var _Platform_worker = F3(function (impl, flagDecoder, args) {
  return _Platform_initialize(
    flagDecoder,
    args,
    impl.init,
    impl.update,
    impl.subscriptions,
    function () {
      return function () {};
    },
  );
});

// INITIALIZE A PROGRAM

function _Platform_initialize(
  flagDecoder,
  args,
  init,
  update,
  subscriptions,
  stepperBuilder,
) {
  var result = A2(
    _Json_run,
    flagDecoder,
    _Json_wrap(args ? args["flags"] : undefined),
  );
  $gren_lang$core$Result$isOk(result) ||
    _Debug_crash(2 /**/, _Json_errorToString(result.a) /**/);

  _Platform_setupTaskPorts(args ? args["taskPorts"] : undefined);

  var managers = {};
  var initPair = init(result.a);
  var model = initPair.model;
  var stepper = stepperBuilder(sendToApp, model);
  var ports = _Platform_setupEffects(managers, sendToApp, executeCmd);

  function sendToApp(msg, viewMetadata) {
    var pair = A2(update, msg, model);
    stepper((model = pair.model), viewMetadata);
    _Platform_enqueueEffects(managers, pair.command, subscriptions(model));
  }

  function executeCmd(cmd) {
    _Platform_enqueueEffects(managers, cmd, subscriptions(model));
  }

  _Platform_enqueueEffects(managers, initPair.command, subscriptions(model));

  return ports ? { ports: ports } : {};
}

// TRACK PRELOADS
//
// This is used by code in gren/browser and gren/http
// to register any HTTP requests that are triggered by init.
//

var _Platform_preload;

function _Platform_registerPreload(url) {
  _Platform_preload.add(url);
}

// EFFECT MANAGERS

var _Platform_effectManagers = {};

function _Platform_setupEffects(managers, sendToApp, executeCmd) {
  var ports;

  // setup all necessary effect managers
  for (var key in _Platform_effectManagers) {
    var manager = _Platform_effectManagers[key];

    if (manager.a) {
      ports = ports || {};
      ports[key] = manager.a(key, sendToApp);
    }

    managers[key] = _Platform_instantiateManager(
      manager,
      sendToApp,
      executeCmd,
    );
  }

  return ports;
}

function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap) {
  return {
    b: init,
    c: onEffects,
    d: onSelfMsg,
    e: cmdMap,
    f: subMap,
  };
}

function _Platform_instantiateManager(info, sendToApp, executeCmd) {
  var router = {
    g: sendToApp,
    h: executeCmd,
    i: undefined,
  };

  var onEffects = info.c;
  var onSelfMsg = info.d;
  var cmdMap = info.e;
  var subMap = info.f;

  function loop(state) {
    return A2(
      _Scheduler_andThen,
      loop,
      _Scheduler_receive(function (msg) {
        var value = msg.a;

        if (msg.$ === 0) {
          return A3(onSelfMsg, router, value, state);
        }

        return cmdMap && subMap
          ? A4(onEffects, router, value.j, value.k, state)
          : A3(onEffects, router, cmdMap ? value.j : value.k, state);
      }),
    );
  }

  return (router.i = _Scheduler_rawSpawn(
    A2(_Scheduler_andThen, loop, info.b),
  ));
}

// ROUTING

var _Platform_sendToApp = F2(function (router, msg) {
  return _Scheduler_binding(function (callback) {
    router.g(msg);
    callback(_Scheduler_succeed({}));
  });
});

var _Platform_sendToSelf = F2(function (router, msg) {
  return A2(_Scheduler_send, router.i, {
    $: 0,
    a: msg,
  });
});

var _Platform_executeCmd = F2(function (router, cmd) {
  return _Scheduler_binding(function (callback) {
    router.h(cmd);
    callback(_Scheduler_succeed({}));
  });
});

// BAGS

function _Platform_leaf(home) {
  return function (value) {
    return {
      $: 1,
      l: home,
      m: value,
    };
  };
}

function _Platform_batch(array) {
  return {
    $: 2,
    n: array,
  };
}

var _Platform_map = F2(function (tagger, bag) {
  return {
    $: 3,
    o: tagger,
    p: bag,
  };
});

// PIPE BAGS INTO EFFECT MANAGERS
//
// Effects must be queued!
//
// Say your init contains a synchronous command, like Time.now or Time.here
//
//   - This will produce a batch of effects (FX_1)
//   - The synchronous task triggers the subsequent `update` call
//   - This will produce a batch of effects (FX_2)
//
// If we just start dispatching FX_2, subscriptions from FX_2 can be processed
// before subscriptions from FX_1. No good! Earlier versions of this code had
// this problem, leading to these reports:
//
//   https://github.com/gren/core/issues/980
//   https://github.com/gren/core/pull/981
//   https://github.com/gren/compiler/issues/1776
//
// The queue is necessary to avoid ordering issues for synchronous commands.

// Why use true/false here? Why not just check the length of the queue?
// The goal is to detect "are we currently dispatching effects?" If we
// are, we need to bail and let the ongoing while loop handle things.
//
// Now say the queue has 1 element. When we dequeue the final element,
// the queue will be empty, but we are still actively dispatching effects.
// So you could get queue jumping in a really tricky category of cases.
//
var _Platform_effectsQueue = [];
var _Platform_effectsActive = false;

function _Platform_enqueueEffects(managers, cmdBag, subBag) {
  _Platform_effectsQueue.push({
    q: managers,
    r: cmdBag,
    s: subBag,
  });

  if (_Platform_effectsActive) return;

  _Platform_effectsActive = true;
  while (_Platform_effectsQueue.length > 0) {
    const activeEffects = _Platform_effectsQueue;
    _Platform_effectsQueue = [];

    for (const fx of activeEffects) {
      _Platform_dispatchEffects(fx.q, fx.r, fx.s);
    }
  }
  _Platform_effectsActive = false;
}

function _Platform_dispatchEffects(managers, cmdBag, subBag) {
  var effectsDict = {};
  _Platform_gatherEffects(true, cmdBag, effectsDict, null);
  _Platform_gatherEffects(false, subBag, effectsDict, null);

  for (var home in managers) {
    _Scheduler_rawSend(managers[home], {
      $: "fx",
      a: effectsDict[home] || { j: [], k: [] },
    });
  }
}

function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers) {
  switch (bag.$) {
    case 1:
      var home = bag.l;
      var effect = _Platform_toEffect(isCmd, home, taggers, bag.m);
      effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
      return;

    case 2:
      var bags = bag.n;
      for (var idx = 0; idx < bags.length; idx++) {
        _Platform_gatherEffects(isCmd, bags[idx], effectsDict, taggers);
      }
      return;

    case 3:
      _Platform_gatherEffects(isCmd, bag.p, effectsDict, {
        t: bag.o,
        u: taggers,
      });
      return;
  }
}

function _Platform_toEffect(isCmd, home, taggers, value) {
  function applyTaggers(x) {
    for (var temp = taggers; temp; temp = temp.u) {
      x = temp.t(x);
    }
    return x;
  }

  var map = isCmd
    ? _Platform_effectManagers[home].e
    : _Platform_effectManagers[home].f;

  return A2(map, applyTaggers, value);
}

function _Platform_insert(isCmd, newEffect, effects) {
  effects = effects || { j: [], k: [] };

  isCmd
    ? (effects.j = A2($gren_lang$core$Array$pushLast, newEffect, effects.j))
    : (effects.k = A2($gren_lang$core$Array$pushLast, newEffect, effects.k));

  return effects;
}

// PORTS

function _Platform_checkPortName(name) {
  if (_Platform_effectManagers[name]) {
    _Debug_crash(3, name);
  }

  if (_Platform_taskPorts[name]) {
    _Debug_crash(3, name);
  }
}

// OUTGOING PORTS

function _Platform_outgoingPort(name, converter) {
  _Platform_checkPortName(name);
  _Platform_effectManagers[name] = {
    e: _Platform_outgoingPortMap,
    v: converter,
    a: _Platform_setupOutgoingPort,
  };
  return _Platform_leaf(name);
}

var _Platform_outgoingPortMap = F2(function (tagger, value) {
  return value;
});

function _Platform_setupOutgoingPort(name) {
  var subs = [];
  var converter = _Platform_effectManagers[name].v;

  // CREATE MANAGER

  var init = _Process_sleep(0);

  _Platform_effectManagers[name].b = init;
  _Platform_effectManagers[name].c = F3(
    function (router, cmdArray, state) {
      for (var idx = 0; idx < cmdArray.length; idx++) {
        // grab a separate reference to subs in case unsubscribe is called
        var currentSubs = subs;
        var value = _Json_unwrap(converter(cmdArray[idx]));
        for (var subIdx = 0; subIdx < currentSubs.length; subIdx++) {
          currentSubs[subIdx](value);
        }
      }
      return init;
    },
  );

  // PUBLIC API

  function subscribe(callback) {
    subs.push(callback);
  }

  function unsubscribe(callback) {
    // copy subs into a new array in case unsubscribe is called within a
    // subscribed callback
    subs = subs.slice();
    var index = subs.indexOf(callback);
    if (index >= 0) {
      subs.splice(index, 1);
    }
  }

  return {
    subscribe: subscribe,
    unsubscribe: unsubscribe,
  };
}

// INCOMING PORTS

function _Platform_incomingPort(name, converter) {
  _Platform_checkPortName(name);
  _Platform_effectManagers[name] = {
    f: _Platform_incomingPortMap,
    v: converter,
    a: _Platform_setupIncomingPort,
  };
  return _Platform_leaf(name);
}

var _Platform_incomingPortMap = F2(function (tagger, finalTagger) {
  return function (value) {
    return tagger(finalTagger(value));
  };
});

function _Platform_setupIncomingPort(name, sendToApp) {
  var subs = [];
  var converter = _Platform_effectManagers[name].v;

  // CREATE MANAGER

  var init = _Scheduler_succeed(null);

  _Platform_effectManagers[name].b = init;
  _Platform_effectManagers[name].c = F3(
    function (router, subArray, state) {
      subs = subArray;
      return init;
    },
  );

  // PUBLIC API

  function send(incomingValue) {
    var result = A2(_Json_run, converter, _Json_wrap(incomingValue));

    $gren_lang$core$Result$isOk(result) || _Debug_crash(4, name, result.a);

    var value = result.a;
    for (var idx = 0; idx < subs.length; idx++) {
      sendToApp(subs[idx](value));
    }
  }

  return { send: send };
}

// TASK PORTS

var _Platform_taskPorts = {};

function _Platform_taskPort(name, inputConverter, converter) {
  _Platform_checkPortName(name);
  _Platform_taskPorts[name] = {};

  return function (input) {
    var encodedInput = inputConverter
      ? _Json_unwrap(inputConverter(input))
      : null;

    return _Scheduler_binding(function (callback) {
      var promise;
      try {
        promise = _Platform_taskPorts[name](encodedInput);
      } catch (e) {
        throw new Error(
          "Registered code for task-based port named '" + name + "'  crashed.",
          { cause: e },
        );
      }

      if (!(promise instanceof Promise)) {
        throw new Error(
          "Handler for task port named '" +
            name +
            "' did not return a Promise.",
        );
      }

      promise.then(
        function (value) {
          var result = A2(_Json_run, converter, _Json_wrap(value));

          $gren_lang$core$Result$isOk(result) || _Debug_crash(4, name, value);

          callback(_Scheduler_succeed(result.a));
        },
        function (err) {
          // If Error, convert to plain object. This is because Error doesn't have enumerable
          // properties.
          if (err instanceof Error) {
            var newErr = {};
            Object.getOwnPropertyNames(err).forEach(function (key) {
              newErr[key] = err[key];
            });

            err = newErr;
          }

          callback(_Scheduler_fail(_Json_wrap(err)));
        },
      );
    });
  };
}

function _Platform_setupTaskPorts(registeredPorts) {
  if (typeof registeredPorts !== "object") {
    registeredPorts = {};
  }

  for (var key in registeredPorts) {
    if (!(key in _Platform_taskPorts)) {
      // TODO: proper way to crash program
      throw new Error(
        key + " isn't defined as a task-based port in Gren code.",
      );
    }
  }

  for (var key in _Platform_taskPorts) {
    var handler = registeredPorts[key];
    if (!handler) {
      throw new Error("No handler defined for task port named '" + key + "'.");
    }

    if (!(handler instanceof Function)) {
      throw new Error(
        "Handler for task port named '" + key + "' is not a function.",
      );
    }

    _Platform_taskPorts[key] = handler;
  }
}

// EXPORT GREN MODULES
//
// Have DEBUG and PROD versions so that we can (1) give nicer errors in
// debug mode and (2) not pay for the bits needed for that in prod mode.
//

function _Platform_export_UNUSED(exports) {
  scope["Gren"]
    ? _Platform_mergeExportsProd(scope["Gren"], exports)
    : (scope["Gren"] = exports);
}

function _Platform_mergeExportsProd(obj, exports) {
  for (var name in exports) {
    name in obj
      ? name == "init"
        ? _Debug_crash(6)
        : _Platform_mergeExportsProd(obj[name], exports[name])
      : (obj[name] = exports[name]);
  }
}

function _Platform_export(exports) {
  scope["Gren"]
    ? _Platform_mergeExportsDebug("Gren", scope["Gren"], exports)
    : (scope["Gren"] = exports);
}

function _Platform_mergeExportsDebug(moduleName, obj, exports) {
  for (var name in exports) {
    name in obj
      ? name == "init"
        ? _Debug_crash(6, moduleName)
        : _Platform_mergeExportsDebug(
            moduleName + "." + name,
            obj[name],
            exports[name],
          )
      : (obj[name] = exports[name]);
  }
}


// LOG

var _Debug_log_UNUSED = F2(function (tag, value) {
  return value;
});

var _Debug_log = F2(function (tag, value) {
  console.log(tag + ": " + _Debug_toString(value));
  return value;
});

// TODOS

function _Debug_todo(moduleName, region) {
  return function (message) {
    _Debug_crash(8, moduleName, region, message);
  };
}

function _Debug_todoCase(moduleName, region, value) {
  return function (message) {
    _Debug_crash(9, moduleName, region, value, message);
  };
}

// TO STRING

function _Debug_toString_UNUSED(value) {
  return "<internals>";
}

function _Debug_toString(value) {
  return _Debug_toAnsiString(false, value);
}

function _Debug_toAnsiString(ansi, value) {
  if (value == null) {
    return _Debug_internalColor(ansi, "<null>");
  }

  if (typeof value === "function") {
    return _Debug_internalColor(ansi, "<function>");
  }

  if (typeof value === "boolean") {
    return _Debug_ctorColor(ansi, value ? "True" : "False");
  }

  if (typeof value === "number") {
    return _Debug_numberColor(ansi, value + "");
  }

  if (value instanceof String) {
    return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
  }

  if (typeof value === "string") {
    return _Debug_stringColor(
      ansi,
      '"' + _Debug_addSlashes(value, false) + '"',
    );
  }

  if (Array.isArray(value)) {
    var output = "[";

    value.length > 0 && (output += _Debug_toAnsiString(ansi, value[0]));

    for (var idx = 1; idx < value.length; idx++) {
      output += ", " + _Debug_toAnsiString(ansi, value[idx]);
    }

    return output + "]";
  }

  if (typeof value === "object" && "$" in value) {
    var tag = value.$;

    if (typeof tag === "number") {
      return _Debug_internalColor(ansi, "<internals>");
    }

    if (tag === "Set_gren_builtin") {
      return (
        _Debug_ctorColor(ansi, "Set") +
        _Debug_fadeColor(ansi, ".fromArray") +
        " " +
        _Debug_toAnsiString(ansi, $gren_lang$core$Set$toArray(value))
      );
    }

    if (tag === "RBNode_gren_builtin" || tag === "RBEmpty_gren_builtin") {
      return (
        _Debug_ctorColor(ansi, "Dict") +
        _Debug_fadeColor(ansi, ".fromArray") +
        " " +
        _Debug_toAnsiString(
          ansi,
          A3(
            $gren_lang$core$Dict$foldl,
            F3(function (key, value, acc) {
              acc.push({ key: key, value: value });
              return acc;
            }),
            [],
            value,
          ),
        )
      );
    }

    var output = "";
    for (var i in value) {
      if (i === "$") continue;
      var str = _Debug_toAnsiString(ansi, value[i]);
      var c0 = str[0];
      var parenless =
        c0 === "{" ||
        c0 === "(" ||
        c0 === "[" ||
        c0 === "<" ||
        c0 === '"' ||
        str.indexOf(" ") < 0;
      output += " " + (parenless ? str : "(" + str + ")");
    }
    return _Debug_ctorColor(ansi, tag) + output;
  }

  if (value instanceof DataView) {
    return _Debug_stringColor(ansi, "<" + value.byteLength + " bytes>");
  }

  if (typeof File !== "undefined" && value instanceof File) {
    return _Debug_internalColor(ansi, "<" + value.name + ">");
  }

  if (
    typeof _Array_Builder !== "undefined" &&
    value instanceof _Array_Builder
  ) {
    return _Debug_toAnsiString(ansi, value.array.slice(0, value.target));
  }

  if (typeof value === "object") {
    var output = [];
    for (var key in value) {
      var field = key[0] === "_" ? key.slice(1) : key;
      output.push(
        _Debug_fadeColor(ansi, field) +
          " = " +
          _Debug_toAnsiString(ansi, value[key]),
      );
    }
    if (output.length === 0) {
      return "{}";
    }
    return "{ " + output.join(", ") + " }";
  }

  return _Debug_internalColor(ansi, "<internals>");
}

function _Debug_addSlashes(str, isChar) {
  var s = str
    .replace(/\\/g, "\\\\")
    .replace(/\n/g, "\\n")
    .replace(/\t/g, "\\t")
    .replace(/\r/g, "\\r")
    .replace(/\v/g, "\\v")
    .replace(/\0/g, "\\0");

  if (isChar) {
    return s.replace(/\'/g, "\\'");
  } else {
    return s.replace(/\"/g, '\\"');
  }
}

function _Debug_ctorColor(ansi, string) {
  return ansi ? "\x1b[96m" + string + "\x1b[0m" : string;
}

function _Debug_numberColor(ansi, string) {
  return ansi ? "\x1b[95m" + string + "\x1b[0m" : string;
}

function _Debug_stringColor(ansi, string) {
  return ansi ? "\x1b[93m" + string + "\x1b[0m" : string;
}

function _Debug_charColor(ansi, string) {
  return ansi ? "\x1b[92m" + string + "\x1b[0m" : string;
}

function _Debug_fadeColor(ansi, string) {
  return ansi ? "\x1b[37m" + string + "\x1b[0m" : string;
}

function _Debug_internalColor(ansi, string) {
  return ansi ? "\x1b[36m" + string + "\x1b[0m" : string;
}

function _Debug_toHexDigit(n) {
  return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
}

// CRASH

function _Debug_crash_UNUSED(identifier) {
  throw new Error(
    "https://github.com/gren-lang/core/blob/1.0.0/hints/" + identifier + ".md",
  );
}

function _Debug_crash(identifier, fact1, fact2, fact3, fact4) {
  switch (identifier) {
    case 0:
      throw new Error(
        'What node should I take over? In JavaScript I need something like:\n\n    Gren.Main.init({\n        node: document.getElementById("gren-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.',
      );

    case 1:
      throw new Error(
        "Browser.application programs cannot handle URLs like this:\n\n    " +
          document.location.href +
          "\n\nWhat is the root? The root of your file system?",
      );

    case 2:
      var jsonErrorString = fact1;
      throw new Error(
        "Problem with the flags given to your Gren program on initialization.\n\n" +
          jsonErrorString,
      );

    case 3:
      var portName = fact1;
      throw new Error(
        "There can only be one port named `" +
          portName +
          "`, but your program has multiple.",
      );

    case 4:
      var portName = fact1;
      var problem = fact2;
      throw new Error(
        "Trying to send an unexpected type of value through port `" +
          portName +
          "`:\n" +
          problem,
      );

    case 5:
      throw new Error(
        'Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Gren sense.\nRead more about this at https://package.gren-lang.org/packages/gren-lang/core/latest/Basics#== which describes why it is this way and what the better version will look like.',
      );

    case 6:
      var moduleName = fact1;
      throw new Error(
        "Your page is loading multiple Gren scripts with a module named " +
          moduleName +
          ". Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!",
      );

    case 8:
      var moduleName = fact1;
      var region = fact2;
      var message = fact3;
      throw new Error(
        "TODO in module `" +
          moduleName +
          "` " +
          _Debug_regionToString(region) +
          "\n\n" +
          message,
      );

    case 9:
      var moduleName = fact1;
      var region = fact2;
      var value = fact3;
      var message = fact4;
      throw new Error(
        "TODO in module `" +
          moduleName +
          "` from the `case` expression " +
          _Debug_regionToString(region) +
          "\n\nIt received the following value:\n\n    " +
          _Debug_toString(value).replace("\n", "\n    ") +
          "\n\nBut the branch that handles it says:\n\n    " +
          message.replace("\n", "\n    "),
      );

    case 10:
      throw new Error("Bug in https://github.com/gren-lang/core/issues");

    case 11:
      throw new Error("Cannot perform mod 0. Division by zero error.");
  }
}

function _Debug_regionToString(region) {
  if (region.start.line === region.end.line) {
    return "on line " + region.start.line;
  }
  return (
    "on lines " + region.start.line + " through " + region.end.line
  );
}
var $gren_lang$core$Dict$foldl$ = function(func, acc, dict) {
	foldl:
	while (true) {
		if (dict.$ === 'RBEmpty_gren_builtin') {
			return acc;
		} else {
			var _v1 = dict.a;
			var key = _v1.key;
			var value = _v1.value;
			var left = _v1.left;
			var right = _v1.right;
			var $temp$func = func,
			$temp$acc = A3(func, key, value, $gren_lang$core$Dict$foldl$(func, acc, left)),
			$temp$dict = right;
			func = $temp$func;
			acc = $temp$acc;
			dict = $temp$dict;
			continue foldl;
		}
	}
};
var $gren_lang$core$Dict$foldl = F3($gren_lang$core$Dict$foldl$);


var _Array_length = function (array) {
  return array.length;
};

var _Array_initialize = F3(function (size, offset, func) {
  var result = new Array(size);

  for (var i = 0; i < size; i++) {
    result[i] = func(offset + i);
  }

  return result;
});

var _Array_get = F2(function (index, array) {
  var value = array.at(index);

  if (typeof value === "undefined") {
    return $gren_lang$core$Maybe$Nothing;
  }

  return $gren_lang$core$Maybe$Just(value);
});

var _Array_set = F3(function (index, value, array) {
  try {
    return array.with(index, value);
  } catch (e) {
    // assuming RangeError
    return array;
  }
});

var _Array_splice0 = F3(function (index, toRemove, array) {
  return array.toSpliced(index, toRemove);
});

var _Array_splice1 = F4(function (index, toRemove, toAdd, array) {
  return array.toSpliced(index, toRemove, toAdd);
});

var _Array_spliceN = F4(function (index, toRemove, toAdd, array) {
  return array.toSpliced(index, toRemove, ...toAdd);
});

var _Array_foldl = F3(function (func, acc, array) {
  for (var i = 0; i < array.length; i++) {
    acc = A2(func, array[i], acc);
  }

  return acc;
});

var _Array_foldr = F3(function (func, acc, array) {
  for (var i = array.length - 1; i >= 0; i--) {
    acc = A2(func, array[i], acc);
  }

  return acc;
});

var _Array_indexedFoldl = F3(function (func, acc, array) {
  for (var i = 0; i < array.length; i++) {
    acc = A3(func, i, array[i], acc);
  }

  return acc;
});

var _Array_indexedFoldr = F3(function (func, acc, array) {
  for (var i = array.length - 1; i >= 0; i--) {
    acc = A3(func, i, array[i], acc);
  }

  return acc;
});

var _Array_map = F2(function (func, array) {
  return array.map(func);
});

var _Array_indexedMap = F2(function (func, array) {
  return array.map(function (value, index) {
    return A2(func, index, value);
  });
});

var _Array_filter = F2(function (func, array) {
  return array.filter(func);
});

var _Array_indexedFilter = F2(function (func, array) {
  return array.filter(function (value, index) {
    return A2(func, index, value);
  });
});

var _Array_flat = function (array) {
  return array.flat();
};

var _Array_flatMap = F2(function (func, array) {
  return array.flatMap(func);
});

var _Array_slice = F3(function (from, to, array) {
  return array.slice(from, to);
});

var _Array_append = F2(function (left, right) {
  return left.concat(right);
});

var _Array_reverse = function (array) {
  return array.toReversed();
};

var _Array_findFirst = F2(function (pred, array) {
  for (var i = 0; i < array.length; i++) {
    var element = array[i];

    if (pred(element)) {
      return $gren_lang$core$Maybe$Just({ index: i, value: element });
    }
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _Array_findLast = F2(function (pred, array) {
  for (var i = array.length - 1; i >= 0; i--) {
    var element = array[i];

    if (pred(element)) {
      return $gren_lang$core$Maybe$Just({ index: i, value: element });
    }
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _Array_map2 = F3(function (fn, as, bs) {
  var result = [];
  var lowestLength = as.length < bs.length ? as.length : bs.length;

  for (var i = 0; i < lowestLength; i++) {
    result.push(A2(fn, as[i], bs[i]));
  }

  return result;
});

var _Array_map3 = F4(function (fn, as, bs, cs) {
  var result = [];
  var lowestLength = [as.length, bs.length, cs.length].sort()[0];

  for (var i = 0; i < lowestLength; i++) {
    result.push(A3(fn, as[i], bs[i], cs[i]));
  }

  return result;
});

var _Array_sort = function (array) {
  return array.toSorted(function (a, b) {
    return _Utils_cmp(a, b);
  });
};

var _Array_sortBy = F2(function (fn, array) {
  return array.toSorted(function (a, b) {
    return _Utils_cmp(fn(a), fn(b));
  });
});

var _Array_sortWith = F2(function (fn, array) {
  return array.toSorted(function (a, b) {
    var ord = A2(fn, a, b);
    return ord === $gren_lang$core$Basics$EQ ? 0 : ord === $gren_lang$core$Basics$LT ? -1 : 1;
  });
});

class _Array_Builder {
  constructor(target, finalized, array) {
    this.target = target;
    this.finalized = finalized;
    this.array = array;
  }
}

var _Array_emptyBuilder = function (capacity) {
  return new _Array_Builder(0, false, new Array(capacity));
};

var _Array_pushToBuilder = F2(function (value, builder) {
  var array = builder.array;
  var target = builder.target;

  if (builder.finalized) {
    array = array.slice(0, target);
  } else {
    builder.finalized = true;
  }

  if (target < array.length) {
    array[target] = value;
  } else {
    array.push(value);
  }

  return new _Array_Builder(target + 1, false, array);
});

var _Array_appendToBuilder = F2(function (array, builder) {
  var newArray = _Array_fromBuilder(builder);

  for (var i = 0; i < array.length; i++) {
    newArray.push(array[i]);
  }

  return new _Array_Builder(newArray.length, false, newArray);
});

var _Array_toBuilder = function (array) {
  return new _Array_Builder(array.length, true, array);
};

var _Array_fromBuilder = function (builder) {
  var result = builder.array;

  if (builder.finalized) {
    result = result.slice(0, builder.target);
  } else {
    builder.finalized = true;
    result.length = builder.target;
  }

  return result;
};


// EQUALITY

function _Utils_eq(x, y) {
  for (
    var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack);
    isEqual && (pair = stack.pop());
    isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)
  ) {}

  return isEqual;
}

function _Utils_eqHelp(x, y, depth, stack) {
  if (x === y) {
    return true;
  }

  if (typeof x !== "object" || x === null || y === null) {
    typeof x === "function" && _Debug_crash(5);
    return false;
  }

  if (depth > 100) {
    stack.push({ a: x, b: y });
    return true;
  }

  /**/
	if (x.$ === 'Set_gren_builtin')
	{
		x = $gren_lang$core$Set$toArray(x);
		y = $gren_lang$core$Set$toArray(y);
	}
	if (x.$ === 'RBNode_gren_builtin' || x.$ === 'RBEmpty_gren_builtin')
	{
		x = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], x);
		y = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], y);
	}
	//*/

  /**_UNUSED/
	if (x.$ < 0)
	{
		x = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], x);
		y = A3($gren_lang$core$Dict$foldl, F3(function(key, value, acc) { acc.push({ a: key, b: value }); return acc; }), [], y);
	}
	//*/

  if (x instanceof DataView) {
    var length = x.byteLength;

    if (y.byteLength !== length) {
      return false;
    }

    for (var i = 0; i < length; ++i) {
      if (x.getUint8(i) !== y.getUint8(i)) {
        return false;
      }
    }

    return true;
  }

  if (x instanceof _Array_Builder) {
    x = _Array_fromBuilder(x);
    y = _Array_fromBuilder(y);
  }

  if (Array.isArray(x) && x.length !== y.length) {
    return false;
  }

  var nextDepth = depth + 1;

  for (var key in x) {
    if (!_Utils_eqHelp(x[key], y[key], nextDepth, stack)) {
      return false;
    }
  }

  return true;
}

var _Utils_equal = F2(_Utils_eq);
var _Utils_notEqual = F2(function (a, b) {
  return !_Utils_eq(a, b);
});

// COMPARISONS

// Code in Generate/JavaScript.hs, Basics.js, and depends on
// the particular integer values assigned to LT, EQ, and GT.

function _Utils_cmp(x, y) {
  if (typeof x !== "object") {
    return x === y ? /*EQ*/ 0 : x < y ? /*LT*/ -1 : /*GT*/ 1;
  }

  /**/
	if (x instanceof String)
	{
		var a = x.valueOf();
		var b = y.valueOf();
		return a === b ? 0 : a < b ? -1 : 1;
	}
	//*/

  // At this point, we can only be comparing arrays
  for (var idx = 0; idx < x.length; idx++) {
    var ord = _Utils_cmp(x[idx], y[idx]);
    if (ord !== 0) return ord;
  }

  return x.length - y.length;
}

var _Utils_lt = F2(function (a, b) {
  return _Utils_cmp(a, b) < 0;
});
var _Utils_le = F2(function (a, b) {
  return _Utils_cmp(a, b) < 1;
});
var _Utils_gt = F2(function (a, b) {
  return _Utils_cmp(a, b) > 0;
});
var _Utils_ge = F2(function (a, b) {
  return _Utils_cmp(a, b) >= 0;
});

var _Utils_compare = F2(function (x, y) {
  var n = _Utils_cmp(x, y);
  return n < 0 ? $gren_lang$core$Basics$LT : n ? $gren_lang$core$Basics$GT : $gren_lang$core$Basics$EQ;
});

// COMMON VALUES

function _Utils_chr_UNUSED(c) {
  return c;
}
function _Utils_chr(c) {
  return new String(c);
}

// RECORDS

function _Utils_update(oldRecord, updatedFields) {
  var newRecord = {};

  for (var key in oldRecord) {
    newRecord[key] = oldRecord[key];
  }

  for (var key in updatedFields) {
    newRecord[key] = updatedFields[key];
  }

  return newRecord;
}

// APPEND

var _Utils_append = F2(_Utils_ap);

function _Utils_ap(xs, ys) {
  // append Strings
  if (typeof xs === "string") {
    return xs + ys;
  }

  return xs.concat(ys);
}
var $gren_lang$core$Basics$EQ = { $: 'EQ' };
var $gren_lang$core$Basics$GT = { $: 'GT' };
var $gren_lang$core$Basics$LT = { $: 'LT' };
var $gren_lang$core$Maybe$Just = function (a) {
	return { $: 'Just', a: a };
};
var $gren_lang$core$Maybe$Nothing = { $: 'Nothing' };
var $gren_lang$core$Array$length = _Array_length;
var $gren_lang$core$Array$pushLast$ = function(value, array) {
	return A4(_Array_splice1, $gren_lang$core$Array$length(array), 0, value, array);
};
var $gren_lang$core$Array$pushLast = F2($gren_lang$core$Array$pushLast$);
var $gren_lang$core$Dict$keys = function(dict) {
	return $gren_lang$core$Dict$foldl$(F3(function(key, value, keyArray) {
				return $gren_lang$core$Array$pushLast$(key, keyArray);
			}), [  ], dict);
};
var $gren_lang$core$Set$toArray = function(_v0) {
	var dict = _v0.a;
	return $gren_lang$core$Dict$keys(dict);
};


/**/
function _Json_errorToString(error)
{
	return $gren_lang$core$Json$Decode$errorToString(error);
}
//*/

// CORE DECODERS

function _Json_succeed(msg) {
  return {
    $: 0,
    a: msg,
  };
}

function _Json_fail(msg) {
  return {
    $: 1,
    a: msg,
  };
}

function _Json_decodePrim(decoder) {
  return { $: 2, b: decoder };
}

var _Json_decodeInt = _Json_decodePrim(function (value) {
  return typeof value !== "number"
    ? _Json_expecting("an INT", value)
    : Math.trunc(value) === value
      ? $gren_lang$core$Result$Ok(value)
      : isFinite(value) && !(value % 1)
        ? $gren_lang$core$Result$Ok(value)
        : _Json_expecting("an INT", value);
});

var _Json_decodeBool = _Json_decodePrim(function (value) {
  return typeof value === "boolean"
    ? $gren_lang$core$Result$Ok(value)
    : _Json_expecting("a BOOL", value);
});

var _Json_decodeFloat = _Json_decodePrim(function (value) {
  return typeof value === "number"
    ? $gren_lang$core$Result$Ok(value)
    : _Json_expecting("a FLOAT", value);
});

var _Json_decodeValue = _Json_decodePrim(function (value) {
  return $gren_lang$core$Result$Ok(_Json_wrap(value));
});

var _Json_decodeString = _Json_decodePrim(function (value) {
  return typeof value === "string"
    ? $gren_lang$core$Result$Ok(value)
    : value instanceof String
      ? $gren_lang$core$Result$Ok(value + "")
      : _Json_expecting("a STRING", value);
});

function _Json_decodeArray(decoder) {
  return { $: 3, b: decoder };
}

function _Json_decodeNull(value) {
  return { $: 4, c: value };
}

var _Json_decodeField = F2(function (field, decoder) {
  return {
    $: 5,
    d: field,
    b: decoder,
  };
});

var _Json_decodeIndex = F2(function (index, decoder) {
  return {
    $: 6,
    e: index,
    b: decoder,
  };
});

function _Json_decodeKeyValuePairs(decoder) {
  return {
    $: 7,
    b: decoder,
  };
}

function _Json_mapMany(f, decoders) {
  return {
    $: 8,
    f: f,
    g: decoders,
  };
}

var _Json_andThen = F2(function (callback, decoder) {
  return {
    $: 9,
    b: decoder,
    h: callback,
  };
});

function _Json_oneOf(decoders) {
  return {
    $: 10,
    g: decoders,
  };
}

// DECODING OBJECTS

var _Json_map1 = F2(function (f, d1) {
  return _Json_mapMany(f, [d1]);
});

var _Json_map2 = F3(function (f, d1, d2) {
  return _Json_mapMany(f, [d1, d2]);
});

var _Json_map3 = F4(function (f, d1, d2, d3) {
  return _Json_mapMany(f, [d1, d2, d3]);
});

var _Json_map4 = F5(function (f, d1, d2, d3, d4) {
  return _Json_mapMany(f, [d1, d2, d3, d4]);
});

var _Json_map5 = F6(function (f, d1, d2, d3, d4, d5) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5]);
});

var _Json_map6 = F7(function (f, d1, d2, d3, d4, d5, d6) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6]);
});

var _Json_map7 = F8(function (f, d1, d2, d3, d4, d5, d6, d7) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
});

var _Json_map8 = F9(function (f, d1, d2, d3, d4, d5, d6, d7, d8) {
  return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
});

// DECODE

var _Json_runOnString = F2(function (decoder, string) {
  try {
    var value = JSON.parse(string);
    return _Json_runHelp(decoder, value);
  } catch (e) {
    return $gren_lang$core$Result$Err(
      $gren_lang$core$Json$Decode$Failure({
        message: "This is not valid JSON! " + e.message,
        value: _Json_wrap(string),
      }),
    );
  }
});

var _Json_run = F2(function (decoder, value) {
  return _Json_runHelp(decoder, _Json_unwrap(value));
});

function _Json_runHelp(decoder, value) {
  switch (decoder.$) {
    case 2:
      return decoder.b(value);

    case 4:
      return value === null
        ? $gren_lang$core$Result$Ok(decoder.c)
        : _Json_expecting("null", value);

    case 3:
      if (!_Json_isArray(value)) {
        return _Json_expecting("an ARRAY", value);
      }
      return _Json_runArrayDecoder(decoder.b, value);

    case 5:
      var field = decoder.d;
      if (typeof value !== "object" || value === null || !(field in value)) {
        return _Json_expecting(
          "an OBJECT with a field named `" + field + "`",
          value,
        );
      }
      var result = _Json_runHelp(decoder.b, value[field]);
      return $gren_lang$core$Result$isOk(result)
        ? result
        : $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$Field({ name: field, error: result.a }));

    case 6:
      var index = decoder.e;
      if (!_Json_isArray(value)) {
        return _Json_expecting("an ARRAY", value);
      }
      if (index >= value.length) {
        return _Json_expecting(
          "a LONGER array. Need index " +
            index +
            " but only see " +
            value.length +
            " entries",
          value,
        );
      }
      var result = _Json_runHelp(decoder.b, value[index]);
      return $gren_lang$core$Result$isOk(result)
        ? result
        : $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$Index({ index: index, error: result.a }));

    case 7:
      if (typeof value !== "object" || value === null || _Json_isArray(value)) {
        return _Json_expecting("an OBJECT", value);
      }

      var keyValuePairs = [];
      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          var result = _Json_runHelp(decoder.b, value[key]);
          if (!$gren_lang$core$Result$isOk(result)) {
            return $gren_lang$core$Result$Err(
              $gren_lang$core$Json$Decode$Field({ name: key, error: result.a }),
            );
          }
          keyValuePairs.push({ key: key, value: result.a });
        }
      }
      return $gren_lang$core$Result$Ok(keyValuePairs);

    case 8:
      var answer = decoder.f;
      var decoders = decoder.g;
      for (var i = 0; i < decoders.length; i++) {
        var result = _Json_runHelp(decoders[i], value);
        if (!$gren_lang$core$Result$isOk(result)) {
          return result;
        }
        answer = answer(result.a);
      }
      return $gren_lang$core$Result$Ok(answer);

    case 9:
      var result = _Json_runHelp(decoder.b, value);
      return !$gren_lang$core$Result$isOk(result)
        ? result
        : _Json_runHelp(decoder.h(result.a), value);

    case 10:
      var errors = [];

      var decoders = decoder.g;
      for (var idx = 0; idx < decoders.length; idx++) {
        var result = _Json_runHelp(decoders[idx], value);
        if ($gren_lang$core$Result$isOk(result)) {
          return result;
        }
        errors.push(result.a);
      }

      return $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$OneOf(errors));

    case 1:
      return $gren_lang$core$Result$Err(
        $gren_lang$core$Json$Decode$Failure({
          message: decoder.a,
          value: _Json_wrap(value),
        }),
      );

    case 0:
      return $gren_lang$core$Result$Ok(decoder.a);
  }
}

function _Json_runArrayDecoder(decoder, value) {
  var len = value.length;
  var array = new Array(len);
  for (var i = 0; i < len; i++) {
    var result = _Json_runHelp(decoder, value[i]);
    if (!$gren_lang$core$Result$isOk(result)) {
      return $gren_lang$core$Result$Err($gren_lang$core$Json$Decode$Index({ index: i, error: result.a }));
    }
    array[i] = result.a;
  }
  return $gren_lang$core$Result$Ok(array);
}

function _Json_isArray(value) {
  return (
    Array.isArray(value) ||
    (typeof FileList !== "undefined" && value instanceof FileList)
  );
}

function _Json_expecting(type, value) {
  return $gren_lang$core$Result$Err(
    $gren_lang$core$Json$Decode$Failure({
      message: "Expecting " + type,
      value: _Json_wrap(value),
    }),
  );
}

// EQUALITY

function _Json_equality(x, y) {
  if (x === y) {
    return true;
  }

  if (x.$ !== y.$) {
    return false;
  }

  switch (x.$) {
    case 0:
    case 1:
      return x.a === y.a;

    case 2:
      return x.b === y.b;

    case 4:
      return x.c === y.c;

    case 3:
    case 7:
      return _Json_equality(x.b, y.b);

    case 5:
      return (
        x.d === y.d && _Json_equality(x.b, y.b)
      );

    case 6:
      return (
        x.e === y.e && _Json_equality(x.b, y.b)
      );

    case 8:
      return (
        x.f === y.f && _Json_arrayEquality(x.g, y.g)
      );

    case 9:
      return (
        x.h === y.h &&
        _Json_equality(x.b, y.b)
      );

    case 10:
      return _Json_arrayEquality(x.g, y.g);
  }
}

function _Json_arrayEquality(aDecoders, bDecoders) {
  var len = aDecoders.length;
  if (len !== bDecoders.length) {
    return false;
  }
  for (var i = 0; i < len; i++) {
    if (!_Json_equality(aDecoders[i], bDecoders[i])) {
      return false;
    }
  }
  return true;
}

// ENCODE

var _Json_encode = F2(function (indentLevel, value) {
  return JSON.stringify(_Json_unwrap(value), null, indentLevel) + "";
});

function _Json_wrap(value) {
  return { $: 0, a: value };
}
function _Json_unwrap(value) {
  return value.a;
}

function _Json_wrap_UNUSED(value) {
  return value;
}
function _Json_unwrap_UNUSED(value) {
  return value;
}

function _Json_emptyArray() {
  return [];
}
function _Json_emptyObject() {
  return {};
}

var _Json_addField = F3(function (key, value, object) {
  object[key] = _Json_unwrap(value);
  return object;
});

function _Json_addEntry(func) {
  return F2(function (entry, array) {
    array.push(_Json_unwrap(func(entry)));
    return array;
  });
}

var _Json_encodeNull = _Json_wrap(null);
var $gren_lang$core$Result$Err = function (a) {
	return { $: 'Err', a: a };
};
var $gren_lang$core$Json$Decode$Failure = function (a) {
	return { $: 'Failure', a: a };
};
var $gren_lang$core$Json$Decode$Field = function (a) {
	return { $: 'Field', a: a };
};
var $gren_lang$core$Json$Decode$Index = function (a) {
	return { $: 'Index', a: a };
};
var $gren_lang$core$Result$Ok = function (a) {
	return { $: 'Ok', a: a };
};
var $gren_lang$core$Json$Decode$OneOf = function (a) {
	return { $: 'OneOf', a: a };
};
var $gren_lang$core$Basics$False = { $: 'False' };


// MATH

var _Basics_add = F2(function (a, b) {
  return a + b;
});
var _Basics_sub = F2(function (a, b) {
  return a - b;
});
var _Basics_mul = F2(function (a, b) {
  return a * b;
});
var _Basics_fdiv = F2(function (a, b) {
  return a / b;
});
var _Basics_idiv = F2(function (a, b) {
  return Math.trunc(a / b);
});
var _Basics_pow = F2(Math.pow);

// MORE MATH

function _Basics_toFloat(x) {
  return x;
}
function _Basics_isInfinite(n) {
  return n === Infinity || n === -Infinity;
}

var _Basics_isNaN = isNaN;

// BOOLEANS

function _Basics_not(bool) {
  return !bool;
}
var _Basics_and = F2(function (a, b) {
  return a && b;
});
var _Basics_or = F2(function (a, b) {
  return a || b;
});
var _Basics_xor = F2(function (a, b) {
  return a !== b;
});
var $gren_lang$core$Basics$add = _Basics_add;


var _String_pushFirst = F2(function (char, string) {
  return char + string;
});

var _String_pushLast = F2(function (char, string) {
  return string + char;
});

var _String_popFirst = function (string) {
  if (string.length <= 0) {
    return $gren_lang$core$Maybe$Nothing;
  }

  var firstPointNumber = string.codePointAt(0);
  var firstChar = String.fromCodePoint(firstPointNumber);

  return $gren_lang$core$Maybe$Just({
    first: _Utils_chr(firstChar),
    rest: string.slice(firstChar.length),
  });
};

var _String_popLast = function (string) {
  if (string.length <= 0) {
    return $gren_lang$core$Maybe$Nothing;
  }

  var possibleLastPointIdx = string.length - 2;
  var possibleLastPoint = string.codePointAt(possibleLastPointIdx);

  if (possibleLastPoint === string.charCodeAt(possibleLastPointIdx)) {
    // last char is a unit
    return $gren_lang$core$Maybe$Just({
      last: _Utils_chr(string[string.length - 1]),
      rest: string.slice(string.length - 1),
    });
  }

  // last char is a point
  return $gren_lang$core$Maybe$Just({
    last: _Utils_chr(String.fromCodePoint(possibleLastPoint)),
    rest: string.slice(string.length - 2),
  });
};

var _String_append = F2(function (a, b) {
  return a + b;
});

var _String_repeat = F2(function (num, chunk) {
  try {
    return chunk.repeat(num);
  } catch (error) {
    if (error.name === "RangeError") {
      return "";
    } else {
      throw error;
    }
  }
});

var _String_foldl = F3(function (func, state, string) {
  for (let char of string) {
    state = A2(func, _Utils_chr(char), state);
  }

  return state;
});

var _String_foldr = F3(function (func, state, string) {
  let reversed = [];

  for (let char of string) {
    reversed.unshift(char);
  }

  for (let char of reversed) {
    state = A2(func, _Utils_chr(char), state);
  }

  return state;
});

var _String_split = F2(function (sep, str) {
  return str.split(sep);
});

var _String_join = F2(function (sep, strs) {
  return strs.join(sep);
});

var _String_slice = F3(function (start, end, str) {
  if (start < 0) {
    start = str.length + start;
  }

  if (end < 0) {
    end = str.length + end;
  }

  if (start >= end) {
    return "";
  }

  let index = 0;
  let result = "";

  for (let char of str) {
    if (index < start) {
      index++;
      continue;
    }

    if (index >= end) {
      break;
    }

    result += char;
    index++;
  }

  return result;
});

function _String_trim(str) {
  return str.trim();
}

function _String_trimLeft(str) {
  return str.replace(/^\s+/, "");
}

function _String_trimRight(str) {
  return str.replace(/\s+$/, "");
}

function _String_words(str) {
  return str.trim().split(/\s+/g);
}

function _String_lines(str) {
  return str.split(/\r\n|\r|\n/g);
}

function _String_toUpper(str) {
  return str.toUpperCase();
}

function _String_toLower(str) {
  return str.toLowerCase();
}

var _String_any = F2(function (isGood, string) {
  for (let char of string) {
    if (isGood(_Utils_chr(char))) {
      return true;
    }
  }

  return false;
});

var _String_contains = F2(function (sub, str) {
  return str.indexOf(sub) > -1;
});

var _String_startsWith = F2(function (sub, str) {
  return str.indexOf(sub) === 0;
});

var _String_endsWith = F2(function (sub, str) {
  return (
    str.length >= sub.length && str.lastIndexOf(sub) === str.length - sub.length
  );
});

var _String_indexOf = F2(function (sub, str) {
  var ret = str.indexOf(sub);

  if (ret > -1) {
    return $gren_lang$core$Maybe$Just(ret);
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _String_lastIndexOf = F2(function (sub, str) {
  var ret = str.lastIndexOf(sub);

  if (ret > -1) {
    return $gren_lang$core$Maybe$Just(ret);
  }

  return $gren_lang$core$Maybe$Nothing;
});

var _String_indexes = F2(function (sub, str) {
  var subLen = sub.length;

  if (subLen < 1) {
    return [];
  }

  var i = 0;
  var is = [];

  while ((i = str.indexOf(sub, i)) > -1) {
    is.push(i);
    i = i + subLen;
  }

  return is;
});

// TO STRING

function _String_fromNumber(number) {
  return number + "";
}

// INT CONVERSIONS

function _String_toInt(str) {
  var total = 0;
  var code0 = str.charCodeAt(0);
  var start = code0 == 0x2b /* + */ || code0 == 0x2d /* - */ ? 1 : 0;

  for (var i = start; i < str.length; ++i) {
    var code = str.charCodeAt(i);
    if (code < 0x30 || 0x39 < code) {
      return $gren_lang$core$Maybe$Nothing;
    }
    total = 10 * total + code - 0x30;
  }

  return i == start
    ? $gren_lang$core$Maybe$Nothing
    : $gren_lang$core$Maybe$Just(code0 == 0x2d ? -total : total);
}

// FLOAT CONVERSIONS

function _String_toFloat(s) {
  // check if it is a hex, octal, or binary number
  if (s.length === 0 || /[\sxbo]/.test(s)) {
    return $gren_lang$core$Maybe$Nothing;
  }
  var n = +s;
  // faster isNaN check
  return n === n ? $gren_lang$core$Maybe$Just(n) : $gren_lang$core$Maybe$Nothing;
}

function _String_fromArray(chars) {
  return chars.join("");
}

// UNITS

var _String_unitLength = function (str) {
  return str.length;
};

var _String_getUnit = F2(function (index, str) {
  var ret = str.at(index);

  if (typeof ret === "undefined") {
    return $gren_lang$core$Maybe$Nothing;
  }

  return $gren_lang$core$Maybe$Just(_Utils_chr(char));
});

var _String_foldlUnits = F3(function (fn, state, str) {
  for (let i = 0; i < str.length; i++) {
    state = A2(fn, str[i], state);
  }

  return state;
});

var _String_foldrUnits = F3(function (fn, state, str) {
  for (let i = str.length - 1; i < 0; i--) {
    state = A2(fn, str[i], state);
  }

  return state;
});
var $gren_lang$core$String$any = _String_any;
var $gren_lang$core$Basics$composeL$ = function(g, f) {
	return function(x) {
		return g(f(x));
	};
};
var $gren_lang$core$Basics$composeL = F2($gren_lang$core$Basics$composeL$);
var $gren_lang$core$Basics$not = _Basics_not;
var $gren_lang$core$String$all$ = function(isGood, str) {
	return !A2($gren_lang$core$String$any, $gren_lang$core$Basics$composeL$($gren_lang$core$Basics$not, isGood), str);
};
var $gren_lang$core$String$all = F2($gren_lang$core$String$all$);
var $gren_lang$core$Basics$and = _Basics_and;
var $gren_lang$core$Basics$append = _Utils_append;
var $gren_lang$core$Json$Encode$encode = _Json_encode;
var $gren_lang$core$String$fromInt = _String_fromNumber;
var $gren_lang$core$String$join = _String_join;
var $gren_lang$core$String$split = _String_split;
var $gren_lang$core$Json$Decode$indent = function(str) {
	return A2($gren_lang$core$String$join, '\n    ', A2($gren_lang$core$String$split, '\n', str));
};
var $gren_lang$core$Array$indexedMap = _Array_indexedMap;
var $gren_lang$core$Basics$le = _Utils_le;


function _Char_toCode(char) {
  return char.codePointAt(0);
}

function _Char_fromCode(code) {
  return _Utils_chr(String.fromCodePoint(code));
}
var $gren_lang$core$Char$toCode = _Char_toCode;
var $gren_lang$core$Char$isLower = function(_char) {
	var code = $gren_lang$core$Char$toCode(_char);
	return (97 <= code) && (code <= 122);
};
var $gren_lang$core$Char$isUpper = function(_char) {
	var code = $gren_lang$core$Char$toCode(_char);
	return (code <= 90) && (65 <= code);
};
var $gren_lang$core$Basics$or = _Basics_or;
var $gren_lang$core$Char$isAlpha = function(_char) {
	return $gren_lang$core$Char$isLower(_char) || $gren_lang$core$Char$isUpper(_char);
};
var $gren_lang$core$Char$isDigit = function(_char) {
	var code = $gren_lang$core$Char$toCode(_char);
	return (code <= 57) && (48 <= code);
};
var $gren_lang$core$Char$isAlphaNum = function(_char) {
	return $gren_lang$core$Char$isLower(_char) || ($gren_lang$core$Char$isUpper(_char) || $gren_lang$core$Char$isDigit(_char));
};
var $gren_lang$core$String$popFirst = _String_popFirst;
var $gren_lang$core$Json$Decode$errorOneOf$ = function(i, error) {
	return '\n\n(' + ($gren_lang$core$String$fromInt(i + 1) + (') ' + $gren_lang$core$Json$Decode$indent($gren_lang$core$Json$Decode$errorToString(error))));
};
var $gren_lang$core$Json$Decode$errorOneOf = F2($gren_lang$core$Json$Decode$errorOneOf$);
var $gren_lang$core$Json$Decode$errorToString = function(error) {
	return $gren_lang$core$Json$Decode$errorToStringHelp$(error, [  ]);
};
var $gren_lang$core$Json$Decode$errorToStringHelp$ = function(error, context) {
	errorToStringHelp:
	while (true) {
		switch (error.$) {
			case 'Field':
				var _v1 = error.a;
				var f = _v1.name;
				var err = _v1.error;
				var isSimple = function () {
					var _v2 = $gren_lang$core$String$popFirst(f);
					if (_v2.$ === 'Nothing') {
						return false;
					} else {
						var _v3 = _v2.a;
						var _char = _v3.first;
						var rest = _v3.rest;
						return $gren_lang$core$Char$isAlpha(_char) && $gren_lang$core$String$all$($gren_lang$core$Char$isAlphaNum, rest);
					}
				}();
				var fieldName = isSimple ? ('.' + f) : ('[\'' + (f + '\']'));
				var $temp$error = err,
				$temp$context = _Utils_ap([ fieldName ], context);
				error = $temp$error;
				context = $temp$context;
				continue errorToStringHelp;
			case 'Index':
				var _v4 = error.a;
				var i = _v4.index;
				var err = _v4.error;
				var indexName = '[' + ($gren_lang$core$String$fromInt(i) + ']');
				var $temp$error = err,
				$temp$context = _Utils_ap([ indexName ], context);
				error = $temp$error;
				context = $temp$context;
				continue errorToStringHelp;
			case 'OneOf':
				var errors = error.a;
				switch (errors.length) {
					case 0:
						return 'Ran into a Json.Decode.oneOf with no possibilities' + function () {
							if (context.length === 0) {
								return '!';
							} else {
								return ' at json' + A2($gren_lang$core$String$join, '', context);
							}
						}();
					case 1:
						var err = errors[0];
						var $temp$error = err,
						$temp$context = context;
						error = $temp$error;
						context = $temp$context;
						continue errorToStringHelp;
					default:
						var starter = function () {
							if (context.length === 0) {
								return 'Json.Decode.oneOf';
							} else {
								return 'The Json.Decode.oneOf at json' + A2($gren_lang$core$String$join, '', context);
							}
						}();
						var introduction = starter + (' failed in the following ' + ($gren_lang$core$String$fromInt($gren_lang$core$Array$length(errors)) + ' ways:'));
						return A2($gren_lang$core$String$join, '\n\n', _Utils_ap([ introduction ], A2($gren_lang$core$Array$indexedMap, $gren_lang$core$Json$Decode$errorOneOf, errors)));
				}
			default:
				var _v8 = error.a;
				var msg = _v8.message;
				var json = _v8.value;
				var introduction = function () {
					if (context.length === 0) {
						return 'Problem with the given value:\n\n';
					} else {
						return 'Problem with the value at json' + (A2($gren_lang$core$String$join, '', context) + ':\n\n    ');
					}
				}();
				return introduction + ($gren_lang$core$Json$Decode$indent(A2($gren_lang$core$Json$Encode$encode, 4, json)) + ('\n\n' + msg));
		}
	}
};
var $gren_lang$core$Json$Decode$errorToStringHelp = F2($gren_lang$core$Json$Decode$errorToStringHelp$);
var $gren_lang$core$Basics$True = { $: 'True' };
var $gren_lang$core$Result$isOk = function(result) {
	if (result.$ === 'Ok') {
		return true;
	} else {
		return false;
	}
};


function _Process_sleep(time) {
  return _Scheduler_binding(function (callback) {
    var id = setTimeout(function () {
      callback(_Scheduler_succeed({}));
    }, time);

    return function () {
      clearTimeout(id);
    };
  });
}
var $gren_lang$core$Dict$RBEmpty_gren_builtin = { $: 'RBEmpty_gren_builtin' };
var $gren_lang$core$Dict$empty = $gren_lang$core$Dict$RBEmpty_gren_builtin;
var $gren_lang$core$Basics$never = function(_v0) {
	never:
	while (true) {
		var nvr = _v0.a;
		var $temp$_v0 = nvr;
		_v0 = $temp$_v0;
		continue never;
	}
};
var $gren_lang$core$Task$Perform = function (a) {
	return { $: 'Perform', a: a };
};
var $gren_lang$core$Task$succeed = _Scheduler_succeed;
var $gren_lang$core$Task$init = $gren_lang$core$Task$succeed({  });
var $gren_lang$core$Array$map = _Array_map;
var $gren_lang$core$Task$map$ = function(func, taskA) {
	return A2($gren_lang$core$Task$andThen, function(a) {
			return $gren_lang$core$Task$succeed(func(a));
		}, taskA);
};
var $gren_lang$core$Task$map = F2($gren_lang$core$Task$map$);
var $gren_lang$core$Array$foldr = _Array_foldr;
var $gren_lang$core$Array$pushFirst$ = function(value, array) {
	return A4(_Array_splice1, 0, 0, value, array);
};
var $gren_lang$core$Array$pushFirst = F2($gren_lang$core$Array$pushFirst$);
var $gren_lang$core$Task$sequence = A2($gren_lang$core$Array$foldr, F2(function(task, combined) {
			return A2($gren_lang$core$Task$andThen, function(x) {
					return $gren_lang$core$Task$map$($gren_lang$core$Array$pushFirst(x), combined);
				}, task);
		}), $gren_lang$core$Task$succeed([  ]));
var $gren_lang$core$Platform$sendToApp = _Platform_sendToApp;
var $gren_lang$core$Task$spawnCmd$ = function(router, cmd) {
	switch (cmd.$) {
		case 'Perform':
			var task = cmd.a;
			return _Scheduler_spawn(A2($gren_lang$core$Task$andThen, $gren_lang$core$Platform$sendToApp(router), task));
		case 'ExecuteCmd':
			var task = cmd.a;
			return _Scheduler_spawn(A2($gren_lang$core$Task$andThen, _Platform_executeCmd(router), task));
		default:
			var task = cmd.a;
			return _Scheduler_spawn(task);
	}
};
var $gren_lang$core$Task$spawnCmd = F2($gren_lang$core$Task$spawnCmd$);
var $gren_lang$core$Task$onEffects$ = function(router, commands, state) {
	return $gren_lang$core$Task$map$(function(_v0) {
			return {  };
		}, $gren_lang$core$Task$sequence(A2($gren_lang$core$Array$map, $gren_lang$core$Task$spawnCmd(router), commands)));
};
var $gren_lang$core$Task$onEffects = F3($gren_lang$core$Task$onEffects$);
var $gren_lang$core$Task$onSelfMsg$ = function(_v0, _v1, _v2) {
	return $gren_lang$core$Task$succeed({  });
};
var $gren_lang$core$Task$onSelfMsg = F3($gren_lang$core$Task$onSelfMsg$);
var $gren_lang$core$Task$Execute = function (a) {
	return { $: 'Execute', a: a };
};
var $gren_lang$core$Task$ExecuteCmd = function (a) {
	return { $: 'ExecuteCmd', a: a };
};
var $gren_lang$core$Platform$Cmd$map = _Platform_map;
var $gren_lang$core$Task$cmdMap$ = function(tagger, cmd) {
	switch (cmd.$) {
		case 'Perform':
			var task = cmd.a;
			return $gren_lang$core$Task$Perform($gren_lang$core$Task$map$(tagger, task));
		case 'ExecuteCmd':
			var task = cmd.a;
			return $gren_lang$core$Task$ExecuteCmd($gren_lang$core$Task$map$($gren_lang$core$Platform$Cmd$map(tagger), task));
		default:
			var task = cmd.a;
			return $gren_lang$core$Task$Execute(task);
	}
};
var $gren_lang$core$Task$cmdMap = F2($gren_lang$core$Task$cmdMap$);
_Platform_effectManagers['Task'] = _Platform_createManager($gren_lang$core$Task$init, $gren_lang$core$Task$onEffects, $gren_lang$core$Task$onSelfMsg, $gren_lang$core$Task$cmdMap);
var $gren_lang$core$Task$command = _Platform_leaf('Task');
var $gren_lang$core$Task$perform$ = function(toMessage, task) {
	return $gren_lang$core$Task$command($gren_lang$core$Task$Perform($gren_lang$core$Task$map$(toMessage, task)));
};
var $gren_lang$core$Task$perform = F2($gren_lang$core$Task$perform$);
var $gren_lang$core$Dict$Black = { $: 'Black' };
var $gren_lang$core$Dict$RBNode_gren_builtin = function (a) {
	return { $: 'RBNode_gren_builtin', a: a };
};
var $gren_lang$core$Dict$node$ = function(color, key, value, left, right) {
	return $gren_lang$core$Dict$RBNode_gren_builtin({ color: color, key: key, left: left, right: right, value: value });
};
var $gren_lang$core$Dict$node = F5($gren_lang$core$Dict$node$);
var $gren_lang$core$Dict$Red = { $: 'Red' };
var $gren_lang$core$Dict$balance$ = function(color, key, value, left, right) {
	if ((right.$ === 'RBNode_gren_builtin') && (right.a.color.$ === 'Red')) {
		var _v1 = right.a;
		var _v2 = _v1.color;
		var rK = _v1.key;
		var rV = _v1.value;
		var rLeft = _v1.left;
		var rRight = _v1.right;
		if ((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Red')) {
			var _v4 = left.a;
			var _v5 = _v4.color;
			var lK = _v4.key;
			var lV = _v4.value;
			var lLeft = _v4.left;
			var lRight = _v4.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, lK, lV, lLeft, lRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, rK, rV, rLeft, rRight));
		} else {
			return $gren_lang$core$Dict$node$(color, rK, rV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, left, rLeft), rRight);
		}
	} else {
		if ((((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Red')) && (left.a.left.$ === 'RBNode_gren_builtin')) && (left.a.left.a.color.$ === 'Red')) {
			var _v7 = left.a;
			var _v8 = _v7.color;
			var lK = _v7.key;
			var lV = _v7.value;
			var _v9 = _v7.left.a;
			var _v10 = _v9.color;
			var llK = _v9.key;
			var llV = _v9.value;
			var llLeft = _v9.left;
			var llRight = _v9.right;
			var lRight = _v7.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, llK, llV, llLeft, llRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, key, value, lRight, right));
		} else {
			return $gren_lang$core$Dict$node$(color, key, value, left, right);
		}
	}
};
var $gren_lang$core$Dict$balance = F5($gren_lang$core$Dict$balance$);
var $gren_lang$core$Basics$compare = _Utils_compare;
var $gren_lang$core$Dict$setHelp$ = function(key, value, dict) {
	if (dict.$ === 'RBEmpty_gren_builtin') {
		return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, $gren_lang$core$Dict$RBEmpty_gren_builtin, $gren_lang$core$Dict$RBEmpty_gren_builtin);
	} else {
		var _v1 = dict.a;
		var nColor = _v1.color;
		var nKey = _v1.key;
		var nValue = _v1.value;
		var nLeft = _v1.left;
		var nRight = _v1.right;
		var _v2 = A2($gren_lang$core$Basics$compare, key, nKey);
		switch (_v2.$) {
			case 'LT':
				return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, $gren_lang$core$Dict$setHelp$(key, value, nLeft), nRight);
			case 'EQ':
				return $gren_lang$core$Dict$node$(nColor, nKey, value, nLeft, nRight);
			default:
				return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, nLeft, $gren_lang$core$Dict$setHelp$(key, value, nRight));
		}
	}
};
var $gren_lang$core$Dict$setHelp = F3($gren_lang$core$Dict$setHelp$);
var $gren_lang$core$Dict$set$ = function(setKey, setValue, dict) {
	var _v0 = $gren_lang$core$Dict$setHelp$(setKey, setValue, dict);
	if ((_v0.$ === 'RBNode_gren_builtin') && (_v0.a.color.$ === 'Red')) {
		var _v1 = _v0.a;
		var _v2 = _v1.color;
		var key = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var right = _v1.right;
		return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, key, value, left, right);
	} else {
		var x = _v0;
		return x;
	}
};
var $gren_lang$core$Dict$set = F3($gren_lang$core$Dict$set$);
var $gren_lang$node$Node$Arm = { $: 'Arm' };
var $gren_lang$node$Node$Arm64 = { $: 'Arm64' };
var $gren_lang$node$Node$IA32 = { $: 'IA32' };
var $gren_lang$node$Node$Mips = { $: 'Mips' };
var $gren_lang$node$Node$Mipsel = { $: 'Mipsel' };
var $gren_lang$node$Node$PPC = { $: 'PPC' };
var $gren_lang$node$Node$PPC64 = { $: 'PPC64' };
var $gren_lang$node$Node$S390 = { $: 'S390' };
var $gren_lang$node$Node$S390x = { $: 'S390x' };
var $gren_lang$node$Node$UnknownArchitecture = function (a) {
	return { $: 'UnknownArchitecture', a: a };
};
var $gren_lang$node$Node$X64 = { $: 'X64' };
var $gren_lang$core$String$toLower = _String_toLower;
var $gren_lang$node$Node$archFromString = function(arch) {
	var _v0 = $gren_lang$core$String$toLower(arch);
	switch (_v0) {
		case 'arm':
			return $gren_lang$node$Node$Arm;
		case 'arm64':
			return $gren_lang$node$Node$Arm64;
		case 'ia32':
			return $gren_lang$node$Node$IA32;
		case 'mips':
			return $gren_lang$node$Node$Mips;
		case 'mipsel':
			return $gren_lang$node$Node$Mipsel;
		case 'ppc':
			return $gren_lang$node$Node$PPC;
		case 'ppc64':
			return $gren_lang$node$Node$PPC64;
		case 's390':
			return $gren_lang$node$Node$S390;
		case 's390x':
			return $gren_lang$node$Node$S390x;
		case 'x64':
			return $gren_lang$node$Node$X64;
		default:
			return $gren_lang$node$Node$UnknownArchitecture(arch);
	}
};
var $gren_lang$node$Node$Aix = { $: 'Aix' };
var $gren_lang$node$Node$Darwin = { $: 'Darwin' };
var $gren_lang$node$Node$FreeBSD = { $: 'FreeBSD' };
var $gren_lang$node$Node$Linux = { $: 'Linux' };
var $gren_lang$node$Node$OpenBSD = { $: 'OpenBSD' };
var $gren_lang$node$Node$SunOS = { $: 'SunOS' };
var $gren_lang$node$Node$UnknownPlatform = function (a) {
	return { $: 'UnknownPlatform', a: a };
};
var $gren_lang$node$Node$Win32 = { $: 'Win32' };
var $gren_lang$node$Node$platformFromString = function(platform) {
	var _v0 = $gren_lang$core$String$toLower(platform);
	switch (_v0) {
		case 'win32':
			return $gren_lang$node$Node$Win32;
		case 'darwin':
			return $gren_lang$node$Node$Darwin;
		case 'linux':
			return $gren_lang$node$Node$Linux;
		case 'freebsd':
			return $gren_lang$node$Node$FreeBSD;
		case 'openbsd':
			return $gren_lang$node$Node$OpenBSD;
		case 'sunos':
			return $gren_lang$node$Node$SunOS;
		case 'aix':
			return $gren_lang$node$Node$Aix;
		default:
			return $gren_lang$node$Node$UnknownPlatform(platform);
	}
};
var $gren_lang$node$Node$initializeEnvironment = $gren_lang$core$Task$map$(function(raw) {
		return { applicationPath: raw.applicationPath, args: raw.args, cpuArchitecture: $gren_lang$node$Node$archFromString(raw.arch), platform: $gren_lang$node$Node$platformFromString(raw.platform), stderr: raw.stderr, stdin: raw.stdin, stdout: raw.stdout };
	}, _Node_init);
var $gren_lang$node$Node$unwrap = function(_v0) {
	var task = _v0.a;
	return task;
};
var $gren_lang$node$Node$initProgram$ = function(initTask, _v0) {
	return { command: $gren_lang$core$Task$perform$($gren_lang$node$Node$InitDone, A2($gren_lang$core$Task$andThen, function(env) {
				return $gren_lang$node$Node$unwrap(initTask(env));
			}, $gren_lang$node$Node$initializeEnvironment)), model: $gren_lang$node$Node$Uninitialized };
};
var $gren_lang$node$Node$initProgram = F2($gren_lang$node$Node$initProgram$);
var $gren_lang$node$Node$MsgReceived = function (a) {
	return { $: 'MsgReceived', a: a };
};
var $gren_lang$core$Platform$Sub$map = _Platform_map;
var $gren_lang$core$Platform$Sub$batch = _Platform_batch;
var $gren_lang$core$Platform$Sub$none = $gren_lang$core$Platform$Sub$batch([  ]);
var $gren_lang$node$Node$subscriptions$ = function(appSubs, model) {
	if (model.$ === 'Uninitialized') {
		return $gren_lang$core$Platform$Sub$none;
	} else {
		var appModel = model.a;
		return A2($gren_lang$core$Platform$Sub$map, $gren_lang$node$Node$MsgReceived, appSubs(appModel));
	}
};
var $gren_lang$node$Node$subscriptions = F2($gren_lang$node$Node$subscriptions$);
var $gren_lang$node$Node$Initialized = function (a) {
	return { $: 'Initialized', a: a };
};
var $gren_lang$core$Platform$Cmd$batch = _Platform_batch;
var $gren_lang$core$Platform$Cmd$none = $gren_lang$core$Platform$Cmd$batch([  ]);
var $gren_lang$node$Node$update$ = function(appUpdate, msg, model) {
	if (model.$ === 'Uninitialized') {
		if (msg.$ === 'InitDone') {
			var initResult = msg.a;
			return { command: A2($gren_lang$core$Platform$Cmd$map, $gren_lang$node$Node$MsgReceived, initResult.command), model: $gren_lang$node$Node$Initialized(initResult.model) };
		} else {
			return { command: $gren_lang$core$Platform$Cmd$none, model: model };
		}
	} else {
		var appModel = model.a;
		if (msg.$ === 'InitDone') {
			return { command: $gren_lang$core$Platform$Cmd$none, model: model };
		} else {
			var appMsg = msg.a;
			var updateResult = A2(appUpdate, appMsg, appModel);
			return { command: A2($gren_lang$core$Platform$Cmd$map, $gren_lang$node$Node$MsgReceived, updateResult.command), model: $gren_lang$node$Node$Initialized(updateResult.model) };
		}
	}
};
var $gren_lang$node$Node$update = F3($gren_lang$node$Node$update$);
var $gren_lang$core$Platform$worker = _Platform_worker;
var $gren_lang$node$Node$defineProgram = function(config) {
	return $gren_lang$core$Platform$worker({ init: $gren_lang$node$Node$initProgram(config.init), subscriptions: $gren_lang$node$Node$subscriptions(config.subscriptions), update: $gren_lang$node$Node$update(config.update) });
};
var $author$project$Main$ExistanceChecked = function (a) {
	return { $: 'ExistanceChecked', a: a };
};
var $gren_lang$core$Task$onError = _Scheduler_onError;
var $gren_lang$core$Task$attempt$ = function(resultToMessage, task) {
	return $gren_lang$core$Task$command($gren_lang$core$Task$Perform(A2($gren_lang$core$Task$onError, $gren_lang$core$Basics$composeL$($gren_lang$core$Basics$composeL$($gren_lang$core$Task$succeed, resultToMessage), $gren_lang$core$Result$Err), A2($gren_lang$core$Task$andThen, $gren_lang$core$Basics$composeL$($gren_lang$core$Basics$composeL$($gren_lang$core$Task$succeed, resultToMessage), $gren_lang$core$Result$Ok), task))));
};
var $gren_lang$core$Task$attempt = F2($gren_lang$core$Task$attempt$);
var $gren_lang$core$Basics$identity = function(x) {
	return x;
};
var $gren_lang$node$Internal$Init$Task = function (a) {
	return { $: 'Task', a: a };
};
var $gren_lang$node$Init$unwrap = function(_v0) {
	var task = _v0.a;
	return task;
};
var $gren_lang$node$Init$await$ = function(_v0, fn) {
	var task = _v0.a;
	return $gren_lang$node$Internal$Init$Task(A2($gren_lang$core$Task$andThen, $gren_lang$core$Basics$composeL$($gren_lang$node$Init$unwrap, fn), task));
};
var $gren_lang$node$Init$await = F2($gren_lang$node$Init$await$);
var $gren_lang$node$Init$awaitTask$ = function(task, fn) {
	return $gren_lang$node$Internal$Init$Task(A2($gren_lang$core$Task$andThen, $gren_lang$core$Basics$composeL$($gren_lang$node$Init$unwrap, fn), task));
};
var $gren_lang$node$Init$awaitTask = F2($gren_lang$node$Init$awaitTask$);
var $gren_lang$core$Array$prepend = _Array_append;
var $gren_lang$core$Array$append$ = function(fst, second) {
	return A2($gren_lang$core$Array$prepend, second, fst);
};
var $gren_lang$core$Array$append = F2($gren_lang$core$Array$append$);
var $gren_lang$core$Basics$eq = _Utils_equal;
var $gren_lang$core$String$isEmpty = function(string) {
	return string === '';
};
var $gren_lang$node$FileSystem$Path$filenameWithExtension = function(path) {
	return $gren_lang$core$String$isEmpty(path.extension) ? path.filename : (path.filename + ('.' + path.extension));
};
var $gren_lang$core$Array$keepIf = _Array_filter;
var $gren_lang$core$Basics$neq = _Utils_notEqual;
var $gren_lang$node$FileSystem$Path$prepend$ = function(left, right) {
	return _Utils_update(left, { directory: A2($gren_lang$core$Array$keepIf, function(dir) {
				return dir !== '';
			}, $gren_lang$core$Array$append$(right.directory, $gren_lang$core$Array$pushLast$($gren_lang$node$FileSystem$Path$filenameWithExtension(left), left.directory))), extension: right.extension, filename: right.filename });
};
var $gren_lang$node$FileSystem$Path$prepend = F2($gren_lang$node$FileSystem$Path$prepend$);
var $gren_lang$node$FileSystem$Path$append$ = function(left, right) {
	return $gren_lang$node$FileSystem$Path$prepend$(right, left);
};
var $gren_lang$node$FileSystem$Path$append = F2($gren_lang$node$FileSystem$Path$append$);
var $gren_lang$node$FileSystem$Path$fromPosixString = _FilePath_fromPosix;
var $gren_lang$node$FileSystem$Path$fromWin32String = _FilePath_fromWin32;
var $gren_lang$core$Dict$get$ = function(targetKey, dict) {
	get:
	while (true) {
		if (dict.$ === 'RBEmpty_gren_builtin') {
			return $gren_lang$core$Maybe$Nothing;
		} else {
			var _v1 = dict.a;
			var key = _v1.key;
			var value = _v1.value;
			var left = _v1.left;
			var right = _v1.right;
			var _v2 = A2($gren_lang$core$Basics$compare, targetKey, key);
			switch (_v2.$) {
				case 'LT':
					var $temp$targetKey = targetKey,
					$temp$dict = left;
					targetKey = $temp$targetKey;
					dict = $temp$dict;
					continue get;
				case 'EQ':
					return $gren_lang$core$Maybe$Just(value);
				default:
					var $temp$targetKey = targetKey,
					$temp$dict = right;
					targetKey = $temp$targetKey;
					dict = $temp$dict;
					continue get;
			}
		}
	}
};
var $gren_lang$core$Dict$get = F2($gren_lang$core$Dict$get$);
var $gren_lang$core$Maybe$map$ = function(f, maybe) {
	if (maybe.$ === 'Just') {
		var value = maybe.a;
		return $gren_lang$core$Maybe$Just(f(value));
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$core$Maybe$map = F2($gren_lang$core$Maybe$map$);
var $gren_lang$compiler_node$Compiler$Backend$version = '0.5.2';
var $gren_lang$core$Maybe$withDefault$ = function(_default, maybe) {
	if (maybe.$ === 'Just') {
		var value = maybe.a;
		return value;
	} else {
		return _default;
	}
};
var $gren_lang$core$Maybe$withDefault = F2($gren_lang$core$Maybe$withDefault$);
var $gren_lang$compiler_node$Compiler$Backend$cachePath$ = function(platform, envVars, homeDir) {
	var startPath = function () {
		switch (platform.$) {
			case 'Win32':
				return $gren_lang$core$Maybe$withDefault$($gren_lang$node$FileSystem$Path$prepend$(homeDir, $gren_lang$node$FileSystem$Path$fromPosixString('AppData/Local')), $gren_lang$core$Maybe$map$($gren_lang$node$FileSystem$Path$fromWin32String, $gren_lang$core$Dict$get$('LOCALAPPDATA', envVars)));
			case 'Darwin':
				return $gren_lang$node$FileSystem$Path$prepend$(homeDir, $gren_lang$node$FileSystem$Path$fromPosixString('Library/Caches'));
			default:
				return $gren_lang$core$Maybe$withDefault$($gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('.cache'), homeDir), $gren_lang$core$Maybe$map$($gren_lang$node$FileSystem$Path$fromPosixString, $gren_lang$core$Dict$get$('XDG_CACHE_HOME', envVars)));
		}
	}();
	var filename = function () {
		if (platform.$ === 'Win32') {
			return 'gren.exe';
		} else {
			return 'gren';
		}
	}();
	var endPath = $gren_lang$node$FileSystem$Path$fromPosixString(A2($gren_lang$core$String$join, '/', [ 'gren', $gren_lang$compiler_node$Compiler$Backend$version, 'bin', filename ]));
	return $gren_lang$node$FileSystem$Path$prepend$(startPath, endPath);
};
var $gren_lang$compiler_node$Compiler$Backend$cachePath = F3($gren_lang$compiler_node$Compiler$Backend$cachePath$);


var fs = require("node:fs");
var bufferNs = require("node:buffer");
var process = require("node:process");
var path = require("node:path");
var os = require("node:os");
var stream = require("node:stream");

var _FileSystem_coerce = function (fh) {
  return fh;
};

var _FileSystem_open = F2(function (access, path) {
  return _Scheduler_binding(function (callback) {
    fs.open(_FilePath_toString(path), access, function (err, fd) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed({ path: path, fd: fd }));
      }
    });
  });
});

var _FileSystem_constructError = function (path, err) {
  return $gren_lang$node$FileSystem$Error({
    path: path,
    code: err.code || "",
    message: err.message || "",
  });
};

var _FileSystem_close = function (fh) {
  return _Scheduler_binding(function (callback) {
    fs.close(fh.fd, function (err) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(fh.path, err)));
      } else {
        callback(_Scheduler_succeed({}));
      }
    });
  });
};

var _FileSystem_readFromOffset = F2(function (fh, options) {
  var requestedLength =
    options.length < 0 || options.length > bufferNs.constants.MAX_LENGTH
      ? bufferNs.constants.MAX_LENGTH
      : options.length;

  var fileOffset = options.offset < 0 ? 0 : options.offset;

  return _Scheduler_binding(function (callback) {
    var initialBufferSize =
      requestedLength === bufferNs.constants.MAX_LENGTH
        ? 16 * 1024
        : requestedLength;
    var buffer = Buffer.allocUnsafe(initialBufferSize);

    _FileSystem_readHelper(
      fh,
      buffer,
      0,
      fileOffset,
      buffer.byteLength,
      requestedLength,
      callback,
    );
  });
});

var _FileSystem_readHelper = function (
  fh,
  buffer,
  bufferOffset,
  fileOffset,
  maxReadLength,
  requestedReadLength,
  callback,
) {
  fs.read(
    fh.fd,
    buffer,
    bufferOffset,
    maxReadLength,
    fileOffset,
    function (err, bytesRead, _buff) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(fh.path, err)));
        return;
      }

      var newBufferOffset = bufferOffset + bytesRead;

      if (bytesRead === 0 || newBufferOffset >= requestedReadLength) {
        callback(
          _Scheduler_succeed(
            new DataView(buffer.buffer, buffer.byteOffset, newBufferOffset),
          ),
        );
        return;
      }

      var newMaxReadLength = maxReadLength - bytesRead;
      if (newMaxReadLength <= 0) {
        var oldBuffer = buffer;
        buffer = Buffer.allocUnsafe(oldBuffer.byteLength * 1.5);
        oldBuffer.copy(buffer);

        newMaxReadLength = buffer.byteLength - oldBuffer.byteLength;
      }

      _FileSystem_readHelper(
        fh,
        buffer,
        newBufferOffset,
        fileOffset + bytesRead,
        newMaxReadLength,
        requestedReadLength,
        callback,
      );
    },
  );
};

var _FileSystem_writeFromOffset = F3(function (fh, options, bytes) {
  return _Scheduler_binding(function (callback) {
    _FileSystem_writeHelper(
      fh,
      bytes,
      0,
      bytes.byteLength,
      options.offset,
      callback,
    );
  });
});

var _FileSystem_writeHelper = function (
  fh,
  buffer,
  bufferOffset,
  length,
  fileOffset,
  callback,
) {
  fs.write(
    fh.fd,
    buffer,
    bufferOffset,
    length,
    fileOffset,
    function (err, bytesWritten, buffer) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(fh.path, err)));
        return;
      }

      if (bytesWritten === length) {
        callback(_Scheduler_succeed(fh));
        return;
      }

      var newBufferOffset = bufferOffset + bytesWritten;
      var newFileOffset = fileOffset + bytesWritten;

      _FileSystem_writeHelper(
        fh,
        buffer,
        newBufferOffset,
        length - bytesWritten,
        newFileOffset,
        callback,
      );
    },
  );
};

var _FileSystem_remove = F2(function (options, path) {
  var rmOpts = {
    recursive: options.recursive,
  };

  return _Scheduler_binding(function (callback) {
    fs.rm(_FilePath_toString(path), rmOpts, function (err) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_makeDirectory = F2(function (options, path) {
  return _Scheduler_binding(function (callback) {
    fs.mkdir(
      _FilePath_toString(path),
      { recursive: options.recursive },
      function (err) {
        if (err != null) {
          callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
        } else {
          callback(_Scheduler_succeed(path));
        }
      },
    );
  });
});

// List of dir contents as DirEntry values holding filename string
var _FileSystem_listDirectory = function (path) {
  return _Scheduler_binding(function (callback) {
    fs.readdir(
      _FilePath_toString(path),
      { withFileTypes: true },
      function (err, content) {
        if (err != null) {
          callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
        } else {
          callback(
            _Scheduler_succeed(
              content.map((f) => ({
                path: _FilePath_fromString(f.name),
                entityType: _FileSystem_toEntityType(f),
              })),
            ),
          );
        }
      },
    );
  });
};

var _FileSystem_toEntityType = function (dirEnt) {
  if (dirEnt.isFile()) {
    return $gren_lang$node$FileSystem$File;
  } else if (dirEnt.isDirectory()) {
    return $gren_lang$node$FileSystem$Directory;
  } else if (dirEnt.isFIFO()) {
    return $gren_lang$node$FileSystem$Pipe;
  } else if (dirEnt.isSocket()) {
    return $gren_lang$node$FileSystem$Socket;
  } else if (dirEnt.isSymbolicLink()) {
    return $gren_lang$node$FileSystem$Symlink;
  } else {
    return $gren_lang$node$FileSystem$Device;
  }
};

var _FileSystem_fchmod = F2(function (mode, fd) {
  return _Scheduler_binding(function (callback) {
    fs.fchmod(fd.fd, mode, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(fd.path, err)));
      } else {
        callback(_Scheduler_succeed(fd));
      }
    });
  });
});

var _FileSystem_fchown = F2(function (ids, fd) {
  return _Scheduler_binding(function (callback) {
    fs.fchown(fd.fd, ids.userID, ids.groupID, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(fd.path, err)));
      } else {
        callback(_Scheduler_succeed(fd));
      }
    });
  });
});

var _FileSystem_fdatasync = function (fd) {
  return _Scheduler_binding(function (callback) {
    fs.fdatasync(fd.fd, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(fd.path, err)));
      } else {
        callback(_Scheduler_succeed(fd));
      }
    });
  });
};

var _FileSystem_fsync = function (fd) {
  return _Scheduler_binding(function (callback) {
    fs.fsync(fd.fd, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(fd.path, err)));
      } else {
        callback(_Scheduler_succeed(fd));
      }
    });
  });
};

var _FileSystem_fstat = function (fd) {
  return _Scheduler_binding(function (callback) {
    fs.fstat(fd.fd, function (err, stats) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(fd.path, err)));
      } else {
        callback(_Scheduler_succeed(_FileSystem_statToGrenRecord(stats)));
      }
    });
  });
};

var _FileSystem_ftruncate = F2(function (len, fd) {
  return _Scheduler_binding(function (callback) {
    fs.ftruncate(fd.fd, len, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(fd.path, err)));
      } else {
        callback(_Scheduler_succeed(fd));
      }
    });
  });
});

var _FileSystem_futimes = F3(function (atime, mtime, fd) {
  return _Scheduler_binding(function (callback) {
    fs.futimes(fd.fd, atime, mtime, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(fd.path, err)));
      } else {
        callback(_Scheduler_succeed(fd));
      }
    });
  });
});

var _FileSystem_access = F2(function (permissions, path) {
  var mode = fs.constants.F_OK;

  if (permissions.includes($gren_lang$node$FileSystem$Read)) {
    mode = mode | fs.constants.R_OK;
  }

  if (permissions.includes($gren_lang$node$FileSystem$Write)) {
    mode = mode | fs.constants.W_OK;
  }

  if (permissions.includes($gren_lang$node$FileSystem$Execute)) {
    mode = mode | fs.constants.X_OK;
  }

  return _Scheduler_binding(function (callback) {
    fs.access(_FilePath_toString(path), mode, function (err) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_appendFile = F2(function (data, path) {
  return _Scheduler_binding(function (callback) {
    fs.appendFile(_FilePath_toString(path), data, function (err) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_chmod = F2(function (mode, path) {
  return _Scheduler_binding(function (callback) {
    fs.chmod(_FilePath_toString(path), mode, function (err) {
      if (err != null) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_chown = F2(function (ids, path) {
  return _Scheduler_binding(function (callback) {
    fs.chown(
      _FilePath_toString(path),
      ids.userID,
      ids.groupID,
      function (err) {
        if (err) {
          callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
        } else {
          callback(_Scheduler_succeed(path));
        }
      },
    );
  });
});

var _FileSystem_lchown = F2(function (ids, path) {
  return _Scheduler_binding(function (callback) {
    fs.lchown(
      _FilePath_toString(path),
      ids.userID,
      ids.groupID,
      function (err) {
        if (err) {
          callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
        } else {
          callback(_Scheduler_succeed(path));
        }
      },
    );
  });
});

var _FileSystem_copyFile = F2(function (src, dest) {
  return _Scheduler_binding(function (callback) {
    fs.copyFile(
      _FilePath_toString(src),
      _FilePath_toString(dest),
      0,
      function (err) {
        if (err) {
          callback(_Scheduler_fail(_FileSystem_constructError(dest, err)));
        } else {
          callback(_Scheduler_succeed(dest));
        }
      },
    );
  });
});

var _FileSystem_link = F2(function (src, dest) {
  return _Scheduler_binding(function (callback) {
    fs.link(
      _FilePath_toString(src),
      _FilePath_toString(dest),
      function (err) {
        if (err) {
          callback(_Scheduler_fail(_FileSystem_constructError(dest, err)));
        } else {
          callback(_Scheduler_succeed(dest));
        }
      },
    );
  });
});

var _FileSystem_symlink = F2(function (src, dest) {
  return _Scheduler_binding(function (callback) {
    fs.symlink(
      _FilePath_toString(src),
      _FilePath_toString(dest),
      function (err) {
        if (err) {
          callback(_Scheduler_fail(_FileSystem_constructError(dest, err)));
        } else {
          callback(_Scheduler_succeed(dest));
        }
      },
    );
  });
});

var _FileSystem_unlink = function (src) {
  return _Scheduler_binding(function (callback) {
    fs.unlink(_FilePath_toString(src), function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(src, err)));
      } else {
        callback(_Scheduler_succeed(src));
      }
    });
  });
};

var _FileSystem_mkdtemp = function (prefix) {
  return _Scheduler_binding(function (callback) {
    fs.mkdtemp(path.join(os.tmpdir(), prefix), function (err, dir) {
      if (err) {
        callback(
          _Scheduler_fail(
            _FileSystem_constructError(_FilePath_fromString(dir), err),
          ),
        );
      } else {
        callback(_Scheduler_succeed(_FilePath_fromString(dir)));
      }
    });
  });
};

var _FileSystem_readFile = function (path) {
  return _Scheduler_binding(function (callback) {
    fs.readFile(_FilePath_toString(path), function (err, data) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(
          _Scheduler_succeed(
            new DataView(data.buffer, data.byteOffset, data.byteLength),
          ),
        );
      }
    });
  });
};

var _FileSystem_readFileStream = F2(function (opts, path) {
  return _Scheduler_binding(function (callback) {
    try {
      var fstream = fs.createReadStream(_FilePath_toString(path), {
        start: opts.start,
        end: opts.end === -1 ? undefined : opts.end,
      });
      callback(_Scheduler_succeed(stream.Readable.toWeb(fstream)));
    } catch (err) {
      callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
    }
  });
});

var _FileSystem_readLink = function (path) {
  return _Scheduler_binding(function (callback) {
    fs.readlink(_FilePath_toString(path), function (err, linkedPath) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(_FilePath_fromString(linkedPath)));
      }
    });
  });
};

var _FileSystem_rename = F2(function (oldPath, newPath) {
  return _Scheduler_binding(function (callback) {
    fs.rename(
      _FilePath_toString(oldPath),
      _FilePath_toString(newPath),
      function (err) {
        if (err) {
          callback(_Scheduler_fail(_FileSystem_constructError(newPath, err)));
        } else {
          callback(_Scheduler_succeed(newPath));
        }
      },
    );
  });
});

var _FileSystem_realpath = function (path) {
  return _Scheduler_binding(function (callback) {
    fs.realpath(_FilePath_toString(path), function (err, resolvedPath) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(_FilePath_fromString(resolvedPath)));
      }
    });
  });
};

var _FileSystem_stat = function (path) {
  return _Scheduler_binding(function (callback) {
    fs.stat(_FilePath_toString(path), function (err, stats) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(_FileSystem_statToGrenRecord(stats)));
      }
    });
  });
};

var _FileSystem_lstat = function (path) {
  return _Scheduler_binding(function (callback) {
    fs.lstat(_FilePath_toString(path), function (err, stats) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(_FileSystem_statToGrenRecord(stats)));
      }
    });
  });
};

var _FileSystem_statToGrenRecord = function (stats) {
  return {
    entityType: _FileSystem_toEntityType(stats),
    blockSize: stats.blksize,
    blocks: stats.blocks,
    byteSize: stats.size,
    created: $gren_lang$core$Time$millisToPosix(Math.floor(stats.birthtimeMs)),
    deviceID: stats.dev,
    groupID: stats.gid,
    lastAccessed: $gren_lang$core$Time$millisToPosix(Math.floor(stats.atimeMs)),
    lastChanged: $gren_lang$core$Time$millisToPosix(Math.floor(stats.ctimeMs)),
    lastModified: $gren_lang$core$Time$millisToPosix(Math.floor(stats.mtimeMs)),
    userID: stats.uid,
  };
};

var _FileSystem_truncate = F2(function (len, path) {
  return _Scheduler_binding(function (callback) {
    fs.truncate(_FilePath_toString(path), len, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_utimes = F3(function (atime, mtime, path) {
  return _Scheduler_binding(function (callback) {
    fs.utimes(_FilePath_toString(path), atime, mtime, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_lutimes = F3(function (atime, mtime, path) {
  return _Scheduler_binding(function (callback) {
    fs.lutimes(_FilePath_toString(path), atime, mtime, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_writeFile = F2(function (data, path) {
  return _Scheduler_binding(function (callback) {
    fs.writeFile(_FilePath_toString(path), data, function (err) {
      if (err) {
        callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
      } else {
        callback(_Scheduler_succeed(path));
      }
    });
  });
});

var _FileSystem_writeFileStream = F2(function (pos, path) {
  return _Scheduler_binding(function (callback) {
    try {
      var fstream = fs.createWriteStream(_FilePath_toString(path), {
        flags: pos === 0 ? "w" : pos === -1 ? "a" : "r+",
        start: pos === 0 ? undefined : pos,
      });
      callback(_Scheduler_succeed(stream.Writable.toWeb(fstream)));
    } catch (err) {
      callback(_Scheduler_fail(_FileSystem_constructError(path, err)));
    }
  });
});

var _FileSystem_watch = F3(function (path, isRecursive, sendToSelf) {
  return _Scheduler_binding(function (_callback) {
    var watcher = null;

    try {
      watcher = fs.watch(
        path,
        { recursive: isRecursive },
        function (eventType, filename) {
          var maybePath = filename
            ? $gren_lang$core$Maybe$Just(_FilePath_fromString(filename))
            : $gren_lang$core$Maybe$Nothing;

          if (eventType === "rename") {
            _Scheduler_rawSpawn(sendToSelf($gren_lang$node$FileSystem$Moved(maybePath)));
          } else if (eventType === "change") {
            _Scheduler_rawSpawn(sendToSelf($gren_lang$node$FileSystem$Changed(maybePath)));
          }

          // other change types are ignored
        },
      );
    } catch (e) {
      // ignore errors
    }

    return function () {
      if (watcher) {
        watcher.close();
      }
    };
  });
});
var _FileSystem_homeDir = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(_FilePath_fromString(os.homedir())));
});

var _FileSystem_currentWorkingDirectory = _Scheduler_binding(
  function (callback) {
    callback(_Scheduler_succeed(_FilePath_fromString(process.cwd())));
  },
);

var _FileSystem_tmpDir = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(_FilePath_fromString(os.tmpdir())));
});

var _FileSystem_devNull = _Scheduler_binding(function (callback) {
  callback(_Scheduler_succeed(_FilePath_fromString(os.devNull)));
});
var $gren_lang$node$FileSystem$Changed = function (a) {
	return { $: 'Changed', a: a };
};
var $gren_lang$node$FileSystem$Device = { $: 'Device' };
var $gren_lang$node$FileSystem$Directory = { $: 'Directory' };
var $gren_lang$node$FileSystem$Error = function (a) {
	return { $: 'Error', a: a };
};
var $gren_lang$node$FileSystem$Execute = { $: 'Execute' };
var $gren_lang$node$FileSystem$File = { $: 'File' };
var $gren_lang$node$FileSystem$Moved = function (a) {
	return { $: 'Moved', a: a };
};
var $gren_lang$node$FileSystem$Pipe = { $: 'Pipe' };
var $gren_lang$node$FileSystem$Read = { $: 'Read' };
var $gren_lang$node$FileSystem$Socket = { $: 'Socket' };
var $gren_lang$node$FileSystem$Symlink = { $: 'Symlink' };
var $gren_lang$node$FileSystem$Write = { $: 'Write' };
var $gren_lang$core$Time$Posix = function (a) {
	return { $: 'Posix', a: a };
};
var $gren_lang$core$Time$millisToPosix = $gren_lang$core$Time$Posix;
var $gren_lang$node$FileSystem$checkAccess$ = function(_v0, permissions, path) {
	return A2(_FileSystem_access, permissions, path);
};
var $gren_lang$node$FileSystem$checkAccess = F3($gren_lang$node$FileSystem$checkAccess$);
var $gren_lang$compiler_node$Compiler$Backend$UnsupportedPlatform = { $: 'UnsupportedPlatform' };
var $gren_lang$compiler_node$Compiler$Backend$downloadUrl$ = function(platform, cpuArch) {
	var maybeFilename = function () {
		var _v1 = { cpuArch: cpuArch, platform: platform };
		_v1$4:
		while (true) {
			switch (_v1.cpuArch.$) {
				case 'Arm64':
					if (_v1.platform.$ === 'Darwin') {
						var _v6 = _v1.platform;
						var _v7 = _v1.cpuArch;
						return $gren_lang$core$Maybe$Just('gren_mac_aarch64');
					} else {
						break _v1$4;
					}
				case 'X64':
					switch (_v1.platform.$) {
						case 'Win32':
							var _v2 = _v1.platform;
							var _v3 = _v1.cpuArch;
							return $gren_lang$core$Maybe$Just('gren.exe');
						case 'Darwin':
							var _v4 = _v1.platform;
							var _v5 = _v1.cpuArch;
							return $gren_lang$core$Maybe$Just('gren_mac');
						case 'Linux':
							var _v8 = _v1.platform;
							var _v9 = _v1.cpuArch;
							return $gren_lang$core$Maybe$Just('gren_linux');
						default:
							break _v1$4;
					}
				default:
					break _v1$4;
			}
		}
		return $gren_lang$core$Maybe$Nothing;
	}();
	if (maybeFilename.$ === 'Just') {
		var filename = maybeFilename.a;
		return $gren_lang$core$Result$Ok(A2($gren_lang$core$String$join, '/', [ 'https://github.com/gren-lang/compiler/releases/download', 'blob-' + $gren_lang$compiler_node$Compiler$Backend$version, filename ]));
	} else {
		return $gren_lang$core$Result$Err($gren_lang$compiler_node$Compiler$Backend$UnsupportedPlatform);
	}
};
var $gren_lang$compiler_node$Compiler$Backend$downloadUrl = F2($gren_lang$compiler_node$Compiler$Backend$downloadUrl$);
var $gren_lang$core$Array$slice = _Array_slice;
var $gren_lang$core$Array$dropFirst$ = function(n, array) {
	return A3($gren_lang$core$Array$slice, n, $gren_lang$core$Array$length(array), array);
};
var $gren_lang$core$Array$dropFirst = F2($gren_lang$core$Array$dropFirst$);
var $gren_lang$core$Task$execute = function(task) {
	return $gren_lang$core$Task$command($gren_lang$core$Task$Execute($gren_lang$core$Task$map$(function(_v0) {
					return {  };
				}, task)));
};
var $gren_lang$node$Node$getEnvironmentVariables = _Node_getEnvironmentVariables;
var $gren_lang$node$FileSystem$homeDirectory = function(_v0) {
	return _FileSystem_homeDir;
};
var $gren_lang$node$ChildProcess$Permission = { $: 'Permission' };
var $gren_lang$node$ChildProcess$initialize = $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$succeed($gren_lang$node$ChildProcess$Permission));
var $gren_lang$node$FileSystem$Permission = { $: 'Permission' };
var $gren_lang$node$FileSystem$initialize = $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$succeed($gren_lang$node$FileSystem$Permission));
var $gren_lang$node$HttpClient$AnyPermission = { $: 'AnyPermission' };
var $gren_lang$node$HttpClient$initialize = $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$succeed($gren_lang$node$HttpClient$AnyPermission));


var process = require("node:process");

var _Terminal_init = _Scheduler_binding(function (callback) {
  callback(
    _Scheduler_succeed({
      isTTY: process.stdout.isTTY,
      colorDepth: process.stdout.getColorDepth
        ? process.stdout.getColorDepth()
        : 0,
      columns: process.stdout.columns,
      rows: process.stdout.rows,
    }),
  );
});

var _Terminal_attachListener = function (sendToApp) {
  return _Scheduler_binding(function (_callback) {
    var listener = function (data) {
      _Scheduler_rawSpawn(
        sendToApp({
          columns: process.stdout.columns,
          rows: process.stdout.rows,
        }),
      );
    };

    process.stdout.on("resize", listener);

    return function () {
      process.stdout.off("resize", listener);
      process.stdout.pause();
    };
  });
};

var _Terminal_setStdInRawMode = function (toggle) {
  return _Scheduler_binding(function (callback) {
    process.stdin.setRawMode(toggle);
    callback(_Scheduler_succeed({}));
  });
};

var _Terminal_setProcessTitle = function (title) {
  return _Scheduler_binding(function (callback) {
    process.title = title;
    callback(_Scheduler_succeed({}));
  });
};
var $gren_lang$node$Terminal$Permission = { $: 'Permission' };
var $gren_lang$node$Terminal$initialize = $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$map$(function(raw) {
			return raw.isTTY ? $gren_lang$core$Maybe$Just({ colorDepth: raw.colorDepth, columns: raw.columns, permission: $gren_lang$node$Terminal$Permission, rows: raw.rows }) : $gren_lang$core$Maybe$Nothing;
		}, _Terminal_init));


var _Stream_read = function (stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    const reader = stream.getReader();
    reader
      .read()
      .then(({ done, value }) => {
        reader.releaseLock();

        if (done) {
          return callback(_Scheduler_fail($gren_lang$core$Stream$Closed));
        }

        if (value instanceof Uint8Array) {
          value = new DataView(
            value.buffer,
            value.byteOffset,
            value.byteLength,
          );
        }

        callback(_Scheduler_succeed(value));
      })
      .catch((err) => {
        reader.releaseLock();
        callback(
          _Scheduler_fail(
            $gren_lang$core$Stream$Cancelled(_Stream_cancellationErrorString(err)),
          ),
        );
      });
  });
};

var _Stream_cancellationErrorString = function (err) {
  if (err instanceof Error) {
    return err.toString();
  }

  if (typeof err === "string") {
    return err;
  }

  return "Unknown error";
};

var _Stream_write = F2(function (value, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    if (value instanceof DataView) {
      value = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
    }

    const writer = stream.getWriter();
    writer.ready
      .then(() => {
        const writePromise = writer.write(value);
        writer.releaseLock();
        return writePromise;
      })
      .then(() => {
        callback(_Scheduler_succeed(stream));
      })
      .catch((err) => {
        callback(
          _Scheduler_fail(
            $gren_lang$core$Stream$Cancelled(_Stream_cancellationErrorString(err)),
          ),
        );
      });
  });
});

var _Stream_enqueue = F2(function (value, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    if (value instanceof DataView) {
      value = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
    }

    const writer = stream.getWriter();
    writer.ready.then(() => {
      writer.write(value);
      writer.releaseLock();

      callback(_Scheduler_succeed(stream));
    });
  });
});

var _Stream_cancelReadable = F2(function (reason, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    stream.cancel(reason).then(() => {
      callback(_Scheduler_succeed({}));
    });
  });
});

var _Stream_cancelWritable = F2(function (reason, stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    stream.abort(reason).then(() => {
      callback(_Scheduler_succeed({}));
    });
  });
});

var _Stream_closeWritable = function (stream) {
  return _Scheduler_binding(function (callback) {
    if (stream.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    const writer = stream.getWriter();
    writer.close();
    writer.releaseLock();

    callback(_Scheduler_succeed({}));
  });
};

var _Stream_pipeThrough = F2(function (transformer, readable) {
  return _Scheduler_binding(function (callback) {
    if (readable.locked || transformer.writable.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    const transformedReader = readable.pipeThrough(transformer);
    return callback(_Scheduler_succeed(transformedReader));
  });
});

var _Stream_pipeTo = F2(function (writable, readable) {
  return _Scheduler_binding(function (callback) {
    if (readable.locked || writable.locked) {
      return callback(_Scheduler_fail($gren_lang$core$Stream$Locked));
    }

    readable
      .pipeTo(writable)
      .then(() => {
        callback(_Scheduler_succeed({}));
      })
      .catch((err) => {
        callback(
          _Scheduler_fail(
            $gren_lang$core$Stream$Cancelled(_Stream_cancellationErrorString(err)),
          ),
        );
      });
  });
});

var _Stream_identityTransformation = F2(function (readCapacity, writeCapacity) {
  return _Scheduler_binding(function (callback) {
    const transformStream = new TransformStream(
      {},
      new CountQueuingStrategy({ highWaterMark: writeCapacity }),
      new CountQueuingStrategy({ highWaterMark: readCapacity }),
    );

    return callback(_Scheduler_succeed(transformStream));
  });
});

var _Stream_customTransformation = F4(
  function (toAction, initState, readCapacity, writeCapacity) {
    return _Scheduler_binding(function (callback) {
      const transformStream = new TransformStream(
        {
          start() {
            this.state = initState;
          },
          transform(chunk, controller) {
            if (chunk instanceof Uint8Array) {
              chunk = new DataView(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            }

            const action = A2(toAction, this.state, chunk);
            switch (action.ctor) {
              case "UpdateState":
                this.state = action.state;
                break;
              case "Send":
                this.state = action.state;
                for (let value of action.send) {
                  if (value instanceof DataView) {
                    value = new Uint8Array(
                      value.buffer,
                      value.byteOffset,
                      value.byteLength,
                    );
                  }

                  controller.enqueue(value);
                }
                break;
              case "Close":
                for (let value of action.send) {
                  if (value instanceof DataView) {
                    value = new Uint8Array(
                      value.buffer,
                      value.byteOffset,
                      value.byteLength,
                    );
                  }

                  controller.enqueue(value);
                }
                controller.terminate();
                break;
              case "Cancel":
                controller.error(action.cancelReason);
                break;
            }
          },
        },
        new CountQueuingStrategy({ highWaterMark: writeCapacity }),
        new CountQueuingStrategy({ highWaterMark: readCapacity }),
      );

      return callback(_Scheduler_succeed(transformStream));
    });
  },
);

var _Stream_readable = function (transformStream) {
  return transformStream.readable;
};

var _Stream_writable = function (transformStream) {
  return transformStream.writable;
};

var _Stream_textEncoder = _Scheduler_binding(function (callback) {
  return callback(_Scheduler_succeed(new TextEncoderStream()));
});

var _Stream_textDecoder = _Scheduler_binding(function (callback) {
  return callback(_Scheduler_succeed(new TextDecoderStream()));
});

var _Stream_compressor = function (algo) {
  return _Scheduler_binding(function (callback) {
    return callback(_Scheduler_succeed(new CompressionStream(algo)));
  });
};

var _Stream_decompressor = function (algo) {
  return _Scheduler_binding(function (callback) {
    return callback(_Scheduler_succeed(new DecompressionStream(algo)));
  });
};
var $gren_lang$core$Stream$Cancelled = function (a) {
	return { $: 'Cancelled', a: a };
};
var $gren_lang$core$Stream$Closed = { $: 'Closed' };
var $gren_lang$core$Stream$Locked = { $: 'Locked' };
var $gren_lang$core$Stream$write = _Stream_write;
var $gren_lang$core$Stream$Log$bytes$ = function(stream, data) {
	return A2($gren_lang$core$Task$onError, function(_v1) {
			return $gren_lang$core$Task$succeed({  });
		}, A2($gren_lang$core$Task$andThen, function(_v0) {
				return $gren_lang$core$Task$succeed({  });
			}, A2($gren_lang$core$Stream$write, data, stream)));
};
var $gren_lang$core$Stream$Log$bytes = F2($gren_lang$core$Stream$Log$bytes$);


// BYTES

var _Bytes_empty = new DataView(new ArrayBuffer(0));

function _Bytes_length(bytes) {
  return bytes.byteLength;
}

var _Bytes_getHostEndianness = F2(function (le, be) {
  return _Scheduler_binding(function (callback) {
    callback(
      _Scheduler_succeed(
        new Uint8Array(new Uint32Array([1]))[0] === 1 ? le : be,
      ),
    );
  });
});

function _Bytes_fromString(str) {
  var encoder = new TextEncoder();
  var uint8s = encoder.encode(str);
  return new DataView(uint8s.buffer);
}

function _Bytes_toString(bytes) {
  var decoder = new TextDecoder("utf-8", { fatal: true });

  try {
    return $gren_lang$core$Maybe$Just(decoder.decode(bytes));
  } catch (e) {
    return $gren_lang$core$Maybe$Nothing;
  }
}

function _Bytes_flatten(arrayOfBytes) {
  var requiredSize = 0;
  for (var i = 0; i < arrayOfBytes.length; i++) {
    requiredSize += arrayOfBytes[i].byteLength;
  }

  var offset = 0;
  var result = new Uint8Array(requiredSize);

  for (var i = 0; i < arrayOfBytes.length; i++) {
    var currentBytes = new Uint8Array(arrayOfBytes[i].buffer);
    var currentByteLength = arrayOfBytes[i].byteLength;

    for (var j = 0; j < currentByteLength; j++) {
      result[offset] = currentBytes[j];
      offset++;
    }
  }

  return new DataView(result.buffer);
}

// ENCODERS

function _Bytes_encode(encoder) {
  var mutableBytes = new DataView(new ArrayBuffer($gren_lang$core$Bytes$Encode$getLength(encoder)));
  A3($gren_lang$core$Bytes$Encode$write, encoder, mutableBytes, 0);
  return mutableBytes;
}

// SIGNED INTEGERS

var _Bytes_write_i8 = F3(function (mb, i, n) {
  mb.setInt8(i, n);
  return i + 1;
});
var _Bytes_write_i16 = F4(function (mb, i, n, isLE) {
  mb.setInt16(i, n, isLE);
  return i + 2;
});
var _Bytes_write_i32 = F4(function (mb, i, n, isLE) {
  mb.setInt32(i, n, isLE);
  return i + 4;
});

// UNSIGNED INTEGERS

var _Bytes_write_u8 = F3(function (mb, i, n) {
  mb.setUint8(i, n);
  return i + 1;
});
var _Bytes_write_u16 = F4(function (mb, i, n, isLE) {
  mb.setUint16(i, n, isLE);
  return i + 2;
});
var _Bytes_write_u32 = F4(function (mb, i, n, isLE) {
  mb.setUint32(i, n, isLE);
  return i + 4;
});

// FLOATS

var _Bytes_write_f32 = F4(function (mb, i, n, isLE) {
  mb.setFloat32(i, n, isLE);
  return i + 4;
});
var _Bytes_write_f64 = F4(function (mb, i, n, isLE) {
  mb.setFloat64(i, n, isLE);
  return i + 8;
});

// BYTES

var _Bytes_write_bytes = F3(function (mb, offset, bytes) {
  for (var i = 0, len = bytes.byteLength, limit = len - 4; i <= limit; i += 4) {
    mb.setUint32(offset + i, bytes.getUint32(i));
  }
  for (; i < len; i++) {
    mb.setUint8(offset + i, bytes.getUint8(i));
  }
  return offset + len;
});

// DECODER

var _Bytes_decode = F2(function (decoder, bytes) {
  try {
    return $gren_lang$core$Maybe$Just(A2(decoder, bytes, 0).value);
  } catch (e) {
    if (e instanceof RangeError) {
      return $gren_lang$core$Maybe$Nothing;
    } else {
      throw e;
    }
  }
});

var _Bytes_read_i8 = F2(function (bytes, offset) {
  return { offset: offset + 1, value: bytes.getInt8(offset) };
});
var _Bytes_read_i16 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 2, value: bytes.getInt16(offset, isLE) };
});
var _Bytes_read_i32 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 4, value: bytes.getInt32(offset, isLE) };
});
var _Bytes_read_u8 = F2(function (bytes, offset) {
  return { offset: offset + 1, value: bytes.getUint8(offset) };
});
var _Bytes_read_u16 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 2, value: bytes.getUint16(offset, isLE) };
});
var _Bytes_read_u32 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 4, value: bytes.getUint32(offset, isLE) };
});
var _Bytes_read_f32 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 4, value: bytes.getFloat32(offset, isLE) };
});
var _Bytes_read_f64 = F3(function (isLE, bytes, offset) {
  return { offset: offset + 8, value: bytes.getFloat64(offset, isLE) };
});

var _Bytes_read_bytes = F3(function (len, bytes, offset) {
  return {
    offset: offset + len,
    value: new DataView(bytes.buffer, bytes.byteOffset + offset, len),
  };
});

var _Bytes_decodeFailure = F2(function () {
  throw 0;
});
var $gren_lang$core$Bytes$Encode$getLength = function(builder) {
	switch (builder.$) {
		case 'I8':
			return 1;
		case 'I16':
			return 2;
		case 'I32':
			return 4;
		case 'U8':
			return 1;
		case 'U16':
			return 2;
		case 'U32':
			return 4;
		case 'F32':
			return 4;
		case 'F64':
			return 8;
		case 'Seq':
			var w = builder.a.width;
			return w;
		default:
			var bs = builder.a;
			return _Bytes_length(bs);
	}
};
var $gren_lang$core$Bytes$LE = { $: 'LE' };
var $gren_lang$core$Array$foldl = _Array_foldl;
var $gren_lang$core$Bytes$Encode$write$ = function(builder, mb, offset) {
	switch (builder.$) {
		case 'I8':
			var n = builder.a;
			return A3(_Bytes_write_i8, mb, offset, n);
		case 'I16':
			var _v1 = builder.a;
			var e = _v1.endian;
			var n = _v1.number;
			return A4(_Bytes_write_i16, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'I32':
			var _v2 = builder.a;
			var e = _v2.endian;
			var n = _v2.number;
			return A4(_Bytes_write_i32, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'U8':
			var n = builder.a;
			return A3(_Bytes_write_u8, mb, offset, n);
		case 'U16':
			var _v3 = builder.a;
			var e = _v3.endian;
			var n = _v3.number;
			return A4(_Bytes_write_u16, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'U32':
			var _v4 = builder.a;
			var e = _v4.endian;
			var n = _v4.number;
			return A4(_Bytes_write_u32, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'F32':
			var _v5 = builder.a;
			var e = _v5.endian;
			var n = _v5.number;
			return A4(_Bytes_write_f32, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'F64':
			var _v6 = builder.a;
			var e = _v6.endian;
			var n = _v6.number;
			return A4(_Bytes_write_f64, mb, offset, n, _Utils_eq(e, $gren_lang$core$Bytes$LE));
		case 'Seq':
			var bs = builder.a.items;
			return $gren_lang$core$Bytes$Encode$writeSequence$(bs, mb, offset);
		default:
			var bs = builder.a;
			return A3(_Bytes_write_bytes, mb, offset, bs);
	}
};
var $gren_lang$core$Bytes$Encode$write = F3($gren_lang$core$Bytes$Encode$write$);
var $gren_lang$core$Bytes$Encode$writeSequence$ = function(builders, mb, offset) {
	return A3($gren_lang$core$Array$foldl, F2(function(builder, currentOffset) {
				return $gren_lang$core$Bytes$Encode$write$(builder, mb, currentOffset);
			}), offset, builders);
};
var $gren_lang$core$Bytes$Encode$writeSequence = F3($gren_lang$core$Bytes$Encode$writeSequence$);
var $gren_lang$core$Bytes$fromString = _Bytes_fromString;
var $gren_lang$core$Stream$Log$string$ = function(stream, data) {
	return $gren_lang$core$Stream$Log$bytes$(stream, $gren_lang$core$Bytes$fromString(data));
};
var $gren_lang$core$Stream$Log$string = F2($gren_lang$core$Stream$Log$string$);
var $gren_lang$core$Stream$Log$line$ = function(stream, data) {
	return $gren_lang$core$Stream$Log$string$(stream, data + '\n');
};
var $gren_lang$core$Stream$Log$line = F2($gren_lang$core$Stream$Log$line$);
var $gren_lang$core$Result$map$ = function(func, ra) {
	if (ra.$ === 'Ok') {
		var a = ra.a;
		return $gren_lang$core$Result$Ok(func(a));
	} else {
		var e = ra.a;
		return $gren_lang$core$Result$Err(e);
	}
};
var $gren_lang$core$Result$map = F2($gren_lang$core$Result$map$);
var $gren_lang$core$Dict$member$ = function(key, dict) {
	var _v0 = $gren_lang$core$Dict$get$(key, dict);
	if (_v0.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$core$Dict$member = F2($gren_lang$core$Dict$member$);
var $gren_lang$node$Node$startProgram = function(initResult) {
	return $gren_lang$node$Internal$Init$Task($gren_lang$core$Task$succeed(initResult));
};
var $gren_lang$core$Result$toMaybe = function(result) {
	if (result.$ === 'Ok') {
		var v = result.a;
		return $gren_lang$core$Maybe$Just(v);
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$node$FileSystem$Path$toPosixString = _FilePath_toPosix;
var $gren_lang$node$FileSystem$Path$toWin32String = _FilePath_toWin32;
var $author$project$Main$init = function(env) {
	return $gren_lang$node$Init$await$($gren_lang$node$FileSystem$initialize, function(fsPermission) {
			return $gren_lang$node$Init$await$($gren_lang$node$ChildProcess$initialize, function(cpPermission) {
					return $gren_lang$node$Init$await$($gren_lang$node$HttpClient$initialize, function(httpPermission) {
							return $gren_lang$node$Init$await$($gren_lang$node$Terminal$initialize, function(terminalConfig) {
									return $gren_lang$node$Init$awaitTask$($gren_lang$node$Node$getEnvironmentVariables, function(envVars) {
											return $gren_lang$node$Init$awaitTask$($gren_lang$node$FileSystem$homeDirectory(fsPermission), function(homeDir) {
													var userArgs = $gren_lang$core$Array$dropFirst$(2, env.args);
													var maybePaths = function () {
														var _v2 = { override: $gren_lang$core$Dict$get$('GREN_BIN', envVars), platform: env.platform };
														if (_v2.override.$ === 'Just') {
															if (_v2.platform.$ === 'Win32') {
																var overridePath = _v2.override.a;
																var _v3 = _v2.platform;
																return $gren_lang$core$Maybe$Just({ localPath: $gren_lang$node$FileSystem$Path$fromWin32String(overridePath), remotePath: $gren_lang$core$Maybe$Nothing });
															} else {
																var overridePath = _v2.override.a;
																return $gren_lang$core$Maybe$Just({ localPath: $gren_lang$node$FileSystem$Path$fromPosixString(overridePath), remotePath: $gren_lang$core$Maybe$Nothing });
															}
														} else {
															return $gren_lang$core$Result$toMaybe($gren_lang$core$Result$map$(function(url) {
																		return { localPath: $gren_lang$compiler_node$Compiler$Backend$cachePath$(env.platform, envVars, homeDir), remotePath: $gren_lang$core$Maybe$Just(url) };
																	}, $gren_lang$compiler_node$Compiler$Backend$downloadUrl$(env.platform, env.cpuArchitecture)));
														}
													}();
													var interactiveTerminal = !_Utils_eq(terminalConfig, $gren_lang$core$Maybe$Nothing);
													var useColor = interactiveTerminal && (!$gren_lang$core$Dict$member$('NO_COLOR', envVars));
													return $gren_lang$node$Node$startProgram({ command: function () {
															if (maybePaths.$ === 'Just') {
																var paths = maybePaths.a;
																return $gren_lang$core$Task$attempt$(function(result) {
																		return $author$project$Main$ExistanceChecked({ existanceResult: result, localPath: paths.localPath, maybeRemotePath: paths.remotePath });
																	}, $gren_lang$node$FileSystem$checkAccess$(fsPermission, [  ], paths.localPath));
															} else {
																return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(env.stderr, 'We currently don\'t support this platform/arch.'));
															}
														}(), model: { args: userArgs, backendPath: function () {
															if (maybePaths.$ === 'Nothing') {
																return $gren_lang$compiler_node$Compiler$Backend$cachePath$(env.platform, envVars, homeDir);
															} else {
																var paths = maybePaths.a;
																return paths.localPath;
															}
														}(), cpPermission: cpPermission, fsPermission: fsPermission, httpPermission: httpPermission, interactive: interactiveTerminal, pathToString: _Utils_eq(env.platform, $gren_lang$node$Node$Win32) ? $gren_lang$node$FileSystem$Path$toWin32String : $gren_lang$node$FileSystem$Path$toPosixString, stderr: env.stderr, stdin: env.stdin, stdout: env.stdout, useColor: useColor } });
												});
										});
								});
						});
				});
		});
};
var $gren_lang$core$Json$Decode$succeed = _Json_succeed;
var $author$project$Main$CompilerDownloaded = function (a) {
	return { $: 'CompilerDownloaded', a: a };
};
var $author$project$Main$CompilerInstalled = function (a) {
	return { $: 'CompilerInstalled', a: a };
};
var $author$project$Main$RedirectTerminalIO = function (a) {
	return { $: 'RedirectTerminalIO', a: a };
};
var $author$project$Main$RunExited = function (a) {
	return { $: 'RunExited', a: a };
};
var $author$project$Main$RunStarted = function (a) {
	return { $: 'RunStarted', a: a };
};
var $gren_lang$core$Array$findFirst = _Array_findFirst;
var $gren_lang$core$Array$member$ = function(value, array) {
	var _v0 = A2($gren_lang$core$Array$findFirst, function(v) {
			return _Utils_eq(v, value);
		}, array);
	if (_v0.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$core$Array$member = F2($gren_lang$core$Array$member$);
var $gren_lang$node$FileSystem$accessPermissionsToInt = function(values) {
	var numberFor = F2(function(num, a) {
			return $gren_lang$core$Array$member$(a, values) ? num : 0;
		});
	return (A2(numberFor, 4, $gren_lang$node$FileSystem$Read) + A2(numberFor, 2, $gren_lang$node$FileSystem$Write)) + A2(numberFor, 1, $gren_lang$node$FileSystem$Execute);
};
var $gren_lang$node$FileSystem$changeAccess$ = function(_v0, permissions, path) {
	var mode = _Utils_ap($gren_lang$core$String$fromInt($gren_lang$node$FileSystem$accessPermissionsToInt(permissions.owner)), _Utils_ap($gren_lang$core$String$fromInt($gren_lang$node$FileSystem$accessPermissionsToInt(permissions.group)), $gren_lang$core$String$fromInt($gren_lang$node$FileSystem$accessPermissionsToInt(permissions.others))));
	return A2(_FileSystem_chmod, mode, path);
};
var $gren_lang$node$FileSystem$changeAccess = F3($gren_lang$node$FileSystem$changeAccess$);
var $gren_lang$core$Stream$closeWritable = _Stream_closeWritable;
var $gren_lang$node$HttpClient$ExpectBytes = { $: 'ExpectBytes' };
var $gren_lang$node$HttpClient$expectBytes = function(req) {
	return { body: req.body, expect: $gren_lang$node$HttpClient$ExpectBytes, headers: req.headers, method: req.method, timeout: req.timeout, url: req.url };
};
var $gren_lang$node$HttpServer$GET = { $: 'GET' };
var $gren_lang$node$HttpClient$BodyEmpty = { $: 'BodyEmpty' };
var $gren_lang$node$HttpClient$ExpectAnything = { $: 'ExpectAnything' };
var $gren_lang$core$Basics$mul = _Basics_mul;
var $gren_lang$node$HttpClient$defaultTimeout = 10 * 1000;
var $gren_lang$node$HttpClient$request$ = function(method, url) {
	return { body: $gren_lang$node$HttpClient$BodyEmpty, expect: $gren_lang$node$HttpClient$ExpectAnything, headers: $gren_lang$core$Dict$empty, method: method, timeout: $gren_lang$node$HttpClient$defaultTimeout, url: url };
};
var $gren_lang$node$HttpClient$request = F2($gren_lang$node$HttpClient$request$);
var $gren_lang$node$HttpClient$get = function(url) {
	return $gren_lang$node$HttpClient$request$($gren_lang$node$HttpServer$GET, url);
};


var buffer = require("node:buffer").Buffer;

function _HttpClient_clientForProtocol(config) {
  if (config.url.startsWith("http://")) {
    return require("node:http");
  }

  return require("node:https");
}

var _HttpClient_request = function (config) {
  return _Scheduler_binding(function (callback) {
    let req = null;
    try {
      const client = _HttpClient_clientForProtocol(config);
      req = client.request(config.url, {
        method: config.method,
        headers: A3(
          $gren_lang$core$Dict$foldl,
          _HttpClient_dictToObject,
          {},
          config.headers,
        ),
        timeout: config.timeout,
      });
    } catch (e) {
      if (e.code === "ERR_INVALID_HTTP_TOKEN") {
        return callback(_Scheduler_fail($gren_lang$node$HttpClient$BadHeaders));
      } else if (e.code === "ERR_INVALID_URL") {
        return callback(_Scheduler_fail($gren_lang$node$HttpClient$BadUrl(config.url)));
      } else {
        return callback(
          _Scheduler_fail(
            $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
          ),
        );
      }
    }

    req.on("timeout", () => {
      req.destroy(_HttpClient_CustomTimeoutError);
    });

    req.on("error", (e) => {
      if (e === _HttpClient_CustomTimeoutError) {
        return callback(_Scheduler_fail($gren_lang$node$HttpClient$Timeout));
      }

      return callback(
        _Scheduler_fail(
          $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
        ),
      );
    });

    req.on("response", (res) => {
      const expectType = config.expectType;
      const expectString = expectType === "STRING" || expectType === "JSON";

      if (expectString) {
        res.setEncoding("utf8");
      }

      let rawData = [];

      res.on("data", (chunk) => {
        rawData.push(chunk);
      });

      res.on("error", (e) => {
        return callback(
          _Scheduler_fail(
            $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
          ),
        );
      });

      res.on("end", () => {
        if (res.statusCode < 200 || res.statusCode >= 300) {
          const finalBuffer = expectString
            ? buffer.from(rawData.join(""))
            : buffer.concat(rawData);

          return callback(
            _Scheduler_fail(
              $gren_lang$node$HttpClient$BadStatus(
                _HttpClient_formatResponse(
                  res,
                  new DataView(
                    finalBuffer.buffer,
                    finalBuffer.byteOffset,
                    finalBuffer.byteLength,
                  ),
                ),
              ),
            ),
          );
        }

        switch (expectType) {
          case "NOTHING":
            if (rawData.length === 0) {
              return callback(
                _Scheduler_succeed(_HttpClient_formatResponse(res, {})),
              );
            } else {
              return callback(
                _Scheduler_fail(
                  $gren_lang$node$HttpClient$UnexpectedResponseBody(
                    "Received response body where I expected none.",
                  ),
                ),
              );
            }

          case "ANYTHING":
            return callback(
              _Scheduler_succeed(_HttpClient_formatResponse(res, {})),
            );

          case "STRING":
            return callback(
              _Scheduler_succeed(
                _HttpClient_formatResponse(res, rawData.join("")),
              ),
            );

          case "JSON":
            const jsonResult = A2(
              $gren_lang$core$Json$Decode$decodeString,
              config.expect.a,
              rawData.join(""),
            );
            if ($gren_lang$core$Result$isOk(jsonResult)) {
              return callback(
                _Scheduler_succeed(
                  _HttpClient_formatResponse(res, jsonResult.a),
                ),
              );
            } else {
              return callback(
                _Scheduler_fail(
                  $gren_lang$node$HttpClient$UnexpectedResponseBody(
                    $gren_lang$core$Json$Decode$errorToString(jsonResult.a),
                  ),
                ),
              );
            }

          case "BYTES":
            const finalBuffer = buffer.concat(rawData);

            return callback(
              _Scheduler_succeed(
                _HttpClient_formatResponse(
                  res,
                  new DataView(
                    finalBuffer.buffer,
                    finalBuffer.byteOffset,
                    finalBuffer.byteLength,
                  ),
                ),
              ),
            );
        }
      });
    });

    const body = _HttpClient_extractRequestBody(config);

    if (body != null) {
      req.end(body);
    } else {
      req.end();
    }
  });
};

var _HttpClient_stream = F4(function (cleanup, sendToApp, request, config) {
  return _Scheduler_binding(function (callback) {
    function send(msg) {
      return _Scheduler_rawSpawn(sendToApp(msg));
    }

    let req = null;
    try {
      const client = _HttpClient_clientForProtocol(config);
      req = client.request(config.url, {
        method: config.method,
        headers: A3(
          $gren_lang$core$Dict$foldl,
          _HttpClient_dictToObject,
          {},
          config.headers,
        ),
        timeout: config.timeout,
      });
    } catch (e) {
      callback(_Scheduler_succeed(request));

      if (e.code === "ERR_INVALID_HTTP_TOKEN") {
        send($gren_lang$node$HttpClient$Error($gren_lang$node$HttpClient$BadHeaders));
      } else if (e.code === "ERR_INVALID_URL") {
        send($gren_lang$node$HttpClient$Error($gren_lang$node$HttpClient$BadUrl(config.url)));
      } else {
        send(
          $gren_lang$node$HttpClient$Error(
            $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
          ),
        );
      }

      return _Scheduler_rawSpawn(cleanup(request));
    }

    req.on("timeout", () => {
      req.destroy(_HttpClient_CustomTimeoutError);
    });

    req.on("error", (e) => {
      _Scheduler_rawSpawn(cleanup(request));

      if (e === _HttpClient_CustomTimeoutError) {
        send($gren_lang$node$HttpClient$Timeout);
      } else if (e === _HttpClient_CustomAbortError) {
        send($gren_lang$node$HttpClient$Aborted);
      } else {
        send($gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message));
      }
    });

    const body = _HttpClient_extractRequestBody(config);

    if (body == null) {
      send($gren_lang$node$HttpClient$SentChunk(request));
    } else {
      req.write(body, () => {
        send($gren_lang$node$HttpClient$SentChunk(request));
      });
    }

    return callback(
      _Scheduler_succeed({
        request: req,
        response: null,
      }),
    );
  });
});

var _HttpClient_sendChunk = F4(
  function (sendToApp, kernelRequest, request, bytes) {
    return _Scheduler_binding(function (callback) {
      if (!kernelRequest.request.writableEnded) {
        const chunk = _HttpClient_prepBytes(bytes);

        kernelRequest.request.write(chunk, () => {
          _Scheduler_rawSpawn(sendToApp($gren_lang$node$HttpClient$SentChunk(request)));
        });
      }

      return callback(_Scheduler_succeed({}));
    });
  },
);

var _HttpClient_startReceive = F4(
  function (cleanup, sendToApp, kernelRequest, request) {
    return _Scheduler_binding(function (callback) {
      if (kernelRequest.request.writableEnded) {
        return callback(_Scheduler_succeed({}));
      }
      kernelRequest.request.on("response", (res) => {
        kernelRequest.response = res;

        res.on("data", (bytes) => {
          return _Scheduler_rawSpawn(
            sendToApp(
              $gren_lang$node$HttpClient$ReceivedChunk({
                request: request,
                response: _HttpClient_formatResponse(
                  res,
                  new DataView(
                    bytes.buffer,
                    bytes.byteOffset,
                    bytes.byteLength,
                  ),
                ),
              }),
            ),
          );
        });

        res.on("error", (e) => {
          _Scheduler_rawSpawn(cleanup(request));
          _Scheduler_rawSpawn(
            sendToApp(
              $gren_lang$node$HttpClient$Error(
                $gren_lang$node$HttpClient$UnknownError("problem with request: " + e.message),
              ),
            ),
          );
        });

        res.on("end", () => {
          _Scheduler_rawSpawn(cleanup(request));
          _Scheduler_rawSpawn(sendToApp($gren_lang$node$HttpClient$Done));
        });
      });

      kernelRequest.request.end(() => {
        return callback(_Scheduler_succeed({}));
      });
    });
  },
);

var _HttpClient_abort = function (kernelRequest) {
  return _Scheduler_binding(function (callback) {
    if (!kernelRequest.request.writableEnded) {
      kernelRequest.request.destroy(_HttpClient_CustomAbortError);
    } else if (
      kernelRequest.response &&
      kernelRequest.response.complete === false
    ) {
      kernelRequest.response.destroy(_HttpClient_CustomAbortError);
    }

    return callback(_Scheduler_succeed({}));
  });
};

// HELPERS

var _HttpClient_dictToObject = F3(function (key, value, obj) {
  obj[key] = value;
  return obj;
});

var _HttpClient_extractRequestBody = function (config) {
  switch (config.bodyType) {
    case "EMPTY":
      return null;
    case "STRING":
      return config.body.a;
    case "BYTES":
      return _HttpClient_prepBytes(config.body.a);
  }
};

var _HttpClient_prepBytes = function (bytes) {
  return new Uint8Array(bytes.buffer);
};

var _HttpClient_CustomAbortError = new Error();

var _HttpClient_CustomTimeoutError = new Error();

var _HttpClient_formatResponse = function (res, data) {
  let headerDict = $gren_lang$core$Dict$empty;
  for (const [key, value] of Object.entries(res.headersDistinct)) {
    headerDict = A3($gren_lang$core$Dict$set, key.toLowerCase(), value, headerDict);
  }

  return {
    statusCode: res.statusCode,
    statusText: res.statusMessage,
    headers: headerDict,
    data: data,
  };
};
var $gren_lang$node$HttpClient$Aborted = { $: 'Aborted' };
var $gren_lang$node$HttpClient$BadHeaders = { $: 'BadHeaders' };
var $gren_lang$node$HttpClient$BadStatus = function (a) {
	return { $: 'BadStatus', a: a };
};
var $gren_lang$node$HttpClient$BadUrl = function (a) {
	return { $: 'BadUrl', a: a };
};
var $gren_lang$node$HttpClient$Done = { $: 'Done' };
var $gren_lang$node$HttpClient$Error = function (a) {
	return { $: 'Error', a: a };
};
var $gren_lang$node$HttpClient$ReceivedChunk = function (a) {
	return { $: 'ReceivedChunk', a: a };
};
var $gren_lang$node$HttpClient$SentChunk = function (a) {
	return { $: 'SentChunk', a: a };
};
var $gren_lang$node$HttpClient$Timeout = { $: 'Timeout' };
var $gren_lang$node$HttpClient$UnexpectedResponseBody = function (a) {
	return { $: 'UnexpectedResponseBody', a: a };
};
var $gren_lang$node$HttpClient$UnknownError = function (a) {
	return { $: 'UnknownError', a: a };
};
var $gren_lang$core$Json$Decode$decodeString = _Json_runOnString;
var $gren_lang$node$HttpClient$bodyTypeAsString = function(body) {
	switch (body.$) {
		case 'BodyEmpty':
			return 'EMPTY';
		case 'BodyString':
			return 'STRING';
		default:
			return 'BYTES';
	}
};
var $gren_lang$node$HttpClient$expectTypeAsString = function(expect) {
	switch (expect.$) {
		case 'ExpectNothing':
			return 'NOTHING';
		case 'ExpectAnything':
			return 'ANYTHING';
		case 'ExpectString':
			return 'STRING';
		case 'ExpectJson':
			return 'JSON';
		default:
			return 'BYTES';
	}
};
var $gren_lang$node$HttpServer$methodToString = function(method) {
	switch (method.$) {
		case 'GET':
			return 'GET';
		case 'HEAD':
			return 'HEAD';
		case 'POST':
			return 'POST';
		case 'PUT':
			return 'PUT';
		case 'DELETE':
			return 'DELETE';
		case 'CONNECT':
			return 'CONNECT';
		case 'TRACE':
			return 'TRACE';
		case 'PATCH':
			return 'PATCH';
		default:
			var value = method.a;
			return value;
	}
};
var $gren_lang$node$HttpClient$kernelRequestConfig$ = function(permission, config) {
	var actualUrl = function () {
		if (permission.$ === 'AnyPermission') {
			return config.url;
		} else {
			var prefix = permission.a;
			return _Utils_ap(prefix, config.url);
		}
	}();
	return { body: config.body, bodyType: $gren_lang$node$HttpClient$bodyTypeAsString(config.body), expect: config.expect, expectType: $gren_lang$node$HttpClient$expectTypeAsString(config.expect), headers: config.headers, method: $gren_lang$node$HttpServer$methodToString(config.method), timeout: config.timeout, url: actualUrl };
};
var $gren_lang$node$HttpClient$kernelRequestConfig = F2($gren_lang$node$HttpClient$kernelRequestConfig$);
var $gren_lang$node$HttpClient$send$ = function(permission, config) {
	return _HttpClient_request($gren_lang$node$HttpClient$kernelRequestConfig$(permission, config));
};
var $gren_lang$node$HttpClient$send = F2($gren_lang$node$HttpClient$send$);
var $gren_lang$compiler_node$Compiler$Backend$download$ = function(permission, url) {
	return $gren_lang$node$HttpClient$send$(permission, $gren_lang$node$HttpClient$expectBytes($gren_lang$node$HttpClient$get(url)));
};
var $gren_lang$compiler_node$Compiler$Backend$download = F2($gren_lang$compiler_node$Compiler$Backend$download$);
var $gren_lang$node$FileSystem$Path$empty = { directory: [  ], extension: '', filename: '', root: '' };
var $gren_lang$node$FileSystem$errorToString = function(_v0) {
	var message = _v0.a.message;
	return message;
};
var $gren_lang$node$HttpClient$errorToString = function(err) {
	switch (err.$) {
		case 'Timeout':
			return 'Timeout';
		case 'BadUrl':
			var url = err.a;
			return 'Bad URL: ' + url;
		case 'BadHeaders':
			return 'Bad headers: one or more of your headers contains invalid characters.';
		case 'BadStatus':
			var res = err.a;
			return 'Bad status: ' + ($gren_lang$core$String$fromInt(res.statusCode) + (' - ' + res.statusText));
		case 'UnexpectedResponseBody':
			var message = err.a;
			return 'Unexpected response body: ' + message;
		default:
			var debugStr = err.a;
			return 'Unknown error: ' + debugStr;
	}
};
var $gren_lang$core$Stream$errorToString = function(error) {
	switch (error.$) {
		case 'Closed':
			return 'Closed';
		case 'Cancelled':
			var reason = error.a;
			return 'Cancelled: ' + reason;
		default:
			return 'Locked';
	}
};
var $gren_lang$core$Task$executeCmd = function(task) {
	return $gren_lang$core$Task$command($gren_lang$core$Task$ExecuteCmd(task));
};
var $gren_lang$node$Node$exitWithCode = function(code) {
	return _Node_exitWithCode(code);
};
var $gren_lang$node$FileSystem$makeDirectory$ = function(_v0, options, path) {
	return A2(_FileSystem_makeDirectory, options, path);
};
var $gren_lang$node$FileSystem$makeDirectory = F3($gren_lang$node$FileSystem$makeDirectory$);
var $gren_lang$core$Task$fail = _Scheduler_fail;
var $gren_lang$core$Task$mapError$ = function(convert, task) {
	return A2($gren_lang$core$Task$onError, $gren_lang$core$Basics$composeL$($gren_lang$core$Task$fail, convert), task);
};
var $gren_lang$core$Task$mapError = F2($gren_lang$core$Task$mapError$);
var $gren_lang$core$Basics$sub = _Basics_sub;
var $gren_lang$core$Array$dropLast$ = function(n, array) {
	return A3($gren_lang$core$Array$slice, 0, $gren_lang$core$Array$length(array) - n, array);
};
var $gren_lang$core$Array$dropLast = F2($gren_lang$core$Array$dropLast$);
var $gren_lang$core$Array$get = _Array_get;
var $gren_lang$core$Basics$negate = function(n) {
	return -n;
};
var $gren_lang$core$Array$last = function(array) {
	return A2($gren_lang$core$Array$get, -1, array);
};
var $gren_lang$core$Array$popLast = function(array) {
	var _v0 = $gren_lang$core$Array$last(array);
	if (_v0.$ === 'Just') {
		var value = _v0.a;
		return $gren_lang$core$Maybe$Just({ initial: $gren_lang$core$Array$dropLast$(1, array), last: value });
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$node$FileSystem$Path$parentPath = function(path) {
	var _v0 = $gren_lang$core$Array$popLast(path.directory);
	if (_v0.$ === 'Nothing') {
		return ($gren_lang$node$FileSystem$Path$filenameWithExtension(path) === '') ? $gren_lang$core$Maybe$Nothing : $gren_lang$core$Maybe$Just(_Utils_update(path, { extension: '', filename: '' }));
	} else {
		var _v1 = _v0.a;
		var last = _v1.last;
		var initial = _v1.initial;
		var _v2 = function () {
			var _v3 = A2($gren_lang$core$String$split, '.', last);
			if (_v3.length === 2) {
				var file = _v3[0];
				var ext = _v3[1];
				return { extension: ext, filename: file };
			} else {
				return { extension: '', filename: last };
			}
		}();
		var filename = _v2.filename;
		var extension = _v2.extension;
		return $gren_lang$core$Maybe$Just(_Utils_update(path, { directory: initial, extension: extension, filename: filename }));
	}
};
var $author$project$Main$CompiledForRun = function (a) {
	return { $: 'CompiledForRun', a: a };
};
var $author$project$Main$CompilerInitialized = function (a) {
	return { $: 'CompilerInitialized', a: a };
};
var $author$project$Main$CompilerRan = function (a) {
	return { $: 'CompilerRan', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$Docs = function (a) {
	return { $: 'Docs', a: a };
};
var $gren_lang$node$ChildProcess$External = function (a) {
	return { $: 'External', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$Make = function (a) {
	return { $: 'Make', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$PackageBump = function (a) {
	return { $: 'PackageBump', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$PackageDiff = function (a) {
	return { $: 'PackageDiff', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$PackageValidate = function (a) {
	return { $: 'PackageValidate', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$Repl = function (a) {
	return { $: 'Repl', a: a };
};
var $gren_lang$compiler_node$Compiler$Outline$App = function (a) {
	return { $: 'App', a: a };
};
var $author$project$Terminal$PackageInstall$PackageInstallDebug = function (a) {
	return { $: 'PackageInstallDebug', a: a };
};
var $gren_lang$compiler_node$Compiler$Outline$Version = function (a) {
	return { $: 'Version', a: a };
};
var $gren_lang$core$Stream$cancelReadable = _Stream_cancelReadable;
var $gren_lang$core$Stream$read = _Stream_read;
var $gren_lang$core$Bytes$toString = _Bytes_toString;
var $gren_lang$core$Stream$readBytesAsString = function(stream) {
	return A2($gren_lang$core$Task$andThen, function(bytes) {
			var _v0 = $gren_lang$core$Bytes$toString(bytes);
			if (_v0.$ === 'Just') {
				var str = _v0.a;
				return $gren_lang$core$Task$succeed(str);
			} else {
				var reason = 'Failed to convert bytes to string';
				return A2($gren_lang$core$Task$andThen, function(_v1) {
						return $gren_lang$core$Task$fail($gren_lang$core$Stream$Cancelled(reason));
					}, A2($gren_lang$core$Stream$cancelReadable, reason, stream));
			}
		}, $gren_lang$core$Stream$read(stream));
};
var $gren_lang$core$String$trim = _String_trim;
var $author$project$Terminal$User$confirm = function(_v0) {
	var stdout = _v0.stdout;
	var stdin = _v0.stdin;
	var question = _v0.question;
	var defaultValue = _v0.defaultValue;
	var legend = defaultValue ? ' [Y|n]: ' : ' [y|N]: ';
	return $gren_lang$core$Task$map$(function(answer) {
			var _v2 = $gren_lang$core$String$trim($gren_lang$core$String$toLower(answer));
			switch (_v2) {
				case 'y':
					return true;
				case '':
					return defaultValue;
				default:
					return false;
			}
		}, A2($gren_lang$core$Task$andThen, function(_v1) {
				return $gren_lang$core$Stream$readBytesAsString(stdin);
			}, $gren_lang$core$Stream$Log$string$(stdout, _Utils_ap(question, legend))));
};
var $gren_lang$node$ChildProcess$InheritEnvironmentVariables = { $: 'InheritEnvironmentVariables' };
var $gren_lang$node$ChildProcess$InheritWorkingDirectory = { $: 'InheritWorkingDirectory' };
var $gren_lang$node$ChildProcess$Milliseconds = function (a) {
	return { $: 'Milliseconds', a: a };
};
var $gren_lang$node$ChildProcess$NoShell = { $: 'NoShell' };
var $gren_lang$compiler_node$SemanticVersion$compare$ = function(left, right) {
	var _v0 = A2($gren_lang$core$Basics$compare, left.major, right.major);
	if (_v0.$ === 'EQ') {
		var _v1 = A2($gren_lang$core$Basics$compare, left.minor, right.minor);
		if (_v1.$ === 'EQ') {
			return A2($gren_lang$core$Basics$compare, left.patch, right.patch);
		} else {
			var otherMinor = _v1;
			return otherMinor;
		}
	} else {
		var otherMajor = _v0;
		return otherMajor;
	}
};
var $gren_lang$compiler_node$SemanticVersion$compare = F2($gren_lang$compiler_node$SemanticVersion$compare$);
var $gren_lang$core$Basics$composeR$ = function(f, g) {
	return function(x) {
		return g(f(x));
	};
};
var $gren_lang$core$Basics$composeR = F2($gren_lang$core$Basics$composeR$);
var $gren_lang$core$Basics$ge = _Utils_ge;
var $gren_lang$core$Array$mapAndFlatten = _Array_flatMap;
var $gren_lang$core$Array$mapAndKeepJust$ = function(mapper, array) {
	return A2($gren_lang$core$Array$mapAndFlatten, function(v) {
			var _v0 = mapper(v);
			if (_v0.$ === 'Just') {
				var newValue = _v0.a;
				return [ newValue ];
			} else {
				return [  ];
			}
		}, array);
};
var $gren_lang$core$Array$mapAndKeepJust = F2($gren_lang$core$Array$mapAndKeepJust$);
var $gren_lang$core$String$toInt = _String_toInt;
var $gren_lang$compiler_node$SemanticVersion$fromString = function(str) {
	var parts = A2($gren_lang$core$Array$keepIf, function(num) {
			return num >= 0;
		}, $gren_lang$core$Array$mapAndKeepJust$($gren_lang$core$String$toInt, A2($gren_lang$core$String$split, '.', str)));
	if (parts.length === 3) {
		var major = parts[0];
		var minor = parts[1];
		var patch = parts[2];
		return $gren_lang$core$Maybe$Just({ major: major, minor: minor, patch: patch });
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};


var bufferNs = require("node:buffer");
var process = require("node:process");
var stream = require("node:stream");

var _ChildProcess_module = function () {
  return require("node:child_process");
};

var _ChildProcess_run = function (options) {
  return _Scheduler_binding(function (callback) {
    var childProcess = _ChildProcess_module();

    var workingDir = options.workingDirectory;
    var env = options.environmentVariables;
    var shell = options.shell;

    childProcess.execFile(
      options.program,
      options._arguments,
      {
        encoding: "buffer",
        timeout: options.runDuration,
        cwd: _ChildProcess_handleCwd(workingDir),
        env: _ChildProcess_handleEnv(env),
        timeout: options.runDuration,
        maxBuffer: options.maximumBytesWrittenToStreams,
        shell: _ChildProcess_handleShell(shell),
      },
      function (err, stdout, stderr) {
        if (err == null) {
          callback(
            _Scheduler_succeed({
              stdout: new DataView(
                stdout.buffer,
                stdout.byteOffset,
                stdout.byteLength,
              ),
              stderr: new DataView(
                stderr.buffer,
                stderr.byteOffset,
                stderr.byteLength,
              ),
            }),
          );
        } else {
          callback(
            _Scheduler_fail({
              exitCode:
                typeof err.errno === "undefined" ? err.code : err.errno,
              stdout: new DataView(
                stdout.buffer,
                stdout.byteOffset,
                stdout.byteLength,
              ),
              stderr: new DataView(
                stderr.buffer,
                stderr.byteOffset,
                stderr.byteLength,
              ),
            }),
          );
        }
      },
    );
  });
};

var _ChildProcess_spawn = F3(function (sendInitToApp, sendExitToApp, options) {
  return _Scheduler_binding(function (callback) {
    var subproc = _ChildProcess_getSubProc(options);

    var proc = _Scheduler_rawSpawn(
      sendInitToApp({
        processId: _Scheduler_rawSpawn(
          _Scheduler_binding(function (callback) {
            return function () {
              subproc.kill();
            };
          }),
        ),
        streams:
          options.connection.kind !== 1
            ? {}
            : {
                input: stream.Writable.toWeb(subproc.stdin),
                output: stream.Readable.toWeb(subproc.stdout),
                error: stream.Readable.toWeb(subproc.stderr),
              },
      }),
    );

    subproc.on("exit", function (code) {
      _Scheduler_rawSpawn(sendExitToApp(code));
    });

    callback(_Scheduler_succeed(proc));
  });
});

function _ChildProcess_getSubProc(options) {
  var childProcess = _ChildProcess_module();

  var workingDir = options.workingDirectory;
  var env = options.environmentVariables;
  var shell = options.shell;

  var subproc = childProcess.spawn(options.program, options._arguments, {
    cwd: _ChildProcess_handleCwd(workingDir),
    env: _ChildProcess_handleEnv(env),
    timeout: options.runDuration,
    shell: _ChildProcess_handleShell(shell),
    stdio:
      options.connection.kind === 0
        ? "inherit"
        : options.connection.kind === 1
          ? "pipe"
          : "ignore",
    detached:
      options.connection.kind === 3 && process.platform === "win32",
  });

  if (options.connection.kind === 3) {
    subproc.unref();
  }

  return subproc;
}

function _ChildProcess_handleCwd(cwd) {
  return cwd.inherit ? process.cwd() : cwd.override;
}

function _ChildProcess_handleEnv(env) {
  return env.option === 0
    ? process.env
    : env.option === 1
      ? _Utils_update(process.env, _ChildProcess_dictToObj(env.value))
      : _ChildProcess_dictToObj(env.value);
}

function _ChildProcess_handleShell(shell) {
  return shell.choice === 0
    ? false
    : shell.choice === 1
      ? true
      : shell.value;
}

function _ChildProcess_dictToObj(dict) {
  return A3(
    $gren_lang$core$Dict$foldl,
    F3(function (key, value, acc) {
      acc[key] = value;
      return acc;
    }),
    {},
    dict,
  );
}
var $gren_lang$core$Basics$gt = _Utils_gt;
var $gren_lang$core$Basics$max$ = function(x, y) {
	return (_Utils_cmp(x, y) > 0) ? x : y;
};
var $gren_lang$core$Basics$max = F2($gren_lang$core$Basics$max$);
var $gren_lang$node$ChildProcess$run$ = function(_v0, program, _arguments, opts) {
	return _ChildProcess_run({ _arguments: _arguments, environmentVariables: function () {
			var _v1 = opts.environmentVariables;
			switch (_v1.$) {
				case 'InheritEnvironmentVariables':
					return { option: 0, value: $gren_lang$core$Dict$empty };
				case 'MergeWithEnvironmentVariables':
					var value = _v1.a;
					return { option: 1, value: value };
				default:
					var value = _v1.a;
					return { option: 2, value: value };
			}
		}(), maximumBytesWrittenToStreams: opts.maximumBytesWrittenToStreams, program: program, runDuration: function () {
			var _v2 = opts.runDuration;
			if (_v2.$ === 'NoLimit') {
				return 0;
			} else {
				var ms = _v2.a;
				return $gren_lang$core$Basics$max$(0, ms);
			}
		}(), shell: function () {
			var _v3 = opts.shell;
			switch (_v3.$) {
				case 'NoShell':
					return { choice: 0, value: '' };
				case 'DefaultShell':
					return { choice: 1, value: '' };
				default:
					var value = _v3.a;
					return { choice: 2, value: value };
			}
		}(), workingDirectory: function () {
			var _v4 = opts.workingDirectory;
			if (_v4.$ === 'InheritWorkingDirectory') {
				return { inherit: true, override: '' };
			} else {
				var value = _v4.a;
				return { inherit: false, override: value };
			}
		}() });
};
var $gren_lang$node$ChildProcess$run = F4($gren_lang$node$ChildProcess$run$);
var $gren_lang$core$Array$sortWith = _Array_sortWith;
var $gren_lang$compiler_node$Compiler$PackageName$author = function(_v0) {
	var fields = _v0.a;
	return fields.author;
};
var $gren_lang$compiler_node$Compiler$PackageName$name = function(_v0) {
	var fields = _v0.a;
	return fields.name;
};
var $gren_lang$compiler_node$Compiler$PackageName$toString = function(_package) {
	return $gren_lang$compiler_node$Compiler$PackageName$author(_package) + ('/' + $gren_lang$compiler_node$Compiler$PackageName$name(_package));
};
var $author$project$Git$fetchVersions$ = function(cpPerm, name) {
	var githubUrl = 'https://github.com/' + ($gren_lang$compiler_node$Compiler$PackageName$toString(name) + '.git');
	return A2($gren_lang$core$Task$andThen, function(result) {
			var _v0 = $gren_lang$core$Bytes$toString(result.stdout);
			if (_v0.$ === 'Nothing') {
				return $gren_lang$core$Task$succeed([  ]);
			} else {
				var tagList = _v0.a;
				return $gren_lang$core$Task$succeed(A2($gren_lang$core$Array$sortWith, $gren_lang$compiler_node$SemanticVersion$compare, $gren_lang$core$Array$mapAndKeepJust$($gren_lang$compiler_node$SemanticVersion$fromString, A2($gren_lang$core$Array$map, $gren_lang$core$Basics$composeR$($gren_lang$core$String$split('/'), $gren_lang$core$Basics$composeR$($gren_lang$core$Array$last, $gren_lang$core$Maybe$withDefault(''))), A2($gren_lang$core$String$split, '\n', tagList)))));
			}
		}, $gren_lang$node$ChildProcess$run$(cpPerm, 'git', [ 'ls-remote', '--tags', githubUrl ], { environmentVariables: $gren_lang$node$ChildProcess$InheritEnvironmentVariables, maximumBytesWrittenToStreams: 4096, runDuration: $gren_lang$node$ChildProcess$Milliseconds(30000), shell: $gren_lang$node$ChildProcess$NoShell, workingDirectory: $gren_lang$node$ChildProcess$InheritWorkingDirectory }));
};
var $author$project$Git$fetchVersions = F2($author$project$Git$fetchVersions$);
var $author$project$Git$fetchLatestVersion$ = function(cpPerm, name) {
	return $gren_lang$core$Task$map$($gren_lang$core$Array$last, $author$project$Git$fetchVersions$(cpPerm, name));
};
var $author$project$Git$fetchLatestVersion = F2($author$project$Git$fetchLatestVersion$);
var $gren_lang$core$Dict$keepIf$ = function(isGood, dict) {
	return $gren_lang$core$Dict$foldl$(F3(function(k, v, d) {
				return A2(isGood, k, v) ? $gren_lang$core$Dict$set$(k, v, d) : d;
			}), $gren_lang$core$Dict$empty, dict);
};
var $gren_lang$core$Dict$keepIf = F2($gren_lang$core$Dict$keepIf$);
var $gren_lang$core$Dict$map$ = function(func, dict) {
	if (dict.$ === 'RBEmpty_gren_builtin') {
		return $gren_lang$core$Dict$RBEmpty_gren_builtin;
	} else {
		var _v1 = dict.a;
		var color = _v1.color;
		var key = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var right = _v1.right;
		return $gren_lang$core$Dict$node$(color, key, A2(func, key, value), $gren_lang$core$Dict$map$(func, left), $gren_lang$core$Dict$map$(func, right));
	}
};
var $gren_lang$core$Dict$map = F2($gren_lang$core$Dict$map$);
var $gren_lang$core$Dict$getMin = function(dict) {
	getMin:
	while (true) {
		if ((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) {
			var left = dict.a.left;
			var $temp$dict = left;
			dict = $temp$dict;
			continue getMin;
		} else {
			return dict;
		}
	}
};
var $gren_lang$core$Basics$lt = _Utils_lt;
var $gren_lang$core$Dict$moveRedLeft = function(dict) {
	if (((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) && (dict.a.right.$ === 'RBNode_gren_builtin')) {
		if ((dict.a.right.a.left.$ === 'RBNode_gren_builtin') && (dict.a.right.a.left.a.color.$ === 'Red')) {
			var _v1 = dict.a;
			var clr = _v1.color;
			var k = _v1.key;
			var v = _v1.value;
			var _v2 = _v1.left.a;
			var lClr = _v2.color;
			var lK = _v2.key;
			var lV = _v2.value;
			var lLeft = _v2.left;
			var lRight = _v2.right;
			var _v3 = _v1.right.a;
			var rClr = _v3.color;
			var rK = _v3.key;
			var rV = _v3.value;
			var rLeft = _v3.left;
			var _v4 = rLeft.a;
			var _v5 = _v4.color;
			var rlK = _v4.key;
			var rlV = _v4.value;
			var rlL = _v4.left;
			var rlR = _v4.right;
			var rRight = _v3.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rlK, rlV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, lLeft, lRight), rlL), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, rK, rV, rlR, rRight));
		} else {
			var _v6 = dict.a;
			var clr = _v6.color;
			var k = _v6.key;
			var v = _v6.value;
			var _v7 = _v6.left.a;
			var lClr = _v7.color;
			var lK = _v7.key;
			var lV = _v7.value;
			var lLeft = _v7.left;
			var lRight = _v7.right;
			var _v8 = _v6.right.a;
			var rClr = _v8.color;
			var rK = _v8.key;
			var rV = _v8.value;
			var rLeft = _v8.left;
			var rRight = _v8.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, lLeft, lRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rK, rV, rLeft, rRight));
		}
	} else {
		return dict;
	}
};
var $gren_lang$core$Dict$moveRedRight = function(dict) {
	if (((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) && (dict.a.right.$ === 'RBNode_gren_builtin')) {
		if ((dict.a.left.a.left.$ === 'RBNode_gren_builtin') && (dict.a.left.a.left.a.color.$ === 'Red')) {
			var _v1 = dict.a;
			var clr = _v1.color;
			var k = _v1.key;
			var v = _v1.value;
			var _v2 = _v1.left.a;
			var lClr = _v2.color;
			var lK = _v2.key;
			var lV = _v2.value;
			var _v3 = _v2.left.a;
			var _v4 = _v3.color;
			var llK = _v3.key;
			var llV = _v3.value;
			var llLeft = _v3.left;
			var llRight = _v3.right;
			var lRight = _v2.right;
			var _v5 = _v1.right.a;
			var rClr = _v5.color;
			var rK = _v5.key;
			var rV = _v5.value;
			var rLeft = _v5.left;
			var rRight = _v5.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, llK, llV, llLeft, llRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, lRight, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rK, rV, rLeft, rRight)));
		} else {
			var _v6 = dict.a;
			var clr = _v6.color;
			var k = _v6.key;
			var v = _v6.value;
			var _v7 = _v6.left.a;
			var lClr = _v7.color;
			var lK = _v7.key;
			var lV = _v7.value;
			var lLeft = _v7.left;
			var lRight = _v7.right;
			var _v8 = _v6.right.a;
			var rClr = _v8.color;
			var rK = _v8.key;
			var rV = _v8.value;
			var rLeft = _v8.left;
			var rRight = _v8.right;
			return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, k, v, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, lK, lV, lLeft, lRight), $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, rK, rV, rLeft, rRight));
		}
	} else {
		return dict;
	}
};
var $gren_lang$core$Dict$removeHelpPrepEQGT$ = function(targetKey, dict, color, key, value, left, right) {
	if ((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Red')) {
		var _v1 = left.a;
		var _v2 = _v1.color;
		var lK = _v1.key;
		var lV = _v1.value;
		var lLeft = _v1.left;
		var lRight = _v1.right;
		return $gren_lang$core$Dict$node$(color, lK, lV, lLeft, $gren_lang$core$Dict$node$($gren_lang$core$Dict$Red, key, value, lRight, right));
	} else {
		_v3$2:
		while (true) {
			if ((right.$ === 'RBNode_gren_builtin') && (right.a.color.$ === 'Black')) {
				if (right.a.left.$ === 'RBNode_gren_builtin') {
					if (right.a.left.a.color.$ === 'Black') {
						var _v4 = right.a;
						var _v5 = _v4.color;
						var _v6 = _v4.left.a.color;
						return $gren_lang$core$Dict$moveRedRight(dict);
					} else {
						break _v3$2;
					}
				} else {
					var _v7 = right.a;
					var _v8 = _v7.color;
					var _v9 = _v7.left;
					return $gren_lang$core$Dict$moveRedRight(dict);
				}
			} else {
				break _v3$2;
			}
		}
		return dict;
	}
};
var $gren_lang$core$Dict$removeHelpPrepEQGT = F7($gren_lang$core$Dict$removeHelpPrepEQGT$);
var $gren_lang$core$Dict$removeMin = function(dict) {
	if ((dict.$ === 'RBNode_gren_builtin') && (dict.a.left.$ === 'RBNode_gren_builtin')) {
		var _v1 = dict.a;
		var color = _v1.color;
		var key = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var _v2 = left.a;
		var lColor = _v2.color;
		var lLeft = _v2.left;
		var right = _v1.right;
		if (lColor.$ === 'Black') {
			if ((lLeft.$ === 'RBNode_gren_builtin') && (lLeft.a.color.$ === 'Red')) {
				var _v5 = lLeft.a.color;
				return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeMin(left), right);
			} else {
				var _v6 = $gren_lang$core$Dict$moveRedLeft(dict);
				if (_v6.$ === 'RBNode_gren_builtin') {
					var _v7 = _v6.a;
					var nColor = _v7.color;
					var nKey = _v7.key;
					var nValue = _v7.value;
					var nLeft = _v7.left;
					var nRight = _v7.right;
					return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, $gren_lang$core$Dict$removeMin(nLeft), nRight);
				} else {
					return $gren_lang$core$Dict$RBEmpty_gren_builtin;
				}
			}
		} else {
			return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeMin(left), right);
		}
	} else {
		return $gren_lang$core$Dict$RBEmpty_gren_builtin;
	}
};
var $gren_lang$core$Dict$removeHelp$ = function(targetKey, dict) {
	if (dict.$ === 'RBEmpty_gren_builtin') {
		return $gren_lang$core$Dict$RBEmpty_gren_builtin;
	} else {
		var _v5 = dict.a;
		var color = _v5.color;
		var key = _v5.key;
		var value = _v5.value;
		var left = _v5.left;
		var right = _v5.right;
		if (_Utils_cmp(targetKey, key) < 0) {
			if ((left.$ === 'RBNode_gren_builtin') && (left.a.color.$ === 'Black')) {
				var _v7 = left.a;
				var _v8 = _v7.color;
				var lLeft = _v7.left;
				if ((lLeft.$ === 'RBNode_gren_builtin') && (lLeft.a.color.$ === 'Red')) {
					var _v10 = lLeft.a.color;
					return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeHelp$(targetKey, left), right);
				} else {
					var _v11 = $gren_lang$core$Dict$moveRedLeft(dict);
					if (_v11.$ === 'RBNode_gren_builtin') {
						var _v12 = _v11.a;
						var nColor = _v12.color;
						var nKey = _v12.key;
						var nValue = _v12.value;
						var nLeft = _v12.left;
						var nRight = _v12.right;
						return $gren_lang$core$Dict$balance$(nColor, nKey, nValue, $gren_lang$core$Dict$removeHelp$(targetKey, nLeft), nRight);
					} else {
						return $gren_lang$core$Dict$RBEmpty_gren_builtin;
					}
				}
			} else {
				return $gren_lang$core$Dict$node$(color, key, value, $gren_lang$core$Dict$removeHelp$(targetKey, left), right);
			}
		} else {
			return $gren_lang$core$Dict$removeHelpEQGT$(targetKey, $gren_lang$core$Dict$removeHelpPrepEQGT$(targetKey, dict, color, key, value, left, right));
		}
	}
};
var $gren_lang$core$Dict$removeHelp = F2($gren_lang$core$Dict$removeHelp$);
var $gren_lang$core$Dict$removeHelpEQGT$ = function(targetKey, dict) {
	if (dict.$ === 'RBNode_gren_builtin') {
		var _v1 = dict.a;
		var color = _v1.color;
		var key = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var right = _v1.right;
		if (_Utils_eq(targetKey, key)) {
			var _v2 = $gren_lang$core$Dict$getMin(right);
			if (_v2.$ === 'RBNode_gren_builtin') {
				var _v3 = _v2.a;
				var minKey = _v3.key;
				var minValue = _v3.value;
				return $gren_lang$core$Dict$balance$(color, minKey, minValue, left, $gren_lang$core$Dict$removeMin(right));
			} else {
				return $gren_lang$core$Dict$RBEmpty_gren_builtin;
			}
		} else {
			return $gren_lang$core$Dict$balance$(color, key, value, left, $gren_lang$core$Dict$removeHelp$(targetKey, right));
		}
	} else {
		return $gren_lang$core$Dict$RBEmpty_gren_builtin;
	}
};
var $gren_lang$core$Dict$removeHelpEQGT = F2($gren_lang$core$Dict$removeHelpEQGT$);
var $gren_lang$core$Dict$remove$ = function(key, dict) {
	var _v0 = $gren_lang$core$Dict$removeHelp$(key, dict);
	if ((_v0.$ === 'RBNode_gren_builtin') && (_v0.a.color.$ === 'Red')) {
		var _v1 = _v0.a;
		var _v2 = _v1.color;
		var nKey = _v1.key;
		var value = _v1.value;
		var left = _v1.left;
		var right = _v1.right;
		return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, nKey, value, left, right);
	} else {
		var x = _v0;
		return x;
	}
};
var $gren_lang$core$Dict$remove = F2($gren_lang$core$Dict$remove$);
var $gren_lang$compiler_node$Compiler$Outline$LocalPath = function (a) {
	return { $: 'LocalPath', a: a };
};
var $gren_lang$core$Task$concurrent = _Scheduler_concurrent;
var $gren_lang$node$FileSystem$errorIsNoSuchFileOrDirectory = function(_v0) {
	var code = _v0.a.code;
	return code === 'ENOENT';
};
var $gren_lang$compiler_node$Compiler$PackageName$PackageName = function (a) {
	return { $: 'PackageName', a: a };
};
var $gren_lang$compiler_node$Compiler$PackageName$example = $gren_lang$compiler_node$Compiler$PackageName$PackageName({ author: 'example', name: 'package' });
var $gren_lang$core$Array$flatten = _Array_flat;
var $gren_lang$node$FileSystem$listDirectory$ = function(_v0, path) {
	return _FileSystem_listDirectory(path);
};
var $gren_lang$node$FileSystem$listDirectory = F2($gren_lang$node$FileSystem$listDirectory$);
var $gren_lang$compiler_node$Compiler$Outline$findSourceFilesHelp$ = function(fsPerm, local, root) {
	return A2($gren_lang$core$Task$andThen, function(paths) {
			return $gren_lang$core$Task$map$($gren_lang$core$Array$flatten, $gren_lang$core$Task$sequence($gren_lang$core$Array$mapAndKeepJust$(function(entry) {
							var _v0 = entry.entityType;
							switch (_v0.$) {
								case 'Directory':
									return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Outline$findSourceFilesHelp$(fsPerm, $gren_lang$node$FileSystem$Path$append$(entry.path, local), $gren_lang$node$FileSystem$Path$append$(entry.path, root)));
								case 'File':
									return ((entry.path.extension === 'js') || (entry.path.extension === 'gren')) ? $gren_lang$core$Maybe$Just($gren_lang$core$Task$succeed([ { absolute: $gren_lang$node$FileSystem$Path$append$(entry.path, root), relative: $gren_lang$node$FileSystem$Path$append$(entry.path, local) } ])) : $gren_lang$core$Maybe$Nothing;
								default:
									return $gren_lang$core$Maybe$Nothing;
							}
						}, paths)));
		}, $gren_lang$node$FileSystem$listDirectory$(fsPerm, root));
};
var $gren_lang$compiler_node$Compiler$Outline$findSourceFilesHelp = F3($gren_lang$compiler_node$Compiler$Outline$findSourceFilesHelp$);
var $gren_lang$node$FileSystem$readFile$ = function(_v0, path) {
	return _FileSystem_readFile(path);
};
var $gren_lang$node$FileSystem$readFile = F2($gren_lang$node$FileSystem$readFile$);
var $gren_lang$core$String$replace$ = function(before, after, string) {
	return A2($gren_lang$core$String$join, after, A2($gren_lang$core$String$split, before, string));
};
var $gren_lang$core$String$replace = F3($gren_lang$core$String$replace$);
var $gren_lang$compiler_node$Compiler$Outline$readSourceFile$ = function(fsPerm, _v0) {
	var absolute = _v0.absolute;
	var relative = _v0.relative;
	return $gren_lang$core$Task$map$(function(source) {
			return { moduleName: $gren_lang$core$String$replace$('/', '.', $gren_lang$node$FileSystem$Path$toPosixString(_Utils_update(relative, { extension: '' }))), source: $gren_lang$core$Maybe$withDefault$('', $gren_lang$core$Bytes$toString(source)) };
		}, $gren_lang$node$FileSystem$readFile$(fsPerm, absolute));
};
var $gren_lang$compiler_node$Compiler$Outline$readSourceFile = F2($gren_lang$compiler_node$Compiler$Outline$readSourceFile$);
var $gren_lang$compiler_node$Compiler$Outline$findSourceFiles$ = function(fsPerm, outline, outlinePath) {
	var sourceDirs = function () {
		if (outline.$ === 'App') {
			var appOutline = outline.a;
			return appOutline.sourceDirectories;
		} else {
			return [ $gren_lang$node$FileSystem$Path$fromPosixString('src') ];
		}
	}();
	return A2($gren_lang$core$Task$andThen, function(paths) {
			return $gren_lang$core$Task$sequence(A2($gren_lang$core$Array$map, $gren_lang$compiler_node$Compiler$Outline$readSourceFile(fsPerm), paths));
		}, $gren_lang$core$Task$map$($gren_lang$core$Array$flatten, $gren_lang$core$Task$sequence(A2($gren_lang$core$Array$map, A2($gren_lang$compiler_node$Compiler$Outline$findSourceFilesHelp, fsPerm, $gren_lang$node$FileSystem$Path$empty), A2($gren_lang$core$Array$map, function(srcDir) {
							return $gren_lang$node$FileSystem$Path$append$(srcDir, outlinePath);
						}, sourceDirs)))));
};
var $gren_lang$compiler_node$Compiler$Outline$findSourceFiles = F3($gren_lang$compiler_node$Compiler$Outline$findSourceFiles$);
var $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange = function (a) {
	return { $: 'SemanticVersionRange', a: a };
};
var $gren_lang$compiler_node$SemanticVersionRange$fromExact = function(lower) {
	var major = lower.major;
	var minor = lower.minor;
	var patch = lower.patch;
	return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lower, upper: { major: major, minor: minor, patch: patch + 1 } });
};
var $gren_lang$core$String$contains = _String_contains;
var $gren_lang$core$String$endsWith = _String_endsWith;
var $gren_lang$core$String$startsWith = _String_startsWith;
var $gren_lang$compiler_node$Compiler$PackageName$fromString = function(str) {
	var _v0 = A2($gren_lang$core$String$split, '/', str);
	if (_v0.length === 2) {
		var authorStr = _v0[0];
		var nameStr = _v0[1];
		var validName = (!$gren_lang$core$String$isEmpty(nameStr)) && ((!A2($gren_lang$core$String$startsWith, '-', nameStr)) && ((!A2($gren_lang$core$String$endsWith, '-', nameStr)) && ((!A2($gren_lang$core$String$contains, '--', nameStr)) && $gren_lang$core$String$all$(function(c) {
				return $gren_lang$core$Char$isDigit(c) || ($gren_lang$core$Char$isLower(c) || _Utils_eq(c, _Utils_chr('-')));
			}, nameStr))));
		var validAuthor = (!$gren_lang$core$String$isEmpty(authorStr)) && ((!A2($gren_lang$core$String$startsWith, '-', authorStr)) && ((!A2($gren_lang$core$String$endsWith, '-', authorStr)) && ((!A2($gren_lang$core$String$contains, '--', authorStr)) && $gren_lang$core$String$all$(function(c) {
				return _Utils_eq(c, _Utils_chr('-')) || $gren_lang$core$Char$isAlphaNum(c);
			}, authorStr))));
		if (validAuthor && validName) {
			var _v1 = $gren_lang$core$String$popFirst(nameStr);
			if (_v1.$ === 'Just') {
				var firstChar = _v1.a.first;
				return $gren_lang$core$Char$isAlpha(firstChar) ? $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$PackageName$PackageName({ author: authorStr, name: nameStr })) : $gren_lang$core$Maybe$Nothing;
			} else {
				return $gren_lang$core$Maybe$Nothing;
			}
		} else {
			return $gren_lang$core$Maybe$Nothing;
		}
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$compiler_node$Compiler$Outline$Pkg = function (a) {
	return { $: 'Pkg', a: a };
};
var $gren_lang$node$FileSystem$Replace = { $: 'Replace' };
var $gren_lang$core$Stream$pipeThrough = _Stream_pipeThrough;
var $gren_lang$core$Stream$awaitAndPipeThrough$ = function(builder, source) {
	return A2($gren_lang$core$Task$andThen, function(transformation) {
			return A2($gren_lang$core$Stream$pipeThrough, transformation, source);
		}, builder);
};
var $gren_lang$core$Stream$awaitAndPipeThrough = F2($gren_lang$core$Stream$awaitAndPipeThrough$);
var $gren_lang$compiler_node$SemanticVersion$toString = function(_v0) {
	var major = _v0.major;
	var minor = _v0.minor;
	var patch = _v0.patch;
	return $gren_lang$core$String$fromInt(major) + ('.' + ($gren_lang$core$String$fromInt(minor) + ('.' + $gren_lang$core$String$fromInt(patch))));
};
var $author$project$Git$clonePackage$ = function(cpPerm, repo, name, version) {
	var githubUrl = 'https://github.com/' + ($gren_lang$compiler_node$Compiler$PackageName$toString(name) + '.git');
	return $gren_lang$node$ChildProcess$run$(cpPerm, 'git', [ 'clone', '--branch', $gren_lang$compiler_node$SemanticVersion$toString(version), '--depth', '1', githubUrl, $gren_lang$node$FileSystem$Path$toPosixString(repo) ], { environmentVariables: $gren_lang$node$ChildProcess$InheritEnvironmentVariables, maximumBytesWrittenToStreams: 4096, runDuration: $gren_lang$node$ChildProcess$Milliseconds(30000), shell: $gren_lang$node$ChildProcess$NoShell, workingDirectory: $gren_lang$node$ChildProcess$InheritWorkingDirectory });
};
var $author$project$Git$clonePackage = F4($author$project$Git$clonePackage$);
var $gren_lang$node$FileSystem$errorIsFileExists = function(_v0) {
	var code = _v0.a.code;
	return code === 'EEXIST';
};
var $gren_lang$core$Stream$enqueue = _Stream_enqueue;
var $gren_lang$core$Stream$identityTransformationWithOptions = function(_v0) {
	var readCapacity = _v0.readCapacity;
	var writeCapacity = _v0.writeCapacity;
	return A2(_Stream_identityTransformation, $gren_lang$core$Basics$max$(1, readCapacity), $gren_lang$core$Basics$max$(1, writeCapacity));
};
var $gren_lang$core$Stream$readable = _Stream_readable;
var $gren_lang$core$Stream$writable = _Stream_writable;
var $gren_lang$core$Stream$fromArray = function(array) {
	return A2($gren_lang$core$Task$andThen, function(idStream) {
			return $gren_lang$core$Task$map$(function(_v0) {
					return $gren_lang$core$Stream$readable(idStream);
				}, A2($gren_lang$core$Task$andThen, $gren_lang$core$Stream$closeWritable, A3($gren_lang$core$Array$foldl, F2(function(value, stream) {
								return A2($gren_lang$core$Task$andThen, $gren_lang$core$Stream$enqueue(value), stream);
							}), $gren_lang$core$Task$succeed($gren_lang$core$Stream$writable(idStream)), array)));
		}, $gren_lang$core$Stream$identityTransformationWithOptions({ readCapacity: $gren_lang$core$Array$length(array), writeCapacity: 1 }));
};
var $gren_lang$core$Stream$gzipCompression = _Stream_compressor('gzip');
var $gren_lang$core$Array$first = function(array) {
	return A2($gren_lang$core$Array$get, 0, array);
};
var $gren_lang$core$Array$popFirst = function(array) {
	var _v0 = $gren_lang$core$Array$first(array);
	if (_v0.$ === 'Just') {
		var value = _v0.a;
		return $gren_lang$core$Maybe$Just({ first: value, rest: $gren_lang$core$Array$dropFirst$(1, array) });
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$node$FileSystem$Path$join = function(paths) {
	var _v0 = $gren_lang$core$Array$popFirst(paths);
	if (_v0.$ === 'Just') {
		var _v1 = _v0.a;
		var first = _v1.first;
		var rest = _v1.rest;
		return A3($gren_lang$core$Array$foldl, $gren_lang$node$FileSystem$Path$append, first, rest);
	} else {
		return $gren_lang$node$FileSystem$Path$empty;
	}
};
var $author$project$Terminal$PackageInstall$localRepoPath$ = function(name, version, projectPath) {
	var normalizedName = $gren_lang$core$String$replace$('/', '_', $gren_lang$core$String$replace$('.', '_', $gren_lang$core$String$replace$('-', '_', $gren_lang$compiler_node$Compiler$PackageName$toString(name) + ('__' + $gren_lang$compiler_node$SemanticVersion$toString(version)))));
	return $gren_lang$node$FileSystem$Path$join([ projectPath, $gren_lang$node$FileSystem$Path$fromPosixString('.gren/git'), $gren_lang$node$FileSystem$Path$fromPosixString(normalizedName) ]);
};
var $author$project$Terminal$PackageInstall$localRepoPath = F3($author$project$Terminal$PackageInstall$localRepoPath$);
var $gren_lang$compiler_node$SemanticVersionRange$lowerBound = function(_v0) {
	var lower = _v0.a.lower;
	return lower;
};
var $gren_lang$core$Dict$mapAndKeepJust$ = function(toMaybe, dict) {
	return $gren_lang$core$Dict$foldl$(F3(function(k, v, d) {
				var _v0 = A2(toMaybe, k, v);
				if (_v0.$ === 'Just') {
					var newValue = _v0.a;
					return $gren_lang$core$Dict$set$(k, newValue, d);
				} else {
					return d;
				}
			}), $gren_lang$core$Dict$empty, dict);
};
var $gren_lang$core$Dict$mapAndKeepJust = F2($gren_lang$core$Dict$mapAndKeepJust$);
var $gren_lang$core$Json$Encode$dict$ = function(toKey, toValue, dictionary) {
	return _Json_wrap($gren_lang$core$Dict$foldl$(F3(function(key, value, obj) {
					return A3(_Json_addField, toKey(key), toValue(value), obj);
				}), _Json_emptyObject({  }), dictionary));
};
var $gren_lang$core$Json$Encode$dict = F3($gren_lang$core$Json$Encode$dict$);
var $gren_lang$core$Json$Encode$object = function(pairs) {
	return _Json_wrap(A3($gren_lang$core$Array$foldl, F2(function(_v0, obj) {
					var key = _v0.key;
					var value = _v0.value;
					return A3(_Json_addField, key, value, obj);
				}), _Json_emptyObject({  }), pairs));
};
var $gren_lang$core$Json$Encode$string = _Json_wrap;
var $gren_lang$compiler_node$Compiler$Outline$constraintEncoder$ = function(versionEncoder, constraint) {
	if (constraint.$ === 'Version') {
		var vsn = constraint.a;
		return versionEncoder(vsn);
	} else {
		var path = constraint.a;
		return $gren_lang$core$Json$Encode$string('local:' + $gren_lang$node$FileSystem$Path$toPosixString(path));
	}
};
var $gren_lang$compiler_node$Compiler$Outline$constraintEncoder = F2($gren_lang$compiler_node$Compiler$Outline$constraintEncoder$);
var $gren_lang$compiler_node$SemanticVersion$toJson = function(semver) {
	return $gren_lang$core$Json$Encode$string($gren_lang$compiler_node$SemanticVersion$toString(semver));
};
var $gren_lang$compiler_node$Compiler$Outline$appDependenciesEncoder = function(deps) {
	return $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Outline$constraintEncoder($gren_lang$compiler_node$SemanticVersion$toJson), deps);
};
var $gren_lang$core$Json$Encode$array$ = function(func, entries) {
	return _Json_wrap(A3($gren_lang$core$Array$foldl, _Json_addEntry(func), _Json_emptyArray({  }), entries));
};
var $gren_lang$core$Json$Encode$array = F2($gren_lang$core$Json$Encode$array$);
var $gren_lang$compiler_node$Compiler$ModuleName$toString = function(_v0) {
	var name = _v0.a;
	return name;
};
var $gren_lang$compiler_node$Compiler$ModuleName$toJson = function(moduleName) {
	return $gren_lang$core$Json$Encode$string($gren_lang$compiler_node$Compiler$ModuleName$toString(moduleName));
};
var $gren_lang$compiler_node$Compiler$Outline$exposedModulesEncoder = function(exposed) {
	if (exposed.$ === 'ExposedArray') {
		var names = exposed.a;
		return $gren_lang$core$Json$Encode$array$($gren_lang$compiler_node$Compiler$ModuleName$toJson, names);
	} else {
		var dictOfNames = exposed.a;
		return $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$array($gren_lang$compiler_node$Compiler$ModuleName$toJson), dictOfNames);
	}
};
var $gren_lang$compiler_node$SemanticVersionRange$toString = function(_v0) {
	var _v1 = _v0.a;
	var lower = _v1.lower;
	var upper = _v1.upper;
	return $gren_lang$compiler_node$SemanticVersion$toString(lower) + (' <= v < ' + $gren_lang$compiler_node$SemanticVersion$toString(upper));
};
var $gren_lang$compiler_node$SemanticVersionRange$toJson = function(range) {
	return $gren_lang$core$Json$Encode$string($gren_lang$compiler_node$SemanticVersionRange$toString(range));
};
var $gren_lang$compiler_node$Compiler$Outline$pkgDependenciesEncoder = function(deps) {
	return $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Outline$constraintEncoder($gren_lang$compiler_node$SemanticVersionRange$toJson), deps);
};
var $gren_lang$compiler_node$Compiler$License$toString = function(_v0) {
	var value = _v0.a;
	return value;
};
var $gren_lang$compiler_node$Compiler$License$toJson = function(license) {
	return $gren_lang$core$Json$Encode$string($gren_lang$compiler_node$Compiler$License$toString(license));
};
var $gren_lang$compiler_node$Compiler$PackageName$toJson = function(_package) {
	return $gren_lang$core$Json$Encode$string($gren_lang$compiler_node$Compiler$PackageName$toString(_package));
};
var $gren_lang$compiler_node$Compiler$Platform$toJson = function(platform) {
	switch (platform.$) {
		case 'Common':
			return $gren_lang$core$Json$Encode$string('common');
		case 'Browser':
			return $gren_lang$core$Json$Encode$string('browser');
		default:
			return $gren_lang$core$Json$Encode$string('node');
	}
};
var $gren_lang$compiler_node$Compiler$Outline$toJson = function(outline) {
	if (outline.$ === 'App') {
		var app = outline.a;
		return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('application') }, { key: 'platform', value: $gren_lang$compiler_node$Compiler$Platform$toJson(app.platform) }, { key: 'source-directories', value: $gren_lang$core$Json$Encode$array$($gren_lang$core$Basics$composeL$($gren_lang$core$Json$Encode$string, $gren_lang$node$FileSystem$Path$toPosixString), app.sourceDirectories) }, { key: 'gren-version', value: $gren_lang$compiler_node$SemanticVersion$toJson(app.grenVersion) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$object([ { key: 'direct', value: $gren_lang$compiler_node$Compiler$Outline$appDependenciesEncoder(app.dependencies.direct) }, { key: 'indirect', value: $gren_lang$compiler_node$Compiler$Outline$appDependenciesEncoder(app.dependencies.indirect) } ]) } ]);
	} else {
		var pkg = outline.a;
		return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('package') }, { key: 'platform', value: $gren_lang$compiler_node$Compiler$Platform$toJson(pkg.platform) }, { key: 'name', value: $gren_lang$compiler_node$Compiler$PackageName$toJson(pkg.name) }, { key: 'summary', value: $gren_lang$core$Json$Encode$string(pkg.summary) }, { key: 'license', value: $gren_lang$compiler_node$Compiler$License$toJson(pkg.license) }, { key: 'version', value: $gren_lang$compiler_node$SemanticVersion$toJson(pkg.version) }, { key: 'exposed-modules', value: $gren_lang$compiler_node$Compiler$Outline$exposedModulesEncoder(pkg.exposedModules) }, { key: 'gren-version', value: $gren_lang$compiler_node$SemanticVersionRange$toJson(pkg.grenVersion) }, { key: 'dependencies', value: $gren_lang$compiler_node$Compiler$Outline$pkgDependenciesEncoder(pkg.dependencies) } ]);
	}
};
var $author$project$Terminal$PackageInstall$packageBundleEncoder$ = function(outline, sources) {
	return $gren_lang$core$Json$Encode$object([ { key: 'outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson($gren_lang$compiler_node$Compiler$Outline$Pkg(outline)) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, sources) } ]);
};
var $author$project$Terminal$PackageInstall$packageBundleEncoder = F2($author$project$Terminal$PackageInstall$packageBundleEncoder$);
var $gren_lang$core$String$prepend = _String_append;
var $gren_lang$core$String$append$ = function(lhs, rhs) {
	return A2($gren_lang$core$String$prepend, rhs, lhs);
};
var $gren_lang$core$String$append = F2($gren_lang$core$String$append$);
var $author$project$Terminal$PackageInstall$packageBundlePath$ = function(name, version, projectPath) {
	var normalizedName = $gren_lang$core$String$append$('.pkg.gz', $gren_lang$core$String$replace$('/', '_', $gren_lang$core$String$replace$('.', '_', $gren_lang$core$String$replace$('-', '_', $gren_lang$compiler_node$Compiler$PackageName$toString(name) + ('__' + $gren_lang$compiler_node$SemanticVersion$toString(version))))));
	return $gren_lang$node$FileSystem$Path$join([ projectPath, $gren_lang$node$FileSystem$Path$fromPosixString('gren_packages'), $gren_lang$node$FileSystem$Path$fromPosixString(normalizedName) ]);
};
var $author$project$Terminal$PackageInstall$packageBundlePath = F3($author$project$Terminal$PackageInstall$packageBundlePath$);
var $gren_lang$core$Stream$pipeTo = _Stream_pipeTo;
var $gren_lang$core$Json$Decode$andThen = _Json_andThen;
var $gren_lang$core$String$slice = _String_slice;
var $gren_lang$core$String$unitLength = _String_unitLength;
var $gren_lang$core$String$dropFirst$ = function(n, string) {
	return (n < 1) ? string : A3($gren_lang$core$String$slice, n, $gren_lang$core$String$unitLength(string), string);
};
var $gren_lang$core$String$dropFirst = F2($gren_lang$core$String$dropFirst$);
var $gren_lang$core$Json$Decode$fail = _Json_fail;
var $gren_lang$core$String$foldl = _String_foldl;
var $gren_lang$core$String$count = function(string) {
	return A3($gren_lang$core$String$foldl, F2(function(_v0, num) {
				return num + 1;
			}), 0, string);
};
var $gren_lang$compiler_node$Compiler$Outline$localPrefixLength = $gren_lang$core$String$count('local:');
var $gren_lang$core$Json$Decode$map = _Json_map1;
var $gren_lang$core$Json$Decode$oneOf = _Json_oneOf;
var $gren_lang$core$Json$Decode$string = _Json_decodeString;
var $gren_lang$compiler_node$Compiler$Outline$constraintDecoder = function(versionDecoder) {
	return $gren_lang$core$Json$Decode$oneOf([ A2($gren_lang$core$Json$Decode$map, $gren_lang$compiler_node$Compiler$Outline$Version, versionDecoder), A2($gren_lang$core$Json$Decode$andThen, function(strValue) {
				return A2($gren_lang$core$String$startsWith, 'local:', strValue) ? $gren_lang$core$Json$Decode$succeed($gren_lang$compiler_node$Compiler$Outline$LocalPath($gren_lang$node$FileSystem$Path$fromPosixString($gren_lang$core$String$dropFirst$($gren_lang$compiler_node$Compiler$Outline$localPrefixLength, strValue)))) : $gren_lang$core$Json$Decode$fail('Not valid dependency constraint: ' + strValue);
			}, $gren_lang$core$Json$Decode$string) ]);
};
var $gren_lang$core$Json$Decode$keyValuePairs = _Json_decodeKeyValuePairs;
var $gren_lang$core$Json$Decode$dict = function(decoder) {
	return A2($gren_lang$core$Json$Decode$map, function(pairs) {
			return A3($gren_lang$core$Array$foldl, F2(function(p, coll) {
						return $gren_lang$core$Dict$set$(p.key, p.value, coll);
					}), $gren_lang$core$Dict$empty, pairs);
		}, $gren_lang$core$Json$Decode$keyValuePairs(decoder));
};
var $gren_lang$core$Json$Decode$field = _Json_decodeField;
var $gren_lang$compiler_node$SemanticVersion$jsonDecoder = A2($gren_lang$core$Json$Decode$andThen, function(strValue) {
		var _v0 = $gren_lang$compiler_node$SemanticVersion$fromString(strValue);
		if (_v0.$ === 'Just') {
			var semVer = _v0.a;
			return $gren_lang$core$Json$Decode$succeed(semVer);
		} else {
			return $gren_lang$core$Json$Decode$fail('This is not a valid semver formatted version: ' + strValue);
		}
	}, $gren_lang$core$Json$Decode$string);
var $gren_lang$core$Json$Decode$map2 = _Json_map2;
var $gren_lang$compiler_node$Compiler$Outline$appDependenciesDecoder = A3($gren_lang$core$Json$Decode$map2, F2(function(direct, indirect) {
			return { direct: direct, indirect: indirect };
		}), A2($gren_lang$core$Json$Decode$field, 'direct', $gren_lang$core$Json$Decode$dict($gren_lang$compiler_node$Compiler$Outline$constraintDecoder($gren_lang$compiler_node$SemanticVersion$jsonDecoder))), A2($gren_lang$core$Json$Decode$field, 'indirect', $gren_lang$core$Json$Decode$dict($gren_lang$compiler_node$Compiler$Outline$constraintDecoder($gren_lang$compiler_node$SemanticVersion$jsonDecoder))));
var $gren_lang$core$Json$Decode$array = _Json_decodeArray;
var $gren_lang$compiler_node$Compiler$Platform$Browser = { $: 'Browser' };
var $gren_lang$compiler_node$Compiler$Platform$Common = { $: 'Common' };
var $gren_lang$compiler_node$Compiler$Platform$Node = { $: 'Node' };
var $gren_lang$compiler_node$Compiler$Platform$jsonDecoder = A2($gren_lang$core$Json$Decode$andThen, function(value) {
		var _v0 = $gren_lang$core$String$toLower(value);
		switch (_v0) {
			case 'common':
				return $gren_lang$core$Json$Decode$succeed($gren_lang$compiler_node$Compiler$Platform$Common);
			case 'browser':
				return $gren_lang$core$Json$Decode$succeed($gren_lang$compiler_node$Compiler$Platform$Browser);
			case 'node':
				return $gren_lang$core$Json$Decode$succeed($gren_lang$compiler_node$Compiler$Platform$Node);
			default:
				return $gren_lang$core$Json$Decode$fail(value + ' is not a valid platform value');
		}
	}, $gren_lang$core$Json$Decode$string);
var $gren_lang$core$Json$Decode$map4 = _Json_map4;
var $gren_lang$compiler_node$Compiler$Outline$srcDirDecoder = A2($gren_lang$core$Json$Decode$andThen, function(path) {
		return (path.root === '') ? $gren_lang$core$Json$Decode$succeed(path) : $gren_lang$core$Json$Decode$fail('Path needs to be relative, not absolute: ' + $gren_lang$node$FileSystem$Path$toPosixString(path));
	}, A2($gren_lang$core$Json$Decode$map, $gren_lang$node$FileSystem$Path$fromPosixString, $gren_lang$core$Json$Decode$string));
var $gren_lang$compiler_node$Compiler$Outline$appDecoder = A5($gren_lang$core$Json$Decode$map4, F4(function(platform, srcDirs, grenVersion, deps) {
			return { dependencies: deps, grenVersion: grenVersion, platform: platform, sourceDirectories: srcDirs };
		}), A2($gren_lang$core$Json$Decode$field, 'platform', $gren_lang$compiler_node$Compiler$Platform$jsonDecoder), A2($gren_lang$core$Json$Decode$field, 'source-directories', $gren_lang$core$Json$Decode$array($gren_lang$compiler_node$Compiler$Outline$srcDirDecoder)), A2($gren_lang$core$Json$Decode$field, 'gren-version', $gren_lang$compiler_node$SemanticVersion$jsonDecoder), A2($gren_lang$core$Json$Decode$field, 'dependencies', $gren_lang$compiler_node$Compiler$Outline$appDependenciesDecoder));
var $gren_lang$compiler_node$Compiler$Outline$ExposedArray = function (a) {
	return { $: 'ExposedArray', a: a };
};
var $gren_lang$compiler_node$Compiler$Outline$ExposedDict = function (a) {
	return { $: 'ExposedDict', a: a };
};
var $gren_lang$compiler_node$Compiler$ModuleName$ModuleName = function (a) {
	return { $: 'ModuleName', a: a };
};
var $gren_lang$core$Array$all$ = function(fn, array) {
	var _v0 = A2($gren_lang$core$Array$findFirst, $gren_lang$core$Basics$composeL$($gren_lang$core$Basics$not, fn), array);
	if (_v0.$ === 'Just') {
		return false;
	} else {
		return true;
	}
};
var $gren_lang$core$Array$all = F2($gren_lang$core$Array$all$);
var $gren_lang$compiler_node$Compiler$ModuleName$fromString = function(str) {
	var sections = A2($gren_lang$core$String$split, '.', str);
	var sectionTest = function(section) {
		var _v0 = $gren_lang$core$String$popFirst(section);
		if (_v0.$ === 'Just') {
			var _v1 = _v0.a;
			var first = _v1.first;
			var rest = _v1.rest;
			return $gren_lang$core$Char$isUpper(first) && $gren_lang$core$String$all$($gren_lang$core$Char$isAlphaNum, rest);
		} else {
			return false;
		}
	};
	return $gren_lang$core$Array$all$(sectionTest, sections) ? $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$ModuleName$ModuleName(str)) : $gren_lang$core$Maybe$Nothing;
};
var $gren_lang$compiler_node$Compiler$ModuleName$jsonDecoder = A2($gren_lang$core$Json$Decode$andThen, function(str) {
		var _v0 = $gren_lang$compiler_node$Compiler$ModuleName$fromString(str);
		if (_v0.$ === 'Just') {
			var moduleName = _v0.a;
			return $gren_lang$core$Json$Decode$succeed(moduleName);
		} else {
			return $gren_lang$core$Json$Decode$fail('Not a valid module name: ' + str);
		}
	}, $gren_lang$core$Json$Decode$string);
var $gren_lang$compiler_node$Compiler$Outline$exposedModulesDecoder = $gren_lang$core$Json$Decode$oneOf([ A2($gren_lang$core$Json$Decode$map, $gren_lang$compiler_node$Compiler$Outline$ExposedArray, $gren_lang$core$Json$Decode$array($gren_lang$compiler_node$Compiler$ModuleName$jsonDecoder)), A2($gren_lang$core$Json$Decode$map, $gren_lang$compiler_node$Compiler$Outline$ExposedDict, $gren_lang$core$Json$Decode$dict($gren_lang$core$Json$Decode$array($gren_lang$compiler_node$Compiler$ModuleName$jsonDecoder))) ]);
var $gren_lang$compiler_node$Compiler$License$License = function (a) {
	return { $: 'License', a: a };
};
var $gren_lang$compiler_node$Compiler$License$osiApprovedSpdxLicenses = $gren_lang$core$Dict$set$('ZPL-2.0', 'Zope Public License 2.0', $gren_lang$core$Dict$set$('Zlib', 'zlib License', $gren_lang$core$Dict$set$('Xnet', 'X.Net License', $gren_lang$core$Dict$set$('Watcom-1.0', 'Sybase Open Watcom Public License 1.0', $gren_lang$core$Dict$set$('W3C', 'W3C Software Notice and License (2002-12-31)', $gren_lang$core$Dict$set$('VSL-1.0', 'Vovida Software License v1.0', $gren_lang$core$Dict$set$('UPL-1.0', 'Universal Permissive License v1.0', $gren_lang$core$Dict$set$('SPL-1.0', 'Sun Public License v1.0', $gren_lang$core$Dict$set$('Sleepycat', 'Sleepycat License', $gren_lang$core$Dict$set$('SISSL', 'Sun Industry Standards Source License v1.1', $gren_lang$core$Dict$set$('SimPL-2.0', 'Simple Public License 2.0', $gren_lang$core$Dict$set$('RSCPL', 'Ricoh Source Code Public License', $gren_lang$core$Dict$set$('RPSL-1.0', 'RealNetworks Public Source License v1.0', $gren_lang$core$Dict$set$('RPL-1.5', 'Reciprocal Public License 1.5', $gren_lang$core$Dict$set$('RPL-1.1', 'Reciprocal Public License 1.1', $gren_lang$core$Dict$set$('QPL-1.0', 'Q Public License 1.0', $gren_lang$core$Dict$set$('Python-2.0', 'Python License 2.0', $gren_lang$core$Dict$set$('PostgreSQL', 'PostgreSQL License', $gren_lang$core$Dict$set$('PHP-3.0', 'PHP License v3.0', $gren_lang$core$Dict$set$('OSL-3.0', 'Open Software License 3.0', $gren_lang$core$Dict$set$('OSL-2.1', 'Open Software License 2.1', $gren_lang$core$Dict$set$('OSL-2.0', 'Open Software License 2.0', $gren_lang$core$Dict$set$('OSL-1.0', 'Open Software License 1.0', $gren_lang$core$Dict$set$('OSET-PL-2.1', 'OSET Public License version 2.1', $gren_lang$core$Dict$set$('OGTSL', 'Open Group Test Suite License', $gren_lang$core$Dict$set$('OFL-1.1', 'SIL Open Font License 1.1', $gren_lang$core$Dict$set$('OCLC-2.0', 'OCLC Research Public License 2.0', $gren_lang$core$Dict$set$('NTP', 'NTP License', $gren_lang$core$Dict$set$('NPOSL-3.0', 'Non-Profit Open Software License 3.0', $gren_lang$core$Dict$set$('Nokia', 'Nokia Open Source License', $gren_lang$core$Dict$set$('NGPL', 'Nethack General Public License', $gren_lang$core$Dict$set$('NCSA', 'University of Illinois/NCSA Open Source License', $gren_lang$core$Dict$set$('Naumen', 'Naumen Public License', $gren_lang$core$Dict$set$('NASA-1.3', 'NASA Open Source Agreement 1.3', $gren_lang$core$Dict$set$('Multics', 'Multics License', $gren_lang$core$Dict$set$('MS-RL', 'Microsoft Reciprocal License', $gren_lang$core$Dict$set$('MS-PL', 'Microsoft Public License', $gren_lang$core$Dict$set$('MPL-2.0-no-copyleft-exception', 'Mozilla Public License 2.0 (no copyleft exception)', $gren_lang$core$Dict$set$('MPL-2.0', 'Mozilla Public License 2.0', $gren_lang$core$Dict$set$('MPL-1.1', 'Mozilla Public License 1.1', $gren_lang$core$Dict$set$('MPL-1.0', 'Mozilla Public License 1.0', $gren_lang$core$Dict$set$('Motosoto', 'Motosoto License', $gren_lang$core$Dict$set$('MIT', 'MIT License', $gren_lang$core$Dict$set$('MirOS', 'MirOS Licence', $gren_lang$core$Dict$set$('LPPL-1.3c', 'LaTeX Project Public License v1.3c', $gren_lang$core$Dict$set$('LPL-1.02', 'Lucent Public License v1.02', $gren_lang$core$Dict$set$('LPL-1.0', 'Lucent Public License Version 1.0', $gren_lang$core$Dict$set$('LiLiQ-Rplus-1.1', 'Licence Libre du Qubec  Rciprocit forte version 1.1', $gren_lang$core$Dict$set$('LiLiQ-R-1.1', 'Licence Libre du Qubec  Rciprocit version 1.1', $gren_lang$core$Dict$set$('LiLiQ-P-1.1', 'Licence Libre du Qubec  Permissive version 1.1', $gren_lang$core$Dict$set$('LGPL-3.0', 'GNU Lesser General Public License v3.0 only', $gren_lang$core$Dict$set$('LGPL-2.1', 'GNU Lesser General Public License v2.1 only', $gren_lang$core$Dict$set$('LGPL-2.0', 'GNU Library General Public License v2 only', $gren_lang$core$Dict$set$('ISC', 'ISC License', $gren_lang$core$Dict$set$('IPL-1.0', 'IBM Public License v1.0', $gren_lang$core$Dict$set$('IPA', 'IPA Font License', $gren_lang$core$Dict$set$('Intel', 'Intel Open Source License', $gren_lang$core$Dict$set$('HPND', 'Historic Permission Notice and Disclaimer', $gren_lang$core$Dict$set$('GPL-3.0', 'GNU General Public License v3.0 only', $gren_lang$core$Dict$set$('GPL-2.0', 'GNU General Public License v2.0 only', $gren_lang$core$Dict$set$('Frameworx-1.0', 'Frameworx Open License 1.0', $gren_lang$core$Dict$set$('Fair', 'Fair License', $gren_lang$core$Dict$set$('EUPL-1.1', 'European Union Public License 1.1', $gren_lang$core$Dict$set$('EUDatagrid', 'EU DataGrid Software License', $gren_lang$core$Dict$set$('EPL-1.0', 'Eclipse Public License 1.0', $gren_lang$core$Dict$set$('Entessa', 'Entessa Public License v1.0', $gren_lang$core$Dict$set$('EFL-2.0', 'Eiffel Forum License v2.0', $gren_lang$core$Dict$set$('EFL-1.0', 'Eiffel Forum License v1.0', $gren_lang$core$Dict$set$('ECL-2.0', 'Educational Community License v2.0', $gren_lang$core$Dict$set$('ECL-1.0', 'Educational Community License v1.0', $gren_lang$core$Dict$set$('CUA-OPL-1.0', 'CUA Office Public License v1.0', $gren_lang$core$Dict$set$('CPL-1.0', 'Common Public License 1.0', $gren_lang$core$Dict$set$('CPAL-1.0', 'Common Public Attribution License 1.0', $gren_lang$core$Dict$set$('CNRI-Python', 'CNRI Python License', $gren_lang$core$Dict$set$('CECILL-2.1', 'CeCILL Free Software License Agreement v2.1', $gren_lang$core$Dict$set$('CDDL-1.0', 'Common Development and Distribution License 1.0', $gren_lang$core$Dict$set$('CATOSL-1.1', 'Computer Associates Trusted Open Source License 1.1', $gren_lang$core$Dict$set$('BSL-1.0', 'Boost Software License 1.0', $gren_lang$core$Dict$set$('BSD-3-Clause', 'BSD 3-clause \"New\" or \"Revised\" License', $gren_lang$core$Dict$set$('BSD-2-Clause', 'BSD 2-clause \"Simplified\" License', $gren_lang$core$Dict$set$('Artistic-2.0', 'Artistic License 2.0', $gren_lang$core$Dict$set$('Artistic-1.0-Perl', 'Artistic License 1.0 (Perl)', $gren_lang$core$Dict$set$('Artistic-1.0-cl8', 'Artistic License 1.0 w/clause 8', $gren_lang$core$Dict$set$('Artistic-1.0', 'Artistic License 1.0', $gren_lang$core$Dict$set$('APSL-2.0', 'Apple Public Source License 2.0', $gren_lang$core$Dict$set$('APSL-1.2', 'Apple Public Source License 1.2', $gren_lang$core$Dict$set$('APSL-1.1', 'Apple Public Source License 1.1', $gren_lang$core$Dict$set$('APSL-1.0', 'Apple Public Source License 1.0', $gren_lang$core$Dict$set$('APL-1.0', 'Adaptive Public License 1.0', $gren_lang$core$Dict$set$('Apache-2.0', 'Apache License 2.0', $gren_lang$core$Dict$set$('Apache-1.1', 'Apache License 1.1', $gren_lang$core$Dict$set$('AGPL-3.0', 'GNU Affero General Public License v3.0', $gren_lang$core$Dict$set$('AFL-3.0', 'Academic Free License v3.0', $gren_lang$core$Dict$set$('AFL-2.1', 'Academic Free License v2.1', $gren_lang$core$Dict$set$('AFL-2.0', 'Academic Free License v2.0', $gren_lang$core$Dict$set$('AFL-1.2', 'Academic Free License v1.2', $gren_lang$core$Dict$set$('AFL-1.1', 'Academic Free License v1.1', $gren_lang$core$Dict$set$('AAL', 'Attribution Assurance License', $gren_lang$core$Dict$set$('0BSD', 'BSD Zero Clause License', $gren_lang$core$Dict$empty)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
var $gren_lang$compiler_node$Compiler$License$decodeHelper = function(givenCode) {
	return $gren_lang$core$Dict$member$(givenCode, $gren_lang$compiler_node$Compiler$License$osiApprovedSpdxLicenses) ? $gren_lang$core$Json$Decode$succeed($gren_lang$compiler_node$Compiler$License$License(givenCode)) : $gren_lang$core$Json$Decode$fail('Invalid license name: ' + givenCode);
};
var $gren_lang$compiler_node$Compiler$License$jsonDecoder = A2($gren_lang$core$Json$Decode$andThen, $gren_lang$compiler_node$Compiler$License$decodeHelper, $gren_lang$core$Json$Decode$string);
var $gren_lang$compiler_node$Compiler$PackageName$jsonDecoder = A2($gren_lang$core$Json$Decode$andThen, function(strValue) {
		var _v0 = $gren_lang$compiler_node$Compiler$PackageName$fromString(strValue);
		if (_v0.$ === 'Just') {
			var packageName = _v0.a;
			return $gren_lang$core$Json$Decode$succeed(packageName);
		} else {
			return $gren_lang$core$Json$Decode$fail('Not a valid package name: ' + strValue);
		}
	}, $gren_lang$core$Json$Decode$string);
var $gren_lang$core$String$pushLast = _String_pushLast;
var $gren_lang$core$String$keepIf$ = function(isGood, str) {
	return A3($gren_lang$core$String$foldl, F2(function(_char, acc) {
				return isGood(_char) ? A2($gren_lang$core$String$pushLast, _char, acc) : acc;
			}), '', str);
};
var $gren_lang$core$String$keepIf = F2($gren_lang$core$String$keepIf$);
var $gren_lang$compiler_node$SemanticVersionRange$fromString = function(str) {
	var _v0 = A2($gren_lang$core$String$split, '<=v<', $gren_lang$core$String$keepIf$(function(_char) {
				return !_Utils_eq(_char, _Utils_chr(' '));
			}, str));
	if (_v0.length === 2) {
		var lowerStr = _v0[0];
		var upperStr = _v0[1];
		var _v1 = { maybeLower: $gren_lang$compiler_node$SemanticVersion$fromString(lowerStr), maybeUpper: $gren_lang$compiler_node$SemanticVersion$fromString(upperStr) };
		if ((_v1.maybeLower.$ === 'Just') && (_v1.maybeUpper.$ === 'Just')) {
			var lower = _v1.maybeLower.a;
			var upper = _v1.maybeUpper.a;
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lower, upper: upper }));
		} else {
			return $gren_lang$core$Maybe$Nothing;
		}
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$compiler_node$SemanticVersionRange$jsonDecoder = A2($gren_lang$core$Json$Decode$andThen, function(strValue) {
		var _v0 = $gren_lang$compiler_node$SemanticVersionRange$fromString(strValue);
		if (_v0.$ === 'Just') {
			var range = _v0.a;
			return $gren_lang$core$Json$Decode$succeed(range);
		} else {
			return $gren_lang$core$Json$Decode$fail('Not a valid range: ' + strValue);
		}
	}, $gren_lang$core$Json$Decode$string);
var $gren_lang$core$Json$Decode$map8 = _Json_map8;
var $gren_lang$compiler_node$Compiler$Outline$pkgDependenciesDecoder = $gren_lang$core$Json$Decode$dict($gren_lang$compiler_node$Compiler$Outline$constraintDecoder($gren_lang$compiler_node$SemanticVersionRange$jsonDecoder));
var $gren_lang$compiler_node$Compiler$Outline$pkgDecoder = A9($gren_lang$core$Json$Decode$map8, F8(function(platform, name, summary, license, version, exposedModules, grenVersion, dependencies) {
			return { dependencies: dependencies, exposedModules: exposedModules, grenVersion: grenVersion, license: license, name: name, platform: platform, summary: summary, version: version };
		}), A2($gren_lang$core$Json$Decode$field, 'platform', $gren_lang$compiler_node$Compiler$Platform$jsonDecoder), A2($gren_lang$core$Json$Decode$field, 'name', $gren_lang$compiler_node$Compiler$PackageName$jsonDecoder), A2($gren_lang$core$Json$Decode$field, 'summary', $gren_lang$core$Json$Decode$string), A2($gren_lang$core$Json$Decode$field, 'license', $gren_lang$compiler_node$Compiler$License$jsonDecoder), A2($gren_lang$core$Json$Decode$field, 'version', $gren_lang$compiler_node$SemanticVersion$jsonDecoder), A2($gren_lang$core$Json$Decode$field, 'exposed-modules', $gren_lang$compiler_node$Compiler$Outline$exposedModulesDecoder), A2($gren_lang$core$Json$Decode$field, 'gren-version', $gren_lang$compiler_node$SemanticVersionRange$jsonDecoder), A2($gren_lang$core$Json$Decode$field, 'dependencies', $gren_lang$compiler_node$Compiler$Outline$pkgDependenciesDecoder));
var $gren_lang$compiler_node$Compiler$Outline$jsonDecoder = A2($gren_lang$core$Json$Decode$andThen, function(type_) {
		switch (type_) {
			case 'application':
				return A2($gren_lang$core$Json$Decode$map, $gren_lang$compiler_node$Compiler$Outline$App, $gren_lang$compiler_node$Compiler$Outline$appDecoder);
			case 'package':
				return A2($gren_lang$core$Json$Decode$map, $gren_lang$compiler_node$Compiler$Outline$Pkg, $gren_lang$compiler_node$Compiler$Outline$pkgDecoder);
			default:
				return $gren_lang$core$Json$Decode$fail('Unknown gren.json type: ' + type_);
		}
	}, A2($gren_lang$core$Json$Decode$field, 'type', $gren_lang$core$Json$Decode$string));
var $author$project$Terminal$PackageInstall$readOutline$ = function(fsPerm, path) {
	return $gren_lang$core$Task$map$($gren_lang$core$Json$Decode$decodeString($gren_lang$compiler_node$Compiler$Outline$jsonDecoder), $gren_lang$core$Task$map$($gren_lang$core$Basics$composeR$($gren_lang$core$Bytes$toString, $gren_lang$core$Maybe$withDefault('')), $gren_lang$node$FileSystem$readFile$(fsPerm, path)));
};
var $author$project$Terminal$PackageInstall$readOutline = F2($author$project$Terminal$PackageInstall$readOutline$);
var $gren_lang$node$FileSystem$remove$ = function(_v0, options, path) {
	return A2(_FileSystem_remove, options, path);
};
var $gren_lang$node$FileSystem$remove = F3($gren_lang$node$FileSystem$remove$);
var $gren_lang$compiler_node$Compiler$Dependencies$Complete = { $: 'Complete' };
var $gren_lang$compiler_node$Compiler$Dependencies$Conflict = function (a) {
	return { $: 'Conflict', a: a };
};
var $gren_lang$compiler_node$Compiler$Dependencies$Missing = function (a) {
	return { $: 'Missing', a: a };
};
var $gren_lang$compiler_node$SemanticVersionRange$intersect$ = function(left, right) {
	var _v0 = right;
	var _v1 = _v0.a;
	var lowerRight = _v1.lower;
	var upperRight = _v1.upper;
	var _v2 = left;
	var _v3 = _v2.a;
	var lowerLeft = _v3.lower;
	var upperLeft = _v3.upper;
	var _v4 = $gren_lang$compiler_node$SemanticVersion$compare$(upperLeft, upperRight);
	switch (_v4.$) {
		case 'LT':
			return (!_Utils_eq($gren_lang$compiler_node$SemanticVersion$compare$(upperLeft, lowerRight), $gren_lang$core$Basics$GT)) ? $gren_lang$core$Maybe$Nothing : $gren_lang$core$Maybe$Just(function () {
					var _v5 = $gren_lang$compiler_node$SemanticVersion$compare$(lowerLeft, lowerRight);
					switch (_v5.$) {
						case 'LT':
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerRight, upper: upperLeft });
						case 'EQ':
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerLeft, upper: upperLeft });
						default:
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerLeft, upper: upperLeft });
					}
				}());
		case 'EQ':
			return $gren_lang$core$Maybe$Just(function () {
					var _v6 = $gren_lang$compiler_node$SemanticVersion$compare$(lowerLeft, lowerRight);
					switch (_v6.$) {
						case 'LT':
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerRight, upper: upperLeft });
						case 'EQ':
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerLeft, upper: upperLeft });
						default:
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerLeft, upper: upperLeft });
					}
				}());
		default:
			return (!_Utils_eq($gren_lang$compiler_node$SemanticVersion$compare$(upperRight, lowerLeft), $gren_lang$core$Basics$GT)) ? $gren_lang$core$Maybe$Nothing : $gren_lang$core$Maybe$Just(function () {
					var _v7 = $gren_lang$compiler_node$SemanticVersion$compare$(lowerLeft, lowerRight);
					switch (_v7.$) {
						case 'LT':
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerLeft, upper: upperRight });
						case 'EQ':
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerLeft, upper: upperRight });
						default:
							return $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: lowerRight, upper: upperRight });
					}
				}());
	}
};
var $gren_lang$compiler_node$SemanticVersionRange$intersect = F2($gren_lang$compiler_node$SemanticVersionRange$intersect$);
var $gren_lang$compiler_node$Compiler$Dependencies$solveHelp$ = function(pending, solved, loaded) {
	solveHelp:
	while (true) {
		var _v0 = $gren_lang$core$Array$popFirst(pending);
		if (_v0.$ === 'Nothing') {
			return $gren_lang$compiler_node$Compiler$Dependencies$Complete;
		} else {
			var _v1 = _v0.a;
			var _v2 = _v1.first;
			var packageName = _v2.name;
			var packageVersion = _v2.version;
			var rest = _v1.rest;
			var packageNameStr = $gren_lang$compiler_node$Compiler$PackageName$toString(packageName);
			var _v3 = $gren_lang$core$Dict$get$(packageNameStr, solved);
			if (_v3.$ === 'Just') {
				var outline = _v3.a;
				var _v4 = $gren_lang$compiler_node$SemanticVersionRange$intersect$(outline.version, packageVersion);
				if (_v4.$ === 'Nothing') {
					return $gren_lang$compiler_node$Compiler$Dependencies$Conflict({ name: outline.name, version1: outline.version, version2: packageVersion });
				} else {
					var intersectedVersion = _v4.a;
					var $temp$pending = rest,
					$temp$solved = $gren_lang$core$Dict$set$(packageNameStr, _Utils_update(outline, { version: intersectedVersion }), solved),
					$temp$loaded = loaded;
					pending = $temp$pending;
					solved = $temp$solved;
					loaded = $temp$loaded;
					continue solveHelp;
				}
			} else {
				var _v5 = $gren_lang$core$Dict$get$(packageNameStr, loaded);
				if (_v5.$ === 'Nothing') {
					return $gren_lang$compiler_node$Compiler$Dependencies$Missing({ name: packageName, version: packageVersion });
				} else {
					var outline = _v5.a;
					var newPending = $gren_lang$core$Dict$foldl$(F3(function(name, version, acc) {
								return $gren_lang$core$Array$pushLast$({ name: $gren_lang$core$Maybe$withDefault$($gren_lang$compiler_node$Compiler$PackageName$example, $gren_lang$compiler_node$Compiler$PackageName$fromString(name)), version: version }, acc);
							}), rest, outline.dependencies);
					var $temp$pending = newPending,
					$temp$solved = $gren_lang$core$Dict$set$(packageNameStr, outline, solved),
					$temp$loaded = loaded;
					pending = $temp$pending;
					solved = $temp$solved;
					loaded = $temp$loaded;
					continue solveHelp;
				}
			}
		}
	}
};
var $gren_lang$compiler_node$Compiler$Dependencies$solveHelp = F3($gren_lang$compiler_node$Compiler$Dependencies$solveHelp$);
var $gren_lang$compiler_node$Compiler$Dependencies$solve$ = function(rootRequirements, loadedOutlines) {
	return $gren_lang$compiler_node$Compiler$Dependencies$solveHelp$(rootRequirements, $gren_lang$core$Dict$empty, loadedOutlines);
};
var $gren_lang$compiler_node$Compiler$Dependencies$solve = F2($gren_lang$compiler_node$Compiler$Dependencies$solve$);
var $gren_lang$core$Stream$textEncoder = _Stream_textEncoder;
var $gren_lang$core$Debug$toString = _Debug_toString;
var $gren_lang$node$FileSystem$writeFileStream$ = function(_v0, behaviour, path) {
	var pos = function () {
		switch (behaviour.$) {
			case 'Replace':
				return 0;
			case 'ReplaceFrom':
				var num = behaviour.a;
				return num;
			default:
				return -1;
		}
	}();
	return A2(_FileSystem_writeFileStream, pos, path);
};
var $gren_lang$node$FileSystem$writeFileStream = F3($gren_lang$node$FileSystem$writeFileStream$);
var $author$project$Terminal$PackageInstall$installStep$ = function(config, _v0) {
	installStep:
	while (true) {
		var projectPath = _v0.projectPath;
		var outline = _v0.outline;
		var projectSources = _v0.projectSources;
		var rootPackages = _v0.rootPackages;
		var loadedPackages = _v0.loadedPackages;
		var solvedPackages = _v0.solvedPackages;
		var _v1 = $gren_lang$compiler_node$Compiler$Dependencies$solve$(rootPackages, solvedPackages);
		switch (_v1.$) {
			case 'Complete':
				return $gren_lang$core$Task$succeed({ dependencies: loadedPackages, outline: outline, projectPath: projectPath, rootSources: projectSources });
			case 'Missing':
				var _v2 = _v1.a;
				var name = _v2.name;
				var version = _v2.version;
				var packageNameString = $gren_lang$compiler_node$Compiler$PackageName$toString(name);
				var _v3 = $gren_lang$core$Dict$get$(packageNameString, loadedPackages);
				if (_v3.$ === 'Just') {
					var loadedPackage = _v3.a;
					var $temp$config = config,
					$temp$_v0 = { loadedPackages: loadedPackages, outline: outline, projectPath: projectPath, projectSources: projectSources, rootPackages: rootPackages, solvedPackages: $gren_lang$core$Dict$set$(packageNameString, { dependencies: $gren_lang$core$Dict$mapAndKeepJust$(F2(function(_v4, constraint) {
									if (constraint.$ === 'Version') {
										var vsn = constraint.a;
										return $gren_lang$core$Maybe$Just(vsn);
									} else {
										return $gren_lang$core$Maybe$Nothing;
									}
								}), loadedPackage.outline.dependencies), name: name, version: version }, solvedPackages) };
					config = $temp$config;
					_v0 = $temp$_v0;
					continue installStep;
				} else {
					var lowerBound = $gren_lang$compiler_node$SemanticVersionRange$lowerBound(version);
					var repoPath = $author$project$Terminal$PackageInstall$localRepoPath$(name, lowerBound, projectPath);
					var bundlePath = $author$project$Terminal$PackageInstall$packageBundlePath$(name, lowerBound, projectPath);
					return A2($gren_lang$core$Task$andThen, $author$project$Terminal$PackageInstall$installStep(config), $gren_lang$core$Task$mapError$($author$project$Terminal$PackageInstall$PackageInstallDebug, $gren_lang$core$Task$map$(function(pkg) {
									return { loadedPackages: $gren_lang$core$Dict$set$($gren_lang$compiler_node$Compiler$PackageName$toString(name), { outline: pkg.outline, sources: pkg.sources }, loadedPackages), outline: outline, projectPath: projectPath, projectSources: projectSources, rootPackages: rootPackages, solvedPackages: solvedPackages };
								}, A2($gren_lang$core$Task$andThen, function(pkg) {
										var packagesDir = $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren_packages'), projectPath);
										return $gren_lang$core$Task$map$(function(_v13) {
												return pkg;
											}, A2($gren_lang$core$Task$andThen, function(stream) {
													return $gren_lang$core$Task$mapError$($gren_lang$core$Stream$errorToString, A2($gren_lang$core$Task$andThen, $gren_lang$core$Stream$pipeTo(stream), A2($gren_lang$core$Task$andThen, $gren_lang$core$Stream$awaitAndPipeThrough($gren_lang$core$Stream$gzipCompression), A2($gren_lang$core$Task$andThen, $gren_lang$core$Stream$awaitAndPipeThrough($gren_lang$core$Stream$textEncoder), $gren_lang$core$Stream$fromArray([ pkg.data ])))));
												}, $gren_lang$core$Task$mapError$($gren_lang$node$FileSystem$errorToString, A2($gren_lang$core$Task$andThen, function(_v12) {
															return $gren_lang$node$FileSystem$writeFileStream$(config.fsPermission, $gren_lang$node$FileSystem$Replace, bundlePath);
														}, A2($gren_lang$core$Task$onError, function(err) {
																return $gren_lang$node$FileSystem$errorIsFileExists(err) ? $gren_lang$core$Task$succeed(packagesDir) : $gren_lang$core$Task$fail(err);
															}, $gren_lang$node$FileSystem$makeDirectory$(config.fsPermission, { recursive: false }, packagesDir))))));
									}, A2($gren_lang$core$Task$andThen, function(_v9) {
											return A2($gren_lang$core$Task$andThen, function(decodeResult) {
													if (decodeResult.$ === 'Ok') {
														if (decodeResult.a.$ === 'Pkg') {
															var packageOutline = decodeResult.a.a;
															return $gren_lang$core$Task$map$(function(files) {
																	var sources = A3($gren_lang$core$Array$foldl, F2(function(_v11, dict) {
																				var moduleName = _v11.moduleName;
																				var source = _v11.source;
																				return $gren_lang$core$Dict$set$(moduleName, source, dict);
																			}), $gren_lang$core$Dict$empty, files);
																	return { data: A2($gren_lang$core$Json$Encode$encode, 0, $author$project$Terminal$PackageInstall$packageBundleEncoder$(packageOutline, sources)), name: name, outline: packageOutline, sources: sources };
																}, $gren_lang$core$Task$mapError$($gren_lang$node$FileSystem$errorToString, $gren_lang$compiler_node$Compiler$Outline$findSourceFiles$(config.fsPermission, $gren_lang$compiler_node$Compiler$Outline$Pkg(packageOutline), repoPath)));
														} else {
															return $gren_lang$core$Task$fail('Expected package-type outline.');
														}
													} else {
														var err = decodeResult.a;
														return $gren_lang$core$Task$fail($gren_lang$core$Debug$toString(err));
													}
												}, $gren_lang$core$Task$mapError$($gren_lang$node$FileSystem$errorToString, $author$project$Terminal$PackageInstall$readOutline$(config.fsPermission, $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), repoPath))));
										}, $gren_lang$core$Task$mapError$(function(_v8) {
												var stderr = _v8.stderr;
												return $gren_lang$core$Maybe$withDefault$('', $gren_lang$core$Bytes$toString(stderr));
											}, A2($gren_lang$core$Task$andThen, function(_v7) {
													return $author$project$Git$clonePackage$(config.cpPermission, repoPath, name, lowerBound);
												}, A2($gren_lang$core$Task$onError, function(_v6) {
														return $gren_lang$core$Task$succeed(repoPath);
													}, $gren_lang$node$FileSystem$remove$(config.fsPermission, { recursive: true }, repoPath)))))))));
				}
			default:
				return $gren_lang$core$Task$fail($author$project$Terminal$PackageInstall$PackageInstallDebug('TODO: CONFLICT'));
		}
	}
};
var $author$project$Terminal$PackageInstall$installStep = F2($author$project$Terminal$PackageInstall$installStep$);
var $gren_lang$node$FileSystem$Beginning = { $: 'Beginning' };
var $gren_lang$core$Stream$readUntilClosedHelper$ = function(stepFn, oldAcc, stream) {
	return A2($gren_lang$core$Task$onError, function(err) {
			if (err.$ === 'Closed') {
				return $gren_lang$core$Task$succeed(oldAcc);
			} else {
				return $gren_lang$core$Task$fail(err);
			}
		}, A2($gren_lang$core$Task$andThen, function(newPart) {
				var _v0 = A2(stepFn, newPart, oldAcc);
				if (_v0.$ === 'Ok') {
					var newAcc = _v0.a;
					return $gren_lang$core$Stream$readUntilClosedHelper$(stepFn, newAcc, stream);
				} else {
					var reason = _v0.a;
					return A2($gren_lang$core$Task$andThen, function(_v1) {
							return $gren_lang$core$Task$fail($gren_lang$core$Stream$Cancelled(reason));
						}, A2($gren_lang$core$Stream$cancelReadable, reason, stream));
				}
			}, $gren_lang$core$Stream$read(stream)));
};
var $gren_lang$core$Stream$readUntilClosedHelper = F3($gren_lang$core$Stream$readUntilClosedHelper$);
var $gren_lang$core$Stream$readUntilClosed$ = function(stepFn, init, stream) {
	return $gren_lang$core$Stream$readUntilClosedHelper$(stepFn, init, stream);
};
var $gren_lang$core$Stream$readUntilClosed = F3($gren_lang$core$Stream$readUntilClosed$);
var $author$project$Stream$Extra$consumeString = function(stream) {
	return $gren_lang$core$Stream$readUntilClosed$(F2(function(chunk, result) {
				return $gren_lang$core$Result$Ok(_Utils_ap(result, chunk));
			}), '', stream);
};
var $gren_lang$core$Stream$gzipDecompression = _Stream_decompressor('gzip');
var $gren_lang$compiler_node$Compiler$Outline$pkgJsonDecoder = A2($gren_lang$core$Json$Decode$andThen, function(outline) {
		if (outline.$ === 'Pkg') {
			var pkgOutline = outline.a;
			return $gren_lang$core$Json$Decode$succeed(pkgOutline);
		} else {
			return $gren_lang$core$Json$Decode$fail('Expected package outline, but decoded an application outline.');
		}
	}, $gren_lang$compiler_node$Compiler$Outline$jsonDecoder);
var $author$project$Terminal$PackageInstall$packageBundleDecoder = A3($gren_lang$core$Json$Decode$map2, F2(function(outline, sources) {
			return { outline: outline, sources: sources };
		}), A2($gren_lang$core$Json$Decode$field, 'outline', $gren_lang$compiler_node$Compiler$Outline$pkgJsonDecoder), A2($gren_lang$core$Json$Decode$field, 'sources', $gren_lang$core$Json$Decode$dict($gren_lang$core$Json$Decode$string)));
var $gren_lang$node$FileSystem$readFileStream$ = function(_v0, position, path) {
	var range = function () {
		switch (position.$) {
			case 'Beginning':
				return { end: -1, start: 0 };
			case 'From':
				var start = position.a;
				return { end: -1, start: start };
			default:
				var r = position.a;
				return r;
		}
	}();
	return A2(_FileSystem_readFileStream, range, path);
};
var $gren_lang$node$FileSystem$readFileStream = F3($gren_lang$node$FileSystem$readFileStream$);
var $gren_lang$core$Stream$textDecoder = _Stream_textDecoder;
var $author$project$Terminal$PackageInstall$loadPackageFromBundle$ = function(fsPermission, name, vsn, projectPath) {
	return A2($gren_lang$core$Task$andThen, function(stream) {
			return A2($gren_lang$core$Task$onError, function(_v1) {
					return $gren_lang$core$Task$succeed($gren_lang$core$Maybe$Nothing);
				}, A2($gren_lang$core$Task$andThen, function(data) {
						var _v0 = A2($gren_lang$core$Json$Decode$decodeString, $author$project$Terminal$PackageInstall$packageBundleDecoder, data);
						if (_v0.$ === 'Ok') {
							var bundle = _v0.a;
							return (!_Utils_eq(name, bundle.outline.name)) ? $gren_lang$core$Task$fail('Package name mismatch. Expected ' + $gren_lang$compiler_node$Compiler$PackageName$toString(name)) : ((!_Utils_eq(vsn, bundle.outline.version)) ? $gren_lang$core$Task$fail('Package version mismatch. Expected ' + $gren_lang$compiler_node$SemanticVersion$toString(vsn)) : $gren_lang$core$Task$succeed($gren_lang$core$Maybe$Just({ name: name, outline: bundle.outline, sources: bundle.sources })));
						} else {
							var jsonErr = _v0.a;
							return $gren_lang$core$Task$fail($gren_lang$core$Json$Decode$errorToString(jsonErr));
						}
					}, $gren_lang$core$Task$mapError$($gren_lang$core$Stream$errorToString, A2($gren_lang$core$Task$andThen, $author$project$Stream$Extra$consumeString, A2($gren_lang$core$Task$andThen, $gren_lang$core$Stream$awaitAndPipeThrough($gren_lang$core$Stream$textDecoder), $gren_lang$core$Stream$awaitAndPipeThrough$($gren_lang$core$Stream$gzipDecompression, stream))))));
		}, $gren_lang$core$Task$mapError$($gren_lang$node$FileSystem$errorToString, $gren_lang$node$FileSystem$readFileStream$(fsPermission, $gren_lang$node$FileSystem$Beginning, $author$project$Terminal$PackageInstall$packageBundlePath$(name, vsn, projectPath))));
};
var $author$project$Terminal$PackageInstall$loadPackageFromBundle = F4($author$project$Terminal$PackageInstall$loadPackageFromBundle$);
var $author$project$Terminal$PackageInstall$loadPackageFromPath$ = function(fsPermission, name, path) {
	var outlinePath = $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), path);
	return A2($gren_lang$core$Task$andThen, function(outlineStr) {
			var _v1 = A2($gren_lang$core$Json$Decode$decodeString, $gren_lang$compiler_node$Compiler$Outline$pkgJsonDecoder, outlineStr);
			if (_v1.$ === 'Ok') {
				var outline = _v1.a;
				return A2($gren_lang$core$Task$andThen, function(sourceFiles) {
						return (!_Utils_eq(name, outline.name)) ? $gren_lang$core$Task$fail('Name in outline was expected to be ' + $gren_lang$compiler_node$Compiler$PackageName$toString(name)) : $gren_lang$core$Task$succeed($gren_lang$core$Maybe$Just({ name: name, outline: outline, sources: A3($gren_lang$core$Array$foldl, F2(function(_v2, acc) {
											var moduleName = _v2.moduleName;
											var source = _v2.source;
											return $gren_lang$core$Dict$set$(moduleName, source, acc);
										}), $gren_lang$core$Dict$empty, sourceFiles) }));
					}, $gren_lang$core$Task$mapError$($gren_lang$node$FileSystem$errorToString, $gren_lang$compiler_node$Compiler$Outline$findSourceFiles$(fsPermission, $gren_lang$compiler_node$Compiler$Outline$Pkg(outline), path)));
			} else {
				var jsonErr = _v1.a;
				return $gren_lang$core$Task$fail($gren_lang$core$Json$Decode$errorToString(jsonErr));
			}
		}, A2($gren_lang$core$Task$andThen, function(outlineBytes) {
				var _v0 = $gren_lang$core$Bytes$toString(outlineBytes);
				if (_v0.$ === 'Just') {
					var str = _v0.a;
					return $gren_lang$core$Task$succeed(str);
				} else {
					return $gren_lang$core$Task$fail('gren.json not valid utf-8');
				}
			}, $gren_lang$core$Task$mapError$($gren_lang$node$FileSystem$errorToString, $gren_lang$node$FileSystem$readFile$(fsPermission, outlinePath))));
};
var $author$project$Terminal$PackageInstall$loadPackageFromPath = F3($author$project$Terminal$PackageInstall$loadPackageFromPath$);
var $gren_lang$core$Dict$union$ = function(t1, t2) {
	return $gren_lang$core$Dict$foldl$($gren_lang$core$Dict$set, t2, t1);
};
var $gren_lang$core$Dict$union = F2($gren_lang$core$Dict$union$);
var $author$project$Terminal$PackageInstall$run$ = function(config, _v0) {
	var projectPath = _v0.projectPath;
	var outline = _v0.outline;
	var rootDeps = function () {
		if (outline.$ === 'App') {
			var appOutline = outline.a;
			return $gren_lang$core$Dict$map$(F2(function(_v7, v) {
						if (v.$ === 'Version') {
							var vsn = v.a;
							return $gren_lang$compiler_node$Compiler$Outline$Version($gren_lang$compiler_node$SemanticVersionRange$fromExact(vsn));
						} else {
							var p = v.a;
							return $gren_lang$compiler_node$Compiler$Outline$LocalPath(p);
						}
					}), $gren_lang$core$Dict$union$(appOutline.dependencies.direct, appOutline.dependencies.indirect));
		} else {
			var pkgOutline = outline.a;
			return pkgOutline.dependencies;
		}
	}();
	return A2($gren_lang$core$Task$andThen, $author$project$Terminal$PackageInstall$installStep(config), $gren_lang$core$Task$mapError$($author$project$Terminal$PackageInstall$PackageInstallDebug, A2($gren_lang$core$Task$andThen, function(pkgs) {
					var loadedPackages = A3($gren_lang$core$Array$foldl, F2(function(pkg, dict) {
								return $gren_lang$core$Dict$set$($gren_lang$compiler_node$Compiler$PackageName$toString(pkg.name), { outline: pkg.outline, sources: pkg.sources }, dict);
							}), $gren_lang$core$Dict$empty, pkgs);
					return $gren_lang$core$Task$map$(function(sourceFiles) {
							return { loadedPackages: loadedPackages, outline: outline, projectPath: projectPath, projectSources: A3($gren_lang$core$Array$foldl, F2(function(_v3, dict) {
										var moduleName = _v3.moduleName;
										var source = _v3.source;
										return $gren_lang$core$Dict$set$(moduleName, source, dict);
									}), $gren_lang$core$Dict$empty, sourceFiles), rootPackages: $gren_lang$core$Dict$foldl$(F3(function(key, value, acc) {
										if (value.$ === 'Version') {
											var vsn = value.a;
											return $gren_lang$core$Array$pushLast$({ name: $gren_lang$core$Maybe$withDefault$($gren_lang$compiler_node$Compiler$PackageName$example, $gren_lang$compiler_node$Compiler$PackageName$fromString(key)), version: vsn }, acc);
										} else {
											var _v5 = $gren_lang$core$Dict$get$(key, loadedPackages);
											if (_v5.$ === 'Just') {
												var pkgOutline = _v5.a.outline;
												return $gren_lang$core$Array$pushLast$({ name: $gren_lang$core$Maybe$withDefault$($gren_lang$compiler_node$Compiler$PackageName$example, $gren_lang$compiler_node$Compiler$PackageName$fromString(key)), version: $gren_lang$compiler_node$SemanticVersionRange$fromExact(pkgOutline.version) }, acc);
											} else {
												return acc;
											}
										}
									}), [  ], rootDeps), solvedPackages: $gren_lang$core$Dict$empty };
						}, A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$node$FileSystem$errorIsNoSuchFileOrDirectory(err) ? $gren_lang$core$Task$succeed([  ]) : $gren_lang$core$Task$fail($gren_lang$node$FileSystem$errorToString(err));
							}, $gren_lang$compiler_node$Compiler$Outline$findSourceFiles$(config.fsPermission, outline, projectPath)));
				}, $gren_lang$core$Task$map$($gren_lang$core$Array$mapAndKeepJust($gren_lang$core$Basics$identity), $gren_lang$core$Task$concurrent(A2($gren_lang$core$Array$map, function(_v1) {
								var name = _v1.name;
								var constraint = _v1.constraint;
								if (constraint.$ === 'Version') {
									var vsn = constraint.a;
									return $author$project$Terminal$PackageInstall$loadPackageFromBundle$(config.fsPermission, name, $gren_lang$compiler_node$SemanticVersionRange$lowerBound(vsn), projectPath);
								} else {
									var path = constraint.a;
									return $author$project$Terminal$PackageInstall$loadPackageFromPath$(config.fsPermission, name, path);
								}
							}, $gren_lang$core$Dict$foldl$(F3(function(key, value, acc) {
										return $gren_lang$core$Array$pushLast$({ constraint: value, name: $gren_lang$core$Maybe$withDefault$($gren_lang$compiler_node$Compiler$PackageName$example, $gren_lang$compiler_node$Compiler$PackageName$fromString(key)) }, acc);
									}), [  ], rootDeps)))))));
};
var $author$project$Terminal$PackageInstall$run = F2($author$project$Terminal$PackageInstall$run$);
var $gren_lang$node$FileSystem$writeFile$ = function(_v0, bytes, path) {
	return A2(_FileSystem_writeFile, bytes, path);
};
var $gren_lang$node$FileSystem$writeFile = F3($gren_lang$node$FileSystem$writeFile$);
var $author$project$Terminal$PackageInstall$addPackage$ = function(config, _v0, requestedPackage) {
	var projectPath = _v0.projectPath;
	var outline = _v0.outline;
	var packageNameStr = $gren_lang$compiler_node$Compiler$PackageName$toString(requestedPackage);
	var grenJsonPath = $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), projectPath);
	if (outline.$ === 'App') {
		var appOutline = outline.a;
		var _v2 = { direct: $gren_lang$core$Dict$member$(packageNameStr, appOutline.dependencies.direct), transitive: $gren_lang$core$Dict$get$(packageNameStr, appOutline.dependencies.indirect) };
		if (!_v2.direct) {
			if (_v2.transitive.$ === 'Nothing') {
				var _v3 = _v2.transitive;
				return A2($gren_lang$core$Task$andThen, function(_v6) {
						var packageVersion = _v6.packageVersion;
						var resolved = _v6.resolved;
						var originalPackages = _Utils_ap($gren_lang$core$Dict$keys(appOutline.dependencies.direct), $gren_lang$core$Dict$keys(appOutline.dependencies.indirect));
						var newPackages = $gren_lang$core$Dict$map$(F2(function(_v12, value) {
									return value.outline.version;
								}), $gren_lang$core$Dict$keepIf$(F2(function(k, _v11) {
										return !$gren_lang$core$Array$member$(k, originalPackages);
									}), resolved.dependencies));
						var plan = 'The plan is to add the following dependencies:\n\n' + ($gren_lang$core$Dict$foldl$(F3(function(k, v, acc) {
									return acc + ('  ' + (k + (' ' + ($gren_lang$compiler_node$SemanticVersion$toString(v) + '\n'))));
								}), '', newPackages) + '\nDo you want me to update the gren.json file accordingly?');
						var finalOutline = $gren_lang$compiler_node$Compiler$Outline$App(_Utils_update(appOutline, { dependencies: _Utils_update(appOutline.dependencies, { direct: $gren_lang$core$Dict$set$(packageNameStr, $gren_lang$compiler_node$Compiler$Outline$Version(packageVersion), appOutline.dependencies.direct), indirect: $gren_lang$core$Dict$union$(appOutline.dependencies.indirect, $gren_lang$core$Dict$map$(F2(function(_v10, v) {
													return $gren_lang$compiler_node$Compiler$Outline$Version(v);
												}), $gren_lang$core$Dict$remove$(packageNameStr, newPackages))) }) }));
						return A2($gren_lang$core$Task$andThen, function(_v9) {
								return $gren_lang$core$Stream$Log$line$(config.stdout, 'Done');
							}, A2($gren_lang$core$Task$onError, function(err) {
									return $gren_lang$core$Stream$Log$line$(config.stdout, 'Error: ' + err);
								}, A2($gren_lang$core$Task$andThen, function(newOutline) {
										return $gren_lang$core$Task$map$(function(_v8) {
												return {  };
											}, $gren_lang$core$Task$mapError$(function(fsErr) {
													return $gren_lang$core$Debug$toString(fsErr);
												}, $gren_lang$node$FileSystem$writeFile$(config.fsPermission, $gren_lang$core$Bytes$fromString(newOutline), grenJsonPath)));
									}, A2($gren_lang$core$Task$andThen, function(confirmed) {
											return confirmed ? $gren_lang$core$Task$succeed(A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$compiler_node$Compiler$Outline$toJson(finalOutline))) : $gren_lang$core$Task$fail('');
										}, $gren_lang$core$Task$mapError$(function(_v7) {
												return 'Stream error';
											}, $author$project$Terminal$User$confirm({ defaultValue: true, question: plan, stdin: config.stdin, stdout: config.stdout }))))));
					}, A2($gren_lang$core$Task$andThen, function(packageVersion) {
							return $gren_lang$core$Task$map$(function(res) {
									return { packageVersion: packageVersion, resolved: res };
								}, $author$project$Terminal$PackageInstall$run$(config, { outline: $gren_lang$compiler_node$Compiler$Outline$App(_Utils_update(appOutline, { dependencies: _Utils_update(appOutline.dependencies, { direct: $gren_lang$core$Dict$set$(packageNameStr, $gren_lang$compiler_node$Compiler$Outline$Version(packageVersion), appOutline.dependencies.direct) }) })), projectPath: projectPath }));
						}, A2($gren_lang$core$Task$andThen, function(maybeVersion) {
								if (maybeVersion.$ === 'Nothing') {
									return $gren_lang$core$Task$fail($author$project$Terminal$PackageInstall$PackageInstallDebug('Could not find version'));
								} else {
									var packageVersion = maybeVersion.a;
									return $gren_lang$core$Task$succeed(packageVersion);
								}
							}, $gren_lang$core$Task$mapError$(function(err) {
									return $author$project$Terminal$PackageInstall$PackageInstallDebug($gren_lang$core$Debug$toString(err));
								}, A2($gren_lang$core$Task$andThen, function(_v4) {
										return $author$project$Git$fetchLatestVersion$(config.cpPermission, requestedPackage);
									}, $gren_lang$core$Stream$Log$line$(config.stdout, 'Installing ' + packageNameStr))))));
			} else {
				var packageVersion = _v2.transitive.a;
				return A2($gren_lang$core$Task$andThen, function(_v17) {
						return $gren_lang$core$Task$fail($author$project$Terminal$PackageInstall$PackageInstallDebug('done'));
					}, A2($gren_lang$core$Task$andThen, function(newOutline) {
							return $gren_lang$core$Task$mapError$(function(fsErr) {
									return $author$project$Terminal$PackageInstall$PackageInstallDebug($gren_lang$core$Debug$toString(fsErr));
								}, $gren_lang$node$FileSystem$writeFile$(config.fsPermission, $gren_lang$core$Bytes$fromString(newOutline), grenJsonPath));
						}, A2($gren_lang$core$Task$andThen, function(_v16) {
								return $gren_lang$core$Task$succeed(A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$compiler_node$Compiler$Outline$toJson($gren_lang$compiler_node$Compiler$Outline$App(_Utils_update(appOutline, { dependencies: { direct: $gren_lang$core$Dict$set$(packageNameStr, packageVersion, appOutline.dependencies.direct), indirect: $gren_lang$core$Dict$remove$(packageNameStr, appOutline.dependencies.indirect) } })))));
							}, A2($gren_lang$core$Task$andThen, function(answer) {
									var _v15 = $gren_lang$core$String$trim($gren_lang$core$String$toLower(answer));
									if (_v15 === 'y') {
										return $gren_lang$core$Task$succeed({  });
									} else {
										return $gren_lang$core$Task$fail($author$project$Terminal$PackageInstall$PackageInstallDebug(''));
									}
								}, $gren_lang$core$Task$mapError$(function(_v14) {
										return $author$project$Terminal$PackageInstall$PackageInstallDebug('Stream error');
									}, A2($gren_lang$core$Task$andThen, function(_v13) {
											return $gren_lang$core$Stream$readBytesAsString(config.stdin);
										}, $gren_lang$core$Stream$Log$line$(config.stdout, 'Move to direct? y/N')))))));
			}
		} else {
			return $gren_lang$core$Task$fail($author$project$Terminal$PackageInstall$PackageInstallDebug('Already installed'));
		}
	} else {
		var pkgOutline = outline.a;
		return $gren_lang$core$Dict$member$(packageNameStr, pkgOutline.dependencies) ? $gren_lang$core$Task$fail($author$project$Terminal$PackageInstall$PackageInstallDebug('Already installed')) : $gren_lang$core$Stream$Log$line$(config.stdout, 'Installing ' + packageNameStr);
	}
};
var $author$project$Terminal$PackageInstall$addPackage = F3($author$project$Terminal$PackageInstall$addPackage$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$Green = { $: 'Green' };
var $gren_lang$compiler_node$CLI$PrettyPrinter$Red = { $: 'Red' };
var $gren_lang$compiler_node$CLI$PrettyPrinter$Yellow = { $: 'Yellow' };
var $gren_lang$compiler_node$CLI$PrettyPrinter$Block = function (a) {
	return { $: 'Block', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$block = function(docs) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Block(docs);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$Colorized = function (a) {
	return { $: 'Colorized', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$color$ = function(clr, doc) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Colorized({ color: clr, document: doc, intense: false });
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$color = F2($gren_lang$compiler_node$CLI$PrettyPrinter$color$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$Empty = { $: 'Empty' };
var $gren_lang$compiler_node$CLI$PrettyPrinter$empty = $gren_lang$compiler_node$CLI$PrettyPrinter$Empty;
var $gren_lang$compiler_node$CLI$PrettyPrinter$Indented = function (a) {
	return { $: 'Indented', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$indent = function(doc) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Indented(doc);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$Text = function (a) {
	return { $: 'Text', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$text = function(str) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Text($gren_lang$core$String$replace$('\n', ' ', $gren_lang$core$String$replace$('\r', '', str)));
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$VerticalBlock = function (a) {
	return { $: 'VerticalBlock', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock = function(docs) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$VerticalBlock(docs);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$Words = function (a) {
	return { $: 'Words', a: a };
};
var $gren_lang$core$String$words = _String_words;
var $gren_lang$compiler_node$CLI$PrettyPrinter$words = function(str) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Words($gren_lang$core$String$words(str));
};
var $gren_lang$compiler_node$CLI$Parser$argumentErrorPrettified = function(err) {
	if (err.$ === 'ArgumentParserWrongArity') {
		var info = err.a;
		return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('I was expecting ' + ($gren_lang$core$String$fromInt(info.expected) + (' arguments, but seem to have received ' + ($gren_lang$core$String$fromInt(info.actual) + '.')))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
	} else {
		var info = err.a;
		return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('I\'m having trouble with this argument:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Red, $gren_lang$compiler_node$CLI$PrettyPrinter$text(info.argument))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$block([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('It\'s supposed to be a'), $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Yellow, $gren_lang$compiler_node$CLI$PrettyPrinter$text(' <' + (info.title + '> '))), $gren_lang$compiler_node$CLI$PrettyPrinter$words('value, like one of these:') ]), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock(A2($gren_lang$core$Array$map, $gren_lang$compiler_node$CLI$PrettyPrinter$text, info.examples)))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
	}
};


// MATH

var _Math_remainderBy = F2(function (b, a) {
  return a % b;
});

// https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
var _Math_modBy = F2(function (modulus, x) {
  var answer = x % modulus;
  return modulus === 0
    ? _Debug_crash(11)
    : (answer > 0 && modulus < 0) || (answer < 0 && modulus > 0)
      ? answer + modulus
      : answer;
});

// CONSTANTS

var _Math_pi = Math.PI;
var _Math_e = Math.E;
var _Math_maxSafeInteger = Number.MAX_SAFE_INTEGER;
var _Math_minSafeInteger = Number.MIN_SAFE_INTEGER;
var _Math_maxFloat = Number.MAX_VALUE;

// TRIGONOMETRY

var _Math_cos = Math.cos;
var _Math_sin = Math.sin;
var _Math_tan = Math.tan;
var _Math_acos = Math.acos;
var _Math_asin = Math.asin;
var _Math_atan = Math.atan;
var _Math_atan2 = F2(Math.atan2);

// MORE MATH

var _Math_truncate = Math.trunc;
var _Math_ceiling = Math.ceil;
var _Math_floor = Math.floor;
var _Math_round = Math.round;
var _Math_sqrt = Math.sqrt;
var _Math_log = Math.log;
var _Math_log10 = Math.log10;
var $gren_lang$core$Math$maxSafeInteger = _Math_maxSafeInteger;
var $gren_lang$compiler_node$CLI$PrettyPrinter$defaultOptions = { indentationSize: 4, maxColumns: $gren_lang$core$Math$maxSafeInteger, newlineSeparator: '\n' };
var $gren_lang$core$Json$Encode$bool = _Json_wrap;
var $gren_lang$compiler_node$Compiler$Backend$depsToJson = function(dep) {
	return $gren_lang$core$Json$Encode$object([ { key: 'outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson($gren_lang$compiler_node$Compiler$Outline$Pkg(dep.outline)) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, dep.sources) } ]);
};
var $gren_lang$compiler_node$Compiler$Backend$docsOutputEncoder = function(output) {
	switch (output.$) {
		case 'DocsStdOut':
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('stdout') } ]);
		case 'DocsDevNull':
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('null') } ]);
		default:
			var path = output.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('json') }, { key: 'path', value: $gren_lang$core$Json$Encode$string(path) } ]);
	}
};
var $gren_lang$compiler_node$Compiler$Backend$makeOutputEncoder = function(output) {
	switch (output.$) {
		case 'StdOut':
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('stdout') } ]);
		case 'DevNull':
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('null') } ]);
		case 'Html':
			var path = output.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('html') }, { key: 'path', value: $gren_lang$core$Json$Encode$string(path) } ]);
		case 'Js':
			var path = output.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('js') }, { key: 'path', value: $gren_lang$core$Json$Encode$string(path) } ]);
		default:
			var path = output.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'type', value: $gren_lang$core$Json$Encode$string('exe') }, { key: 'path', value: $gren_lang$core$Json$Encode$string(path) } ]);
	}
};
var $gren_lang$core$Json$Encode$null = _Json_encodeNull;
var $gren_lang$compiler_node$Compiler$Backend$maybeEncoder$ = function(enc, maybeVal) {
	if (maybeVal.$ === 'Just') {
		var val = maybeVal.a;
		return enc(val);
	} else {
		return $gren_lang$core$Json$Encode$null;
	}
};
var $gren_lang$compiler_node$Compiler$Backend$maybeEncoder = F2($gren_lang$compiler_node$Compiler$Backend$maybeEncoder$);
var $gren_lang$compiler_node$Compiler$Backend$maybeToBool = function(maybeVal) {
	if (maybeVal.$ === 'Just') {
		var val = maybeVal.a;
		return $gren_lang$core$Json$Encode$bool(true);
	} else {
		return $gren_lang$core$Json$Encode$bool(false);
	}
};
var $gren_lang$compiler_node$Compiler$Backend$commandEncoder$ = function(interactive, pathToString, command) {
	switch (command.$) {
		case 'Repl':
			var flags = command.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'command', value: $gren_lang$core$Json$Encode$string('repl') }, { key: 'interpreter', value: $gren_lang$compiler_node$Compiler$Backend$maybeEncoder$($gren_lang$core$Json$Encode$string, flags.interpreter) }, { key: 'project-path', value: $gren_lang$core$Json$Encode$string(pathToString(flags.projectPath)) }, { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.dependencies) } ]);
		case 'Make':
			var flags = command.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'command', value: $gren_lang$core$Json$Encode$string('make') }, { key: 'optimize', value: $gren_lang$core$Json$Encode$bool(flags.optimize) }, { key: 'sourcemaps', value: $gren_lang$core$Json$Encode$bool(flags.sourcemaps) }, { key: 'output', value: $gren_lang$compiler_node$Compiler$Backend$maybeEncoder$($gren_lang$compiler_node$Compiler$Backend$makeOutputEncoder, flags.output) }, { key: 'report-json', value: $gren_lang$compiler_node$Compiler$Backend$maybeToBool(flags.report) }, { key: 'project-path', value: $gren_lang$core$Json$Encode$string(pathToString(flags.projectPath)) }, { key: 'entry-points', value: $gren_lang$core$Json$Encode$array$($gren_lang$compiler_node$Compiler$ModuleName$toJson, flags.entryPoints) }, { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.dependencies) } ]);
		case 'Docs':
			var flags = command.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'command', value: $gren_lang$core$Json$Encode$string('docs') }, { key: 'output', value: $gren_lang$compiler_node$Compiler$Backend$maybeEncoder$($gren_lang$compiler_node$Compiler$Backend$docsOutputEncoder, flags.output) }, { key: 'report-json', value: $gren_lang$compiler_node$Compiler$Backend$maybeToBool(flags.report) }, { key: 'project-path', value: $gren_lang$core$Json$Encode$string(pathToString(flags.projectPath)) }, { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.dependencies) } ]);
		case 'PackageValidate':
			var flags = command.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'command', value: $gren_lang$core$Json$Encode$string('packageBump') }, { key: 'interactive', value: $gren_lang$core$Json$Encode$bool(interactive) }, { key: 'known-versions', value: $gren_lang$core$Json$Encode$array$($gren_lang$compiler_node$SemanticVersion$toJson, flags.knownVersions) }, { key: 'project-path', value: $gren_lang$core$Json$Encode$string(pathToString(flags.projectPath)) }, { key: 'current-version', value: $gren_lang$core$Json$Encode$object([ { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.currentVersion.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.currentVersion.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.currentVersion.dependencies) } ]) }, { key: 'previous-version', value: $gren_lang$compiler_node$Compiler$Backend$maybeEncoder$(function(_package) {
						return $gren_lang$core$Json$Encode$object([ { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(_package.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, _package.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, _package.dependencies) } ]);
					}, flags.previousVersion) } ]);
		case 'PackageBump':
			var flags = command.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'command', value: $gren_lang$core$Json$Encode$string('packageBump') }, { key: 'interactive', value: $gren_lang$core$Json$Encode$bool(interactive) }, { key: 'known-versions', value: $gren_lang$core$Json$Encode$array$($gren_lang$compiler_node$SemanticVersion$toJson, flags.knownVersions) }, { key: 'project-path', value: $gren_lang$core$Json$Encode$string(pathToString(flags.projectPath)) }, { key: 'current-version', value: $gren_lang$core$Json$Encode$object([ { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.currentVersion.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.currentVersion.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.currentVersion.dependencies) } ]) }, { key: 'published-version', value: $gren_lang$core$Json$Encode$object([ { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.publishedVersion.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.publishedVersion.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.publishedVersion.dependencies) } ]) } ]);
		default:
			var flags = command.a;
			return $gren_lang$core$Json$Encode$object([ { key: 'command', value: $gren_lang$core$Json$Encode$string('packageDiff') }, { key: 'interactive', value: $gren_lang$core$Json$Encode$bool(interactive) }, { key: 'project-path', value: $gren_lang$core$Json$Encode$string(pathToString(flags.projectPath)) }, { key: 'first-package', value: $gren_lang$core$Json$Encode$object([ { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.firstPackage.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.firstPackage.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.firstPackage.dependencies) } ]) }, { key: 'second-package', value: $gren_lang$core$Json$Encode$object([ { key: 'project-outline', value: $gren_lang$compiler_node$Compiler$Outline$toJson(flags.secondPackage.outline) }, { key: 'sources', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$core$Json$Encode$string, flags.secondPackage.rootSources) }, { key: 'dependencies', value: $gren_lang$core$Json$Encode$dict$($gren_lang$core$Basics$identity, $gren_lang$compiler_node$Compiler$Backend$depsToJson, flags.secondPackage.dependencies) } ]) } ]);
	}
};
var $gren_lang$compiler_node$Compiler$Backend$commandEncoder = F3($gren_lang$compiler_node$Compiler$Backend$commandEncoder$);
var $gren_lang$compiler_node$Compiler$Backend$encodeCommand$ = function(options, command) {
	return $gren_lang$core$Bytes$fromString(function(jsonStr) {
			return jsonStr + '\n';
		}(A2($gren_lang$core$Json$Encode$encode, 0, $gren_lang$compiler_node$Compiler$Backend$commandEncoder$(options.interactiveSession, options.pathToString, command))));
};
var $gren_lang$compiler_node$Compiler$Backend$encodeCommand = F2($gren_lang$compiler_node$Compiler$Backend$encodeCommand$);
var $gren_lang$compiler_node$CLI$Parser$describeFlagUse$ = function(knownFlags, flagName) {
	var _v0 = $gren_lang$core$Dict$get$(flagName, knownFlags);
	if (_v0.$ === 'Just') {
		var flagDescription = _v0.a;
		var examples = A2($gren_lang$core$Array$map, function(exampleStr) {
				return $gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + (flagName + ('=' + exampleStr)));
			}, flagDescription.examples);
		return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$block([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('It neeeds a'), $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Yellow, $gren_lang$compiler_node$CLI$PrettyPrinter$text(' <' + (flagDescription.title + '> '))), $gren_lang$compiler_node$CLI$PrettyPrinter$words(' like this:') ]), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock(examples))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
	} else {
		return $gren_lang$compiler_node$CLI$PrettyPrinter$empty;
	}
};
var $gren_lang$compiler_node$CLI$Parser$describeFlagUse = F2($gren_lang$compiler_node$CLI$Parser$describeFlagUse$);
var $gren_lang$compiler_node$CLI$Parser$flagErrorPrettified = function(err) {
	switch (err.$) {
		case 'FlagParserFoundValueOnToggle':
			var _v1 = err.a;
			var knownFlags = _v1.knownFlags;
			var flagName = _v1.flagName;
			return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('This flag doesn\'t take a value:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Red, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + flagName))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('Try removing the value.'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
		case 'FlagParserMissingValue':
			var _v2 = err.a;
			var knownFlags = _v2.knownFlags;
			var flagName = _v2.flagName;
			return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('This flag needs more information:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Red, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + flagName))), $gren_lang$compiler_node$CLI$Parser$describeFlagUse$(knownFlags, flagName) ]);
		case 'FlagParserInvalidValue':
			var _v3 = err.a;
			var knownFlags = _v3.knownFlags;
			var flagName = _v3.flagName;
			return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('This flag was passed an invalid value:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Red, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + flagName))), $gren_lang$compiler_node$CLI$Parser$describeFlagUse$(knownFlags, flagName) ]);
		default:
			var _v4 = err.a;
			var knownFlags = _v4.knownFlags;
			var flagName = _v4.flagName;
			var otherFlags = $gren_lang$core$Dict$foldl$(F3(function(name, desc, doc) {
						return (desc.title === '') ? $gren_lang$core$Array$pushLast$($gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + name), doc) : $gren_lang$core$Array$pushLast$($gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + (name + ('=<' + (desc.title + '>')))), doc);
					}), [  ], knownFlags);
			var suffix = ($gren_lang$core$Array$length(otherFlags) === 0) ? $gren_lang$compiler_node$CLI$PrettyPrinter$empty : $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('Maybe you meant one of these?'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock(otherFlags))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
			return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('I don\'t recognize this flag:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Red, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + flagName))), suffix ]);
	}
};
var $author$project$Terminal$Run$PackageInstallError = function (a) {
	return { $: 'PackageInstallError', a: a };
};
var $gren_lang$core$Task$await$ = function(tsk, callback) {
	return A2(_Scheduler_andThen, callback, tsk);
};
var $gren_lang$core$Task$await = F2($gren_lang$core$Task$await$);
var $gren_lang$core$Stream$UpdateState = function (a) {
	return { $: 'UpdateState', a: a };
};
var $gren_lang$core$Stream$customTransformationActionWrapper = function(toAction) {
	return F2(function(state, input) {
			var _v0 = A2(toAction, state, input);
			switch (_v0.$) {
				case 'UpdateState':
					var newState = _v0.a;
					return { cancelReason: '', ctor: 'UpdateState', send: [  ], state: newState };
				case 'Send':
					var _v1 = _v0.a;
					var newState = _v1.state;
					var sendValues = _v1.send;
					return { cancelReason: '', ctor: 'Send', send: sendValues, state: newState };
				case 'Close':
					var lastValues = _v0.a;
					return { cancelReason: '', ctor: 'Close', send: lastValues, state: state };
				default:
					var reason = _v0.a;
					return { cancelReason: reason, ctor: 'Cancel', send: [  ], state: state };
			}
		});
};
var $gren_lang$core$Stream$customTransformationWithOptions$ = function(fn, _v0) {
	var initialState = _v0.initialState;
	var readCapacity = _v0.readCapacity;
	var writeCapacity = _v0.writeCapacity;
	return A4(_Stream_customTransformation, $gren_lang$core$Stream$customTransformationActionWrapper(fn), initialState, $gren_lang$core$Basics$max$(0, readCapacity), $gren_lang$core$Basics$max$(0, writeCapacity));
};
var $gren_lang$core$Stream$customTransformationWithOptions = F2($gren_lang$core$Stream$customTransformationWithOptions$);
var $gren_lang$core$Stream$customTransformation$ = function(fn, initialState) {
	return $gren_lang$core$Stream$customTransformationWithOptions$(fn, { initialState: initialState, readCapacity: 1, writeCapacity: 1 });
};
var $gren_lang$core$Stream$customTransformation = F2($gren_lang$core$Stream$customTransformation$);
var $gren_lang$core$Stream$nullTransformation = function(initialState) {
	return $gren_lang$core$Stream$customTransformation$(F2(function(state, _v0) {
				return $gren_lang$core$Stream$UpdateState(state);
			}), initialState);
};
var $author$project$Terminal$Run$getNullStream = $gren_lang$core$Stream$nullTransformation($gren_lang$core$Bytes$fromString(''));
var $gren_lang$compiler_node$Compiler$Backend$Exe = function (a) {
	return { $: 'Exe', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$Html = function (a) {
	return { $: 'Html', a: a };
};
var $author$project$Terminal$Run$NotAnApplication = { $: 'NotAnApplication' };
var $author$project$Terminal$Run$TempPathError = function (a) {
	return { $: 'TempPathError', a: a };
};
var $gren_lang$node$FileSystem$makeTempDirectory$ = function(_v0, prefix) {
	return _FileSystem_mkdtemp(prefix);
};
var $gren_lang$node$FileSystem$makeTempDirectory = F2($gren_lang$node$FileSystem$makeTempDirectory$);
var $author$project$Terminal$Run$getOutputPath$ = function(fsPermission, outline) {
	var platform = function () {
		if (outline.$ === 'Pkg') {
			var outline_ = outline.a;
			return outline_.platform;
		} else {
			var outline_ = outline.a;
			return outline_.platform;
		}
	}();
	var getPath = F2(function(outputType, fileName) {
			return $gren_lang$core$Task$map$(function(path) {
					return { outputPath: path, outputType: outputType };
				}, $gren_lang$core$Task$mapError$($author$project$Terminal$Run$TempPathError, $gren_lang$core$Task$map$($gren_lang$node$FileSystem$Path$append($gren_lang$node$FileSystem$Path$fromPosixString(fileName)), $gren_lang$node$FileSystem$makeTempDirectory$(fsPermission, 'gren-run'))));
		});
	switch (platform.$) {
		case 'Node':
			return A2(getPath, $gren_lang$compiler_node$Compiler$Backend$Exe, 'app');
		case 'Browser':
			return A2(getPath, $gren_lang$compiler_node$Compiler$Backend$Html, 'app.html');
		default:
			return $gren_lang$core$Task$fail($author$project$Terminal$Run$NotAnApplication);
	}
};
var $author$project$Terminal$Run$getOutputPath = F2($author$project$Terminal$Run$getOutputPath$);
var $author$project$Terminal$PackageInstall$PackageInstallInvalidGrenJson = function (a) {
	return { $: 'PackageInstallInvalidGrenJson', a: a };
};
var $author$project$Terminal$PackageInstall$PackageInstallNoGrenJson = function (a) {
	return { $: 'PackageInstallNoGrenJson', a: a };
};
var $author$project$Terminal$PackageInstall$PackageInstallNoProject = function (a) {
	return { $: 'PackageInstallNoProject', a: a };
};
var $gren_lang$node$FileSystem$currentWorkingDirectory = function(_v0) {
	return _FileSystem_currentWorkingDirectory;
};
var $gren_lang$compiler_node$Compiler$Paths$projectMetadataHelp$ = function(perm, dir) {
	return A2($gren_lang$core$Task$onError, function(err) {
			return ((!_Utils_eq(dir, $gren_lang$node$FileSystem$Path$empty)) && $gren_lang$node$FileSystem$errorIsNoSuchFileOrDirectory(err)) ? $gren_lang$compiler_node$Compiler$Paths$projectMetadataHelp$(perm, $gren_lang$core$Maybe$withDefault$($gren_lang$node$FileSystem$Path$empty, $gren_lang$node$FileSystem$Path$parentPath(dir))) : $gren_lang$core$Task$fail(err);
		}, $gren_lang$node$FileSystem$checkAccess$(perm, [  ], $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), dir)));
};
var $gren_lang$compiler_node$Compiler$Paths$projectMetadataHelp = F2($gren_lang$compiler_node$Compiler$Paths$projectMetadataHelp$);
var $gren_lang$compiler_node$Compiler$Paths$projectMetadata = function(perm) {
	return A2($gren_lang$core$Task$andThen, function(workingDir) {
			return $gren_lang$compiler_node$Compiler$Paths$projectMetadataHelp$(perm, workingDir);
		}, $gren_lang$node$FileSystem$currentWorkingDirectory(perm));
};
var $gren_lang$compiler_node$Compiler$Paths$projectRoot = function(perm) {
	return $gren_lang$core$Task$map$(function(grenJsonPath) {
			return $gren_lang$core$Maybe$withDefault$($gren_lang$node$FileSystem$Path$empty, $gren_lang$node$FileSystem$Path$parentPath(grenJsonPath));
		}, $gren_lang$compiler_node$Compiler$Paths$projectMetadata(perm));
};
var $author$project$Terminal$PackageInstall$readProjectOutline = function(fsPermission) {
	return A2($gren_lang$core$Task$andThen, function(projectPath) {
			return A2($gren_lang$core$Task$andThen, function(decodeResult) {
					if (decodeResult.$ === 'Ok') {
						var outline = decodeResult.a;
						return $gren_lang$core$Task$succeed({ outline: outline, projectPath: projectPath });
					} else {
						var err = decodeResult.a;
						return $gren_lang$core$Task$fail($author$project$Terminal$PackageInstall$PackageInstallInvalidGrenJson(err));
					}
				}, $gren_lang$core$Task$mapError$($author$project$Terminal$PackageInstall$PackageInstallNoGrenJson, $author$project$Terminal$PackageInstall$readOutline$(fsPermission, $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), projectPath))));
		}, $gren_lang$core$Task$mapError$($author$project$Terminal$PackageInstall$PackageInstallNoProject, $gren_lang$compiler_node$Compiler$Paths$projectRoot(fsPermission)));
};
var $author$project$Terminal$Run$getProjectOutline = function(fsPermission) {
	return $gren_lang$core$Task$mapError$($author$project$Terminal$Run$PackageInstallError, $author$project$Terminal$PackageInstall$readProjectOutline(fsPermission));
};
var $gren_lang$node$ChildProcess$MergeWithEnvironmentVariables = function (a) {
	return { $: 'MergeWithEnvironmentVariables', a: a };
};
var $gren_lang$node$ChildProcess$DefaultShell = { $: 'DefaultShell' };
var $gren_lang$node$ChildProcess$NoLimit = { $: 'NoLimit' };
var $gren_lang$node$ChildProcess$defaultSpawnOptions$ = function(connection, onExit) {
	return { connection: connection, environmentVariables: $gren_lang$node$ChildProcess$InheritEnvironmentVariables, onExit: onExit, runDuration: $gren_lang$node$ChildProcess$NoLimit, shell: $gren_lang$node$ChildProcess$DefaultShell, workingDirectory: $gren_lang$node$ChildProcess$InheritWorkingDirectory };
};
var $gren_lang$node$ChildProcess$defaultSpawnOptions = F2($gren_lang$node$ChildProcess$defaultSpawnOptions$);
var $gren_lang$core$Dict$singleton$ = function(key, value) {
	return $gren_lang$core$Dict$node$($gren_lang$core$Dict$Black, key, value, $gren_lang$core$Dict$RBEmpty_gren_builtin, $gren_lang$core$Dict$RBEmpty_gren_builtin);
};
var $gren_lang$core$Dict$singleton = F2($gren_lang$core$Dict$singleton$);
var $gren_lang$node$ChildProcess$Spawn = function (a) {
	return { $: 'Spawn', a: a };
};
var $gren_lang$node$ChildProcess$init = $gren_lang$core$Task$succeed({  });
var $gren_lang$node$ChildProcess$onEffects$ = function(router, commands, state) {
	var _v0 = $gren_lang$core$Array$popFirst(commands);
	if (_v0.$ === 'Nothing') {
		return $gren_lang$core$Task$succeed(state);
	} else {
		var _v1 = _v0.a;
		var first = _v1.first;
		var rest = _v1.rest;
		var config = first.a;
		return A2($gren_lang$core$Task$andThen, function(_v3) {
				return $gren_lang$node$ChildProcess$onEffects$(router, rest, {  });
			}, A3(_ChildProcess_spawn, $gren_lang$core$Basics$composeL$($gren_lang$core$Platform$sendToApp(router), config.connection.onInit), $gren_lang$core$Basics$composeL$($gren_lang$core$Platform$sendToApp(router), config.onExit), config));
	}
};
var $gren_lang$node$ChildProcess$onEffects = F3($gren_lang$node$ChildProcess$onEffects$);
var $gren_lang$node$ChildProcess$onSelfMsg$ = function(_v0, _v1, _v2) {
	return $gren_lang$core$Task$succeed({  });
};
var $gren_lang$node$ChildProcess$onSelfMsg = F3($gren_lang$node$ChildProcess$onSelfMsg$);
var $gren_lang$node$ChildProcess$mapKernelSpawnConfig$ = function(mapper, config) {
	return { _arguments: config._arguments, connection: { kind: config.connection.kind, onInit: $gren_lang$core$Basics$composeL$(mapper, config.connection.onInit) }, environmentVariables: config.environmentVariables, onExit: $gren_lang$core$Basics$composeL$(mapper, config.onExit), program: config.program, runDuration: config.runDuration, shell: config.shell, workingDirectory: config.workingDirectory };
};
var $gren_lang$node$ChildProcess$mapKernelSpawnConfig = F2($gren_lang$node$ChildProcess$mapKernelSpawnConfig$);
var $gren_lang$node$ChildProcess$cmdMap$ = function(func, cmd) {
	var config = cmd.a;
	return $gren_lang$node$ChildProcess$Spawn($gren_lang$node$ChildProcess$mapKernelSpawnConfig$(func, config));
};
var $gren_lang$node$ChildProcess$cmdMap = F2($gren_lang$node$ChildProcess$cmdMap$);
_Platform_effectManagers['ChildProcess'] = _Platform_createManager($gren_lang$node$ChildProcess$init, $gren_lang$node$ChildProcess$onEffects, $gren_lang$node$ChildProcess$onSelfMsg, $gren_lang$node$ChildProcess$cmdMap);
var $gren_lang$node$ChildProcess$command = _Platform_leaf('ChildProcess');
var $gren_lang$node$ChildProcess$kernelSpawnConfig$ = function(program, _arguments, opts) {
	return { _arguments: _arguments, connection: function () {
		var _v0 = opts.connection;
		switch (_v0.$) {
			case 'Integrated':
				var toMsg = _v0.a;
				return { kind: 0, onInit: function(_v1) {
					var processId = _v1.processId;
					return toMsg(processId);
				} };
			case 'External':
				var toMsg = _v0.a;
				return { kind: 1, onInit: toMsg };
			case 'Ignored':
				var toMsg = _v0.a;
				return { kind: 2, onInit: function(_v2) {
					var processId = _v2.processId;
					return toMsg(processId);
				} };
			default:
				var toMsg = _v0.a;
				return { kind: 3, onInit: function(_v3) {
					var processId = _v3.processId;
					return toMsg(processId);
				} };
		}
	}(), environmentVariables: function () {
		var _v4 = opts.environmentVariables;
		switch (_v4.$) {
			case 'InheritEnvironmentVariables':
				return { option: 0, value: $gren_lang$core$Dict$empty };
			case 'MergeWithEnvironmentVariables':
				var value = _v4.a;
				return { option: 1, value: value };
			default:
				var value = _v4.a;
				return { option: 2, value: value };
		}
	}(), onExit: opts.onExit, program: program, runDuration: function () {
		var _v5 = opts.runDuration;
		if (_v5.$ === 'NoLimit') {
			return 0;
		} else {
			var ms = _v5.a;
			return $gren_lang$core$Basics$max$(0, ms);
		}
	}(), shell: function () {
		var _v6 = opts.shell;
		switch (_v6.$) {
			case 'NoShell':
				return { choice: 0, value: '' };
			case 'DefaultShell':
				return { choice: 1, value: '' };
			default:
				var value = _v6.a;
				return { choice: 2, value: value };
		}
	}(), workingDirectory: function () {
		var _v7 = opts.workingDirectory;
		if (_v7.$ === 'InheritWorkingDirectory') {
			return { inherit: true, override: '' };
		} else {
			var value = _v7.a;
			return { inherit: false, override: value };
		}
	}() };
};
var $gren_lang$node$ChildProcess$kernelSpawnConfig = F3($gren_lang$node$ChildProcess$kernelSpawnConfig$);
var $gren_lang$node$ChildProcess$spawn$ = function(_v0, program, _arguments, opts) {
	return $gren_lang$node$ChildProcess$command($gren_lang$node$ChildProcess$Spawn($gren_lang$node$ChildProcess$kernelSpawnConfig$(program, _arguments, opts)));
};
var $gren_lang$node$ChildProcess$spawn = F4($gren_lang$node$ChildProcess$spawn$);
var $gren_lang$compiler_node$Compiler$Backend$run$ = function(permission, options) {
	var colorEnvVar = options.useColor ? $gren_lang$core$Dict$singleton$('FORCE_COLOR', '1') : $gren_lang$core$Dict$singleton$('NO_COLOR', '1');
	return $gren_lang$node$ChildProcess$spawn$(permission, options.pathToString(options.compilerPath), [  ], _Utils_update($gren_lang$node$ChildProcess$defaultSpawnOptions$(options.connection, options.onComplete), { environmentVariables: $gren_lang$node$ChildProcess$MergeWithEnvironmentVariables(colorEnvVar), shell: $gren_lang$node$ChildProcess$NoShell }));
};
var $gren_lang$compiler_node$Compiler$Backend$run = F2($gren_lang$compiler_node$Compiler$Backend$run$);
var $author$project$Terminal$Run$make = function(config) {
	var installPackages = F2(function(nullStream, projectOutline) {
			return $gren_lang$core$Task$mapError$($author$project$Terminal$Run$PackageInstallError, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: false, stdin: $gren_lang$core$Stream$readable(nullStream), stdout: $gren_lang$core$Stream$writable(nullStream), useColor: config.useColor }, projectOutline));
		});
	var compile = F2(function(outputPath, encodedCommand_) {
			return $gren_lang$compiler_node$Compiler$Backend$run$(config.cpPermission, { compilerPath: config.compilerPath, connection: $gren_lang$node$ChildProcess$External(function(cpOpts) {
						return config.onBackendInitialized({ backendStreams: cpOpts.streams, encodedCommand: encodedCommand_ });
					}), onComplete: config.onCompiled(outputPath), pathToString: config.pathToString, useColor: config.useColor });
		});
	var backendCommand = F3(function(outputType, outputPath, packageResolution) {
			var path = config.pathToString(outputPath);
			return $gren_lang$compiler_node$Compiler$Backend$encodeCommand$({ interactiveSession: false, pathToString: config.pathToString }, $gren_lang$compiler_node$Compiler$Backend$Make({ dependencies: packageResolution.dependencies, entryPoints: [ config.moduleName ], optimize: false, outline: packageResolution.outline, output: $gren_lang$core$Maybe$Just(outputType(path)), projectPath: packageResolution.projectPath, report: $gren_lang$core$Maybe$Nothing, rootSources: packageResolution.rootSources, sourcemaps: false }));
		});
	return $gren_lang$core$Task$await$($author$project$Terminal$Run$getNullStream, function(nullStream) {
			return $gren_lang$core$Task$await$($author$project$Terminal$Run$getProjectOutline(config.fsPermission), function(projectOutline) {
					return $gren_lang$core$Task$await$($author$project$Terminal$Run$getOutputPath$(config.fsPermission, projectOutline.outline), function(_v0) {
							var outputType = _v0.outputType;
							var outputPath = _v0.outputPath;
							return $gren_lang$core$Task$await$(A2(installPackages, nullStream, projectOutline), function(packageResolution) {
									return $gren_lang$core$Task$succeed(A2(compile, outputPath, A3(backendCommand, outputType, outputPath, packageResolution)));
								});
						});
				});
		});
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$Black = { $: 'Black' };
var $author$project$Terminal$Parser$Docs = function (a) {
	return { $: 'Docs', a: a };
};
var $author$project$Terminal$Parser$Init = function (a) {
	return { $: 'Init', a: a };
};
var $author$project$Terminal$Parser$Make = function (a) {
	return { $: 'Make', a: a };
};
var $author$project$Terminal$Parser$Paths = function (a) {
	return { $: 'Paths', a: a };
};
var $author$project$Terminal$Parser$Repl = function (a) {
	return { $: 'Repl', a: a };
};
var $author$project$Terminal$Parser$Run = function (a) {
	return { $: 'Run', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$GroupParser = function (a) {
	return { $: 'GroupParser', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$UnknownCommand = function (a) {
	return { $: 'UnknownCommand', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$defineGroup = $gren_lang$compiler_node$CLI$Parser$GroupParser({ knownCommands: $gren_lang$core$Dict$empty, parseFn: F4(function(_v0, name, _v1, _v2) {
			return $gren_lang$compiler_node$CLI$Parser$UnknownCommand(name);
		}) });
var $gren_lang$compiler_node$Compiler$Backend$DocsDevNull = { $: 'DocsDevNull' };
var $gren_lang$compiler_node$Compiler$Backend$DocsJson = function (a) {
	return { $: 'DocsJson', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$DocsStdOut = { $: 'DocsStdOut' };
var $author$project$Terminal$Parser$docsOutputParser = { examples: [ '/dev/stdout', '/dev/null', 'docs.json' ], fn: function(str) {
	switch (str) {
		case '/dev/stdout':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DocsStdOut);
		case '/dev/null':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DocsDevNull);
		case 'NUL':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DocsDevNull);
		case '$null':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DocsDevNull);
		default:
			return A2($gren_lang$core$String$endsWith, '.json', str) ? $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DocsJson(str)) : $gren_lang$core$Maybe$Nothing;
	}
}, plural: 'output-files', singular: 'output-file' };
var $gren_lang$compiler_node$CLI$Parser$FlagParser = function (a) {
	return { $: 'FlagParser', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$FlagParserInvalidValue = function (a) {
	return { $: 'FlagParserInvalidValue', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$FlagParserMissingValue = function (a) {
	return { $: 'FlagParserMissingValue', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$flag$ = function(key, valueParserFn, desc, _v0) {
	var _v1 = _v0.a;
	var knownFlags = _v1.knownFlags;
	var previousSteps = _v1.parseFn;
	var descriptor = { description: desc, examples: valueParserFn.examples, title: valueParserFn.singular };
	return $gren_lang$compiler_node$CLI$Parser$FlagParser({ knownFlags: $gren_lang$core$Dict$set$(key, descriptor, knownFlags), parseFn: F2(function(flagDescriptions, opts) {
				var _v2 = A2(previousSteps, flagDescriptions, $gren_lang$core$Dict$remove$(key, opts));
				if (_v2.$ === 'Ok') {
					var next = _v2.a;
					var _v3 = $gren_lang$core$Dict$get$(key, opts);
					if (_v3.$ === 'Just') {
						if (_v3.a === '') {
							return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$FlagParserMissingValue({ flagName: key, knownFlags: flagDescriptions }));
						} else {
							var value = _v3.a;
							var _v4 = valueParserFn.fn(value);
							if (_v4.$ === 'Just') {
								var parsedValue = _v4.a;
								return $gren_lang$core$Result$Ok(next($gren_lang$core$Maybe$Just(parsedValue)));
							} else {
								return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$FlagParserInvalidValue({ flagName: key, knownFlags: flagDescriptions }));
							}
						}
					} else {
						return $gren_lang$core$Result$Ok(next($gren_lang$core$Maybe$Nothing));
					}
				} else {
					var err = _v2.a;
					return $gren_lang$core$Result$Err(err);
				}
			}) });
};
var $gren_lang$compiler_node$CLI$Parser$flag = F4($gren_lang$compiler_node$CLI$Parser$flag$);
var $gren_lang$compiler_node$CLI$Parser$FlagParserUnknownFlag = function (a) {
	return { $: 'FlagParserUnknownFlag', a: a };
};
var $gren_lang$core$Dict$first = function(dict) {
	first:
	while (true) {
		if (dict.$ === 'RBEmpty_gren_builtin') {
			return $gren_lang$core$Maybe$Nothing;
		} else {
			if (dict.a.left.$ === 'RBEmpty_gren_builtin') {
				var _v1 = dict.a;
				var key = _v1.key;
				var value = _v1.value;
				var _v2 = _v1.left;
				return $gren_lang$core$Maybe$Just({ key: key, value: value });
			} else {
				var left = dict.a.left;
				var $temp$dict = left;
				dict = $temp$dict;
				continue first;
			}
		}
	}
};
var $gren_lang$compiler_node$CLI$Parser$initFlags = function(value) {
	return $gren_lang$compiler_node$CLI$Parser$FlagParser({ knownFlags: $gren_lang$core$Dict$empty, parseFn: F2(function(knownFlags, remainingFlags) {
				var _v0 = $gren_lang$core$Dict$first(remainingFlags);
				if (_v0.$ === 'Just') {
					var unparsedFlag = _v0.a;
					return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$FlagParserUnknownFlag({ flagName: unparsedFlag.key, knownFlags: knownFlags }));
				} else {
					return $gren_lang$core$Result$Ok(value);
				}
			}) });
};
var $author$project$Terminal$Parser$initPlatformParser = { examples: [ 'common', 'browser', 'node' ], fn: function(str) {
	switch (str) {
		case 'common':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Platform$Common);
		case 'browser':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Platform$Browser);
		case 'node':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Platform$Node);
		default:
			return $gren_lang$core$Maybe$Nothing;
	}
}, plural: 'platforms', singular: 'platform' };
var $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$ = function(clr, doc) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$Colorized({ color: clr, document: doc, intense: true });
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor = F2($gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$);
var $author$project$Terminal$Parser$interpreterParser = { examples: [ 'node', 'deno', 'bun' ], fn: $gren_lang$core$Maybe$Just, plural: 'interpreters', singular: 'interpreter' };
var $author$project$Terminal$Parser$moduleNameParser = { examples: [ 'Main', 'My.Module' ], fn: $gren_lang$compiler_node$Compiler$ModuleName$fromString, plural: 'module-names', singular: 'module-name' };
var $gren_lang$compiler_node$CLI$Parser$ArgumentParser = function (a) {
	return { $: 'ArgumentParser', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$ArgumentParserWrongArity = function (a) {
	return { $: 'ArgumentParserWrongArity', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$noArgs = $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: '', parseFn: function(args) {
		return ($gren_lang$core$Array$length(args) !== 0) ? $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserWrongArity({ actual: $gren_lang$core$Array$length(args), expected: 0 })) : $gren_lang$core$Result$Ok({  });
	} });
var $gren_lang$compiler_node$CLI$Parser$noFlags = $gren_lang$compiler_node$CLI$Parser$initFlags({  });
var $gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument = function (a) {
	return { $: 'ArgumentParserInvalidArgument', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$oneArg = function(parseFn) {
	return $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: '<' + (parseFn.singular + '>'), parseFn: function(args) {
			if (args.length === 1) {
				var arg = args[0];
				return $gren_lang$core$Maybe$withDefault$($gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: arg, examples: parseFn.examples, title: parseFn.singular })), $gren_lang$core$Maybe$map$($gren_lang$core$Result$Ok, parseFn.fn(arg)));
			} else {
				return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserWrongArity({ actual: $gren_lang$core$Array$length(args), expected: 1 }));
			}
		} });
};
var $gren_lang$compiler_node$Compiler$Backend$DevNull = { $: 'DevNull' };
var $gren_lang$compiler_node$Compiler$Backend$Js = function (a) {
	return { $: 'Js', a: a };
};
var $gren_lang$compiler_node$Compiler$Backend$StdOut = { $: 'StdOut' };
var $author$project$Terminal$Parser$outputParser = { examples: [ '/dev/stdout', '/dev/null', 'index.html', 'index.js', 'app' ], fn: function(str) {
	switch (str) {
		case '/dev/stdout':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$StdOut);
		case '/dev/null':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DevNull);
		case 'NUL':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DevNull);
		case '$null':
			return $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$DevNull);
		default:
			return A2($gren_lang$core$String$endsWith, '.html', str) ? $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$Html(str)) : (A2($gren_lang$core$String$endsWith, '.js', str) ? $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$Js(str)) : $gren_lang$core$Maybe$Just($gren_lang$compiler_node$Compiler$Backend$Exe(str)));
	}
}, plural: 'output-files', singular: 'output-file' };
var $author$project$Terminal$Parser$DiffGlobal = function (a) {
	return { $: 'DiffGlobal', a: a };
};
var $author$project$Terminal$Parser$DiffLatest = { $: 'DiffLatest' };
var $author$project$Terminal$Parser$DiffRange = function (a) {
	return { $: 'DiffRange', a: a };
};
var $author$project$Terminal$Parser$DiffVersion = function (a) {
	return { $: 'DiffVersion', a: a };
};
var $author$project$Terminal$Parser$PackageBump = { $: 'PackageBump' };
var $author$project$Terminal$Parser$PackageDiff = function (a) {
	return { $: 'PackageDiff', a: a };
};
var $author$project$Terminal$Parser$PackageInstall = function (a) {
	return { $: 'PackageInstall', a: a };
};
var $author$project$Terminal$Parser$PackageOutdated = { $: 'PackageOutdated' };
var $author$project$Terminal$Parser$PackageUninstall = function (a) {
	return { $: 'PackageUninstall', a: a };
};
var $author$project$Terminal$Parser$PackageValidate = { $: 'PackageValidate' };
var $gren_lang$compiler_node$Compiler$PackageName$cliParser = { examples: [ 'gren-lang/core', 'robheghan/string-diff' ], fn: $gren_lang$compiler_node$Compiler$PackageName$fromString, plural: 'packages', singular: 'package' };
var $gren_lang$compiler_node$SemanticVersion$cliParser = { examples: [ '1.0.0', '1.2.3', '5.1.0' ], fn: $gren_lang$compiler_node$SemanticVersion$fromString, plural: 'versions', singular: 'version' };
var $gren_lang$compiler_node$CLI$Parser$mapArgs$ = function(mapper, _v0) {
	var _v1 = _v0.a;
	var desc = _v1.description;
	var fn = _v1.parseFn;
	return $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: desc, parseFn: function(args) {
			var _v2 = fn(args);
			if (_v2.$ === 'Ok') {
				var val = _v2.a;
				return $gren_lang$core$Result$Ok(mapper(val));
			} else {
				var err = _v2.a;
				return $gren_lang$core$Result$Err(err);
			}
		} });
};
var $gren_lang$compiler_node$CLI$Parser$mapArgs = F2($gren_lang$compiler_node$CLI$Parser$mapArgs$);
var $gren_lang$core$Maybe$andThen$ = function(callback, maybeValue) {
	if (maybeValue.$ === 'Just') {
		var value = maybeValue.a;
		return callback(value);
	} else {
		return $gren_lang$core$Maybe$Nothing;
	}
};
var $gren_lang$core$Maybe$andThen = F2($gren_lang$core$Maybe$andThen$);
var $gren_lang$core$Result$firstOk = function(array) {
	return $gren_lang$core$Maybe$andThen$($gren_lang$core$Result$toMaybe, $gren_lang$core$Maybe$map$(function ($) {
				return $.value;
			}, A2($gren_lang$core$Array$findFirst, $gren_lang$core$Result$isOk, array)));
};
var $gren_lang$compiler_node$CLI$Parser$oneOfArgs = function(argParsers) {
	return $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: '<one-of>', parseFn: function(args) {
			var parseResults = A2($gren_lang$core$Array$map, function(_v1) {
					var fn = _v1.a.parseFn;
					return fn(args);
				}, argParsers);
			var _v0 = $gren_lang$core$Result$firstOk(parseResults);
			if (_v0.$ === 'Just') {
				var result = _v0.a;
				return $gren_lang$core$Result$Ok(result);
			} else {
				return $gren_lang$core$Maybe$withDefault$($gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: A2($gren_lang$core$String$join, ' ', args), examples: [  ], title: '<one-of>' })), $gren_lang$core$Array$first(parseResults));
			}
		} });
};
var $gren_lang$compiler_node$CLI$Parser$threeArgs$ = function(combine, firstValue, secondValue, thirdValue) {
	return $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: '<' + (A2($gren_lang$core$String$join, '> <', [ firstValue.singular, secondValue.singular, thirdValue.singular ]) + '>'), parseFn: function(args) {
			if (args.length === 3) {
				var first = args[0];
				var second = args[1];
				var third = args[2];
				var _v1 = { first: firstValue.fn(first), second: secondValue.fn(second), third: thirdValue.fn(third) };
				if (_v1.first.$ === 'Just') {
					if (_v1.second.$ === 'Just') {
						if (_v1.third.$ === 'Just') {
							var firstOk = _v1.first.a;
							var secondOk = _v1.second.a;
							var thirdOk = _v1.third.a;
							return $gren_lang$core$Result$Ok(A3(combine, firstOk, secondOk, thirdOk));
						} else {
							var _v4 = _v1.third;
							return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: third, examples: thirdValue.examples, title: thirdValue.singular }));
						}
					} else {
						var _v3 = _v1.second;
						return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: second, examples: secondValue.examples, title: secondValue.singular }));
					}
				} else {
					var _v2 = _v1.first;
					return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: first, examples: firstValue.examples, title: firstValue.singular }));
				}
			} else {
				return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserWrongArity({ actual: $gren_lang$core$Array$length(args), expected: 3 }));
			}
		} });
};
var $gren_lang$compiler_node$CLI$Parser$threeArgs = F4($gren_lang$compiler_node$CLI$Parser$threeArgs$);
var $gren_lang$compiler_node$CLI$Parser$twoArgs$ = function(combine, firstValue, secondValue) {
	return $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: '<' + (firstValue.singular + ('> <' + (secondValue.singular + '>'))), parseFn: function(args) {
			if (args.length === 2) {
				var first = args[0];
				var second = args[1];
				var _v1 = { first: firstValue.fn(first), second: secondValue.fn(second) };
				if (_v1.first.$ === 'Just') {
					if (_v1.second.$ === 'Just') {
						var firstOk = _v1.first.a;
						var secondOk = _v1.second.a;
						return $gren_lang$core$Result$Ok(A2(combine, firstOk, secondOk));
					} else {
						var _v3 = _v1.second;
						return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: second, examples: secondValue.examples, title: secondValue.singular }));
					}
				} else {
					var _v2 = _v1.first;
					return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: first, examples: firstValue.examples, title: firstValue.singular }));
				}
			} else {
				return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserWrongArity({ actual: $gren_lang$core$Array$length(args), expected: 2 }));
			}
		} });
};
var $gren_lang$compiler_node$CLI$Parser$twoArgs = F3($gren_lang$compiler_node$CLI$Parser$twoArgs$);
var $gren_lang$compiler_node$CLI$Parser$BadArguments = function (a) {
	return { $: 'BadArguments', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$BadFlags = function (a) {
	return { $: 'BadFlags', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$HelpText = function (a) {
	return { $: 'HelpText', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$Success = function (a) {
	return { $: 'Success', a: a };
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$Cyan = { $: 'Cyan' };
var $gren_lang$compiler_node$CLI$Parser$commandHelpText$ = function(appName, spec) {
	var _v0 = spec.flags;
	var knownFlags = _v0.a.knownFlags;
	var flagDocument = $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock($gren_lang$core$Dict$foldl$(F3(function(flagName, flagDescription, acc) {
						var flagSuffix = (flagDescription.title === '') ? '' : ('=<' + (flagDescription.title + '>'));
						return A2($gren_lang$core$Array$prepend, acc, [ $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--' + (flagName + flagSuffix))), $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words(flagDescription.description)), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
					}), [  ], knownFlags)));
	var _v1 = spec._arguments;
	var argumentType = _v1.a.description;
	return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words(spec.summary), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words(appName + (' ' + (spec.word + (' ' + argumentType)))))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, spec.example, $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('You can customize this command with the following flags:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, flagDocument ]);
};
var $gren_lang$compiler_node$CLI$Parser$commandHelpText = F2($gren_lang$compiler_node$CLI$Parser$commandHelpText$);
var $gren_lang$compiler_node$CLI$Parser$runCommand$ = function(appName, args, flags, spec) {
	var _v0 = spec.flags;
	var _v1 = _v0.a;
	var knownFlags = _v1.knownFlags;
	var parseFlags = _v1.parseFn;
	var _v2 = spec._arguments;
	var parseArgs = _v2.a.parseFn;
	var _v3 = $gren_lang$core$Dict$get$('help', flags);
	if ((_v3.$ === 'Just') && (_v3.a === '')) {
		return $gren_lang$compiler_node$CLI$Parser$HelpText($gren_lang$compiler_node$CLI$Parser$commandHelpText$(appName, spec));
	} else {
		var _v4 = { argResult: parseArgs(args), flagResult: A2(parseFlags, knownFlags, flags) };
		if (_v4.argResult.$ === 'Ok') {
			if (_v4.flagResult.$ === 'Ok') {
				var argValue = _v4.argResult.a;
				var flagValues = _v4.flagResult.a;
				return $gren_lang$compiler_node$CLI$Parser$Success(A2(spec.builder, argValue, flagValues));
			} else {
				var err = _v4.flagResult.a;
				return $gren_lang$compiler_node$CLI$Parser$BadFlags(err);
			}
		} else {
			var err = _v4.argResult.a;
			return $gren_lang$compiler_node$CLI$Parser$BadArguments(err);
		}
	}
};
var $gren_lang$compiler_node$CLI$Parser$runCommand = F4($gren_lang$compiler_node$CLI$Parser$runCommand$);
var $gren_lang$compiler_node$CLI$Parser$withCommand$ = function(command, _v0) {
	var _v1 = _v0.a;
	var knownCommands = _v1.knownCommands;
	var next = _v1.parseFn;
	return $gren_lang$compiler_node$CLI$Parser$GroupParser({ knownCommands: $gren_lang$core$Dict$set$(command.word, command.commonDescription, knownCommands), parseFn: F4(function(appName, name, args, flags) {
				return (!_Utils_eq(name, command.word)) ? A4(next, appName, name, args, flags) : $gren_lang$compiler_node$CLI$Parser$runCommand$(appName, args, flags, command);
			}) });
};
var $gren_lang$compiler_node$CLI$Parser$withCommand = F2($gren_lang$compiler_node$CLI$Parser$withCommand$);
var $author$project$Terminal$Parser$packageCommands = $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$oneOfArgs([ $gren_lang$compiler_node$CLI$Parser$mapArgs$(function(_v9) {
				return $author$project$Terminal$Parser$DiffLatest;
			}, $gren_lang$compiler_node$CLI$Parser$noArgs), $gren_lang$compiler_node$CLI$Parser$mapArgs$($author$project$Terminal$Parser$DiffVersion, $gren_lang$compiler_node$CLI$Parser$oneArg($gren_lang$compiler_node$SemanticVersion$cliParser)), $gren_lang$compiler_node$CLI$Parser$twoArgs$(F2(function(lower, upper) {
					return $author$project$Terminal$Parser$DiffRange({ lower: lower, upper: upper });
				}), $gren_lang$compiler_node$SemanticVersion$cliParser, $gren_lang$compiler_node$SemanticVersion$cliParser), $gren_lang$compiler_node$CLI$Parser$threeArgs$(F3(function(_package, lower, upper) {
					return $author$project$Terminal$Parser$DiffGlobal({ lower: lower, _package: _package, upper: upper });
				}), $gren_lang$compiler_node$Compiler$PackageName$cliParser, $gren_lang$compiler_node$SemanticVersion$cliParser, $gren_lang$compiler_node$SemanticVersion$cliParser) ]), builder: F2(function(args, _v10) {
			return $author$project$Terminal$Parser$PackageDiff(args);
		}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('For example, to see what changed in the Browser package between\nversions 1.0.0 and 2.0.0, you can say:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$text('gren package diff gren-lang/browser 1.0.0 2.0.0'))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('Sometimes a MAJOR change is not actually very big, so\nthis can help you plan your upgrade timelines.') ]), flags: $gren_lang$compiler_node$CLI$Parser$noFlags, summary: 'The `diff` command detects API changes:', word: 'diff' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v7, _v8) {
				return $author$project$Terminal$Parser$PackageBump;
			}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$words('Say you just published version 1.0.0, but then decided to remove a function.\nI will compare the published API to what you have locally, figure out that\nit is a MAJOR change, and bump your version number to 2.0.0. I do this with\nall packages, so there cannot be MAJOR changes hiding in PATCH releases in Gren!'), flags: $gren_lang$compiler_node$CLI$Parser$noFlags, summary: 'The `bump` command figures out the next version number based on API changes:', word: 'bump' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v5, _v6) {
					return $author$project$Terminal$Parser$PackageValidate;
				}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('Gren packages are \"just\" git repositories hosted on github. As\nlong as you\'ve tagged your repository with semver formatted tags,\nanyone can add your package as a dependency.'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('However, a package is no better than its documentation. This command\ntherefore checks that your package exposes a bare minimum of\nprose that the users of your package can read.'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('Keep in mind, you don\'t just want to tell people HOW to use\nyour package. It\'s equally important to tell them WHY. What\nproblem does it solve? Why should people use this particular\npackage to solve their problem?'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('Once this command passes, you may want to add your repo to\n<https://packages.gren-lang.org> so it becomes easier for the Gren\ncommunity to find your package, and its documentation.') ]), flags: $gren_lang$compiler_node$CLI$Parser$noFlags, summary: 'The `validate` command checks that you\'ve done everything necessary for' + ' others in the Gren community to use your package as a dependency:', word: 'validate' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v3, _v4) {
						return $author$project$Terminal$Parser$PackageOutdated;
					}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$text('gren package outdated'))), flags: $gren_lang$compiler_node$CLI$Parser$noFlags, summary: 'The `outdated` command lists the latest version of your dependencies,' + ' if you\'re not already up to date:', word: 'outdated' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$oneArg($gren_lang$compiler_node$Compiler$PackageName$cliParser), builder: F2(function(arg, _v2) {
							return $author$project$Terminal$Parser$PackageUninstall(arg);
						}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('For example, if you want to get rid of the browser package in your project,\nyou would say:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$text('gren package uninstall gren-lang/browser'))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('Notice that you must say the AUTHOR name and PROJECT name!'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('What if another package depends on the package you\'re trying to remove? No problem!\nI\'ll let you know if that\'s the case, and help you resolve the situation. ') ]), flags: $gren_lang$compiler_node$CLI$Parser$noFlags, summary: 'The `uninstall` command removes packages from your project:', word: 'uninstall' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$oneOfArgs([ $gren_lang$compiler_node$CLI$Parser$mapArgs$(function(_v0) {
									return $gren_lang$core$Maybe$Nothing;
								}, $gren_lang$compiler_node$CLI$Parser$noArgs), $gren_lang$compiler_node$CLI$Parser$mapArgs$($gren_lang$core$Maybe$Just, $gren_lang$compiler_node$CLI$Parser$oneArg($gren_lang$compiler_node$Compiler$PackageName$cliParser)) ]), builder: F2(function(arg, _v1) {
								return $author$project$Terminal$Parser$PackageInstall(arg);
							}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('For example, if you want to get access to Web APIs in your project,\nyou would say:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$text('gren package install gren-lang/browser'))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('Notice that you must say the AUTHOR name and PROJECT name! After running those\ncommands, you could say `import Browser` in your code.'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('You can also call this command without any arguments to download all dependencies\nlisted in gren.json. This can be helpful in Continous Integration setups where\nyou want to cache dependencies between builds.') ]), flags: $gren_lang$compiler_node$CLI$Parser$noFlags, summary: 'The `install` command fetches packages from github for use in your project:', word: 'install' }, $gren_lang$compiler_node$CLI$Parser$defineGroup))))));
var $author$project$Terminal$Parser$reportParser = { examples: [ 'json' ], fn: function(str) {
	return (str === 'json') ? $gren_lang$core$Maybe$Just({  }) : $gren_lang$core$Maybe$Nothing;
}, plural: 'report-types', singular: 'report-type' };
var $gren_lang$compiler_node$CLI$Parser$FlagParserFoundValueOnToggle = function (a) {
	return { $: 'FlagParserFoundValueOnToggle', a: a };
};
var $gren_lang$compiler_node$CLI$Parser$toggle$ = function(key, desc, _v0) {
	var _v1 = _v0.a;
	var knownFlags = _v1.knownFlags;
	var previousSteps = _v1.parseFn;
	var descriptor = { description: desc, examples: [  ], title: '' };
	return $gren_lang$compiler_node$CLI$Parser$FlagParser({ knownFlags: $gren_lang$core$Dict$set$(key, descriptor, knownFlags), parseFn: F2(function(flagDescriptions, opts) {
				var _v2 = A2(previousSteps, flagDescriptions, $gren_lang$core$Dict$remove$(key, opts));
				if (_v2.$ === 'Ok') {
					var next = _v2.a;
					var _v3 = $gren_lang$core$Dict$get$(key, opts);
					if (_v3.$ === 'Just') {
						if (_v3.a === '') {
							return $gren_lang$core$Result$Ok(next(true));
						} else {
							return $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$FlagParserFoundValueOnToggle({ flagName: key, knownFlags: flagDescriptions }));
						}
					} else {
						return $gren_lang$core$Result$Ok(next(false));
					}
				} else {
					var err = _v2.a;
					return $gren_lang$core$Result$Err(err);
				}
			}) });
};
var $gren_lang$compiler_node$CLI$Parser$toggle = F3($gren_lang$compiler_node$CLI$Parser$toggle$);
var $author$project$Meta$version = { major: 0, minor: 5, patch: 5 };
var $gren_lang$compiler_node$CLI$Parser$prefixHelpText$ = function(appName, prefixName, _v0) {
	var knownCommands = _v0.a.knownCommands;
	var knownCommandsDocument = $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock(A2($gren_lang$core$Array$map, function(command) {
							return $gren_lang$compiler_node$CLI$PrettyPrinter$text(appName + (' ' + (prefixName + (' ' + command))));
						}, $gren_lang$core$Dict$keys(knownCommands))))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$block([ $gren_lang$compiler_node$CLI$PrettyPrinter$text('Adding the '), $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--help')), $gren_lang$compiler_node$CLI$PrettyPrinter$text(' flag gives you more details about a specific command.') ]) ]);
	return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('This is just a prefix. In order to do something useful, you need to give me a command. Here\'s a full list:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, knownCommandsDocument, $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
};
var $gren_lang$compiler_node$CLI$Parser$prefixHelpText = F3($gren_lang$compiler_node$CLI$Parser$prefixHelpText$);
var $gren_lang$compiler_node$CLI$Parser$runPrefix$ = function(appName, prefixName, _arguments, flags, groupParser) {
	var parse = groupParser.a.parseFn;
	var _v0 = $gren_lang$core$Array$popFirst(_arguments);
	if (_v0.$ === 'Just') {
		var _v1 = _v0.a;
		var command = _v1.first;
		var args = _v1.rest;
		return A4(parse, appName, command, args, flags);
	} else {
		return $gren_lang$compiler_node$CLI$Parser$HelpText($gren_lang$compiler_node$CLI$Parser$prefixHelpText$(appName, prefixName, groupParser));
	}
};
var $gren_lang$compiler_node$CLI$Parser$runPrefix = F5($gren_lang$compiler_node$CLI$Parser$runPrefix$);
var $gren_lang$compiler_node$CLI$Parser$withPrefix$ = function(prefix, prefixedCommands, _v0) {
	var _v1 = _v0.a;
	var knownCommands = _v1.knownCommands;
	var nextCommand = _v1.parseFn;
	return $gren_lang$compiler_node$CLI$Parser$GroupParser({ knownCommands: $gren_lang$core$Dict$set$(prefix, $gren_lang$core$Maybe$Nothing, knownCommands), parseFn: F4(function(appName, name, args, flags) {
				return (!_Utils_eq(name, prefix)) ? A4(nextCommand, appName, name, args, flags) : $gren_lang$compiler_node$CLI$Parser$runPrefix$(appName, prefix, args, flags, prefixedCommands);
			}) });
};
var $gren_lang$compiler_node$CLI$Parser$withPrefix = F3($gren_lang$compiler_node$CLI$Parser$withPrefix$);
var $gren_lang$compiler_node$CLI$Parser$zeroOrMoreArgs = function(parseFn) {
	return $gren_lang$compiler_node$CLI$Parser$ArgumentParser({ description: parseFn.plural, parseFn: function(args) {
			var parsedArgs = $gren_lang$core$Array$mapAndKeepJust$(parseFn.fn, args);
			return (!_Utils_eq($gren_lang$core$Array$length(args), $gren_lang$core$Array$length(parsedArgs))) ? $gren_lang$core$Result$Err($gren_lang$compiler_node$CLI$Parser$ArgumentParserInvalidArgument({ argument: A2($gren_lang$core$String$join, ' ', args), examples: parseFn.examples, title: parseFn.plural })) : $gren_lang$core$Result$Ok(parsedArgs);
		} });
};
var $author$project$Terminal$Parser$parser = { commands: $gren_lang$compiler_node$CLI$Parser$withPrefix$('package', $author$project$Terminal$Parser$packageCommands, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v4, flags) {
				return $author$project$Terminal$Parser$Docs(flags);
			}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('For example:'), $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words('gren docs'))), $gren_lang$compiler_node$CLI$PrettyPrinter$words('This collects all documentation for the current pacage and writes it to a\ndocs.json file, if possible.') ]), flags: $gren_lang$compiler_node$CLI$Parser$flag$('report', $author$project$Terminal$Parser$reportParser, 'You can say --report=json to get error messages as JSON. This is only really useful if you are an editor plugin. Humans should avoid it!', $gren_lang$compiler_node$CLI$Parser$flag$('output', $author$project$Terminal$Parser$docsOutputParser, 'Specify the name of the resulting JSON file. For example --output=assets/docs.json to generate the JSON at assets/docs.json. You can also use --output=/dev/stdout to output the JSON to the terminal, or --output=/dev/null to verify that generating the documentation would work.', $gren_lang$compiler_node$CLI$Parser$initFlags(F2(function(output, report) {
							return { output: output, report: report };
						})))), summary: 'The `docs` command collects all documentation for a package in a JSON file:', word: 'docs' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$oneArg($author$project$Terminal$Parser$moduleNameParser), builder: F2(function(arg, _v3) {
					return $author$project$Terminal$Parser$Run(arg);
				}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('For example:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words('gren run Main'))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('This tries to compile a Gren file named src/Main.gren.\nThe file must have a `main` function that returns a Node program.') ]), flags: $gren_lang$compiler_node$CLI$Parser$noFlags, summary: 'The `run` command compiles and runs a Gren module:', word: 'run' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$zeroOrMoreArgs($author$project$Terminal$Parser$moduleNameParser), builder: F2(function(args, flags) {
						return $author$project$Terminal$Parser$Make({ entryPoints: args, optimize: flags.optimize, output: flags.output, report: flags.report, sourcemaps: flags.sourcemaps });
					}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('For example:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words('gren make src/Main.gren'))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('This tries to compile an Gren file named src/Main.gren, generating an index.html\nfile if possible.') ]), flags: $gren_lang$compiler_node$CLI$Parser$flag$('report', $author$project$Terminal$Parser$reportParser, 'You can say --report=json to get error messages as JSON. This is only really useful if you are an editor plugin. Humans should avoid it!', $gren_lang$compiler_node$CLI$Parser$flag$('output', $author$project$Terminal$Parser$outputParser, 'Specify the name of the resulting JS file. For example --output=assets/gren.js to generate the JS at assets/gren.js. You can also use --output=/dev/stdout to output the JS to the terminal, or --output=/dev/null to generate no output at all!', $gren_lang$compiler_node$CLI$Parser$toggle$('sourcemaps', 'Add sourcemaps to the resulting JS file. This let\'s you debug Gren code in a JS debugger, at the cost of longer compile times and a bigger JS file.', $gren_lang$compiler_node$CLI$Parser$toggle$('optimize', 'Turn on optimizations to make code smaller and faster. For example, the compiler renames record fields to be as short as possible and unboxes values to reduce allocation.', $gren_lang$compiler_node$CLI$Parser$initFlags(F4(function(optimize, sourcemaps, output, report) {
											return { optimize: optimize, output: output, report: report, sourcemaps: sourcemaps };
										})))))), summary: 'The `make` command compiles Gren code into JS or HTML:', word: 'make' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v2, flags) {
							return $author$project$Terminal$Parser$Paths(flags);
						}), commonDescription: $gren_lang$core$Maybe$Nothing, example: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('For example:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words('gren paths --backend'))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$words('This will write the path to the compiler backend.\nExecuting the command without any flags will print _all_ relevant paths.') ]), flags: $gren_lang$compiler_node$CLI$Parser$toggle$('json', 'Output in JSON format', $gren_lang$compiler_node$CLI$Parser$toggle$('backend', 'Only output the path to the compiler backend', $gren_lang$compiler_node$CLI$Parser$toggle$('package-cache', 'Only output the path to the package cache', $gren_lang$compiler_node$CLI$Parser$toggle$('project', 'Only output the path to the project', $gren_lang$compiler_node$CLI$Parser$initFlags(F4(function(project, packageCache, backend, json) {
												return { backend: backend, json: json, packageCache: packageCache, project: project };
											})))))), summary: 'Return the paths used for compiling a project.', word: 'paths' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v1, flags) {
								return $author$project$Terminal$Parser$Repl(flags);
							}), commonDescription: $gren_lang$core$Maybe$Just('Open up an interactive programming session. Type in Gren expressions like\n(2 + 2) or (String.length \"test\") and see if they equal four!'), example: $gren_lang$compiler_node$CLI$PrettyPrinter$words('Start working through <https://gren-lang.org/learn> to learn how to use this!\nIt has a whole chapter that uses the REPL for everything, so that is probably\nthe quickest way to get started.'), flags: $gren_lang$compiler_node$CLI$Parser$flag$('interpreter', $author$project$Terminal$Parser$interpreterParser, 'Path to a alternate JS interpreter, like deno or nodejs', $gren_lang$compiler_node$CLI$Parser$initFlags(function(maybeInterpreter) {
									return { interpreter: maybeInterpreter };
								})), summary: 'The `repl` command opens up an interactive programming session:', word: 'repl' }, $gren_lang$compiler_node$CLI$Parser$withCommand$({ _arguments: $gren_lang$compiler_node$CLI$Parser$noArgs, builder: F2(function(_v0, flags) {
									return $author$project$Terminal$Parser$Init(flags);
								}), commonDescription: $gren_lang$core$Maybe$Just('Start a Gren project. It creates a starter gren.json file.'), example: $gren_lang$compiler_node$CLI$PrettyPrinter$words('It will ask permission to create a gren.json file, the one thing\ncommon to all Gren project.'), flags: $gren_lang$compiler_node$CLI$Parser$flag$('platform', $author$project$Terminal$Parser$initPlatformParser, 'Which platform to target', $gren_lang$compiler_node$CLI$Parser$toggle$('package', 'Create a package (as opposed to an application)', $gren_lang$compiler_node$CLI$Parser$initFlags(F2(function(_package, maybePlatform) {
												return { _package: _package, platform: _package ? $gren_lang$core$Maybe$withDefault$($gren_lang$compiler_node$Compiler$Platform$Common, maybePlatform) : $gren_lang$core$Maybe$withDefault$($gren_lang$compiler_node$Compiler$Platform$Browser, maybePlatform) };
											})))), summary: 'The `init` command helps start Gren project:', word: 'init' }, $gren_lang$compiler_node$CLI$Parser$defineGroup))))))), intro: $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$block([ $gren_lang$compiler_node$CLI$PrettyPrinter$text('Hi, thank you for trying out '), $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$($gren_lang$compiler_node$CLI$PrettyPrinter$Green, $gren_lang$compiler_node$CLI$PrettyPrinter$text('Gren ' + $gren_lang$compiler_node$Compiler$Backend$version)), $gren_lang$compiler_node$CLI$PrettyPrinter$text('. I hope you like it!') ]), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$($gren_lang$compiler_node$CLI$PrettyPrinter$Black, $gren_lang$compiler_node$CLI$PrettyPrinter$text('-------------------------------------------------------------------------------\nI highly recommend working through <https://gren-lang.org/learn> to get started\nIt teaches many important concepts, including how to use `gren` in the terminal\n-------------------------------------------------------------------------------')) ]), name: 'gren', outro: $gren_lang$compiler_node$CLI$PrettyPrinter$words('Be sure to ask on the Gren Discord (https://discord.gg/Chb9YB9Vmh) if you run into trouble!\nFolks are friendly and happy to help out. They hang out there because it is fun, so be kind\nto get the best results!'), version: $gren_lang$compiler_node$SemanticVersion$toString($author$project$Meta$version) };
var $gren_lang$core$Dict$isEmpty = function(dict) {
	if (dict.$ === 'RBEmpty_gren_builtin') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$compiler_node$CLI$Parser$appHelpText = function(appDef) {
	var _v0 = appDef.commands;
	var knownCommands = _v0.a.knownCommands;
	var commonCommands = $gren_lang$core$Dict$mapAndKeepJust$(F2(function(_v1, commonDescription) {
				return commonDescription;
			}), knownCommands);
	var knownCommandsDocument = $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock(A2($gren_lang$core$Array$map, function(command) {
							return $gren_lang$compiler_node$CLI$PrettyPrinter$text(appDef.name + (' ' + command));
						}, $gren_lang$core$Dict$keys(knownCommands))))), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$block([ $gren_lang$compiler_node$CLI$PrettyPrinter$text('Adding the '), $gren_lang$compiler_node$CLI$PrettyPrinter$color$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$text('--help')), $gren_lang$compiler_node$CLI$PrettyPrinter$text(' flag gives you more details about a specific command.') ]) ]);
	var commandBlock = $gren_lang$core$Dict$isEmpty(commonCommands) ? $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('In order to do something useful, you need to give me a command. Here\'s a full list:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, knownCommandsDocument ]) : $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$words('The most common commands are:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock($gren_lang$core$Dict$foldl$(F3(function(name, description, acc) {
							return $gren_lang$core$Array$pushLast$($gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ $gren_lang$compiler_node$CLI$PrettyPrinter$intenseColor$($gren_lang$compiler_node$CLI$PrettyPrinter$Cyan, $gren_lang$compiler_node$CLI$PrettyPrinter$text(appDef.name + (' ' + name))), $gren_lang$compiler_node$CLI$PrettyPrinter$indent($gren_lang$compiler_node$CLI$PrettyPrinter$words(description)), $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]), acc);
						}), [  ], commonCommands))), $gren_lang$compiler_node$CLI$PrettyPrinter$words('There are a bunch of other commands as well though. Here is a full list:'), $gren_lang$compiler_node$CLI$PrettyPrinter$empty, knownCommandsDocument ]);
	return $gren_lang$compiler_node$CLI$PrettyPrinter$verticalBlock([ appDef.intro, $gren_lang$compiler_node$CLI$PrettyPrinter$empty, commandBlock, $gren_lang$compiler_node$CLI$PrettyPrinter$empty, appDef.outro, $gren_lang$compiler_node$CLI$PrettyPrinter$empty ]);
};
var $gren_lang$core$Array$takeFirst$ = function(n, array) {
	return A3($gren_lang$core$Array$slice, 0, n, array);
};
var $gren_lang$core$Array$takeFirst = F2($gren_lang$core$Array$takeFirst$);
var $gren_lang$compiler_node$CLI$Parser$buildFlagDict = function(flags) {
	return A3($gren_lang$core$Array$foldl, F2(function(rawFlag, dict) {
				var flagParts = $gren_lang$core$Array$takeFirst$(2, A2($gren_lang$core$String$split, '=', $gren_lang$core$String$dropFirst$(2, rawFlag)));
				switch (flagParts.length) {
					case 1:
						var key = flagParts[0];
						return $gren_lang$core$Dict$set$(key, '', dict);
					case 2:
						var key = flagParts[0];
						var value = flagParts[1];
						return $gren_lang$core$Dict$set$(key, value, dict);
					default:
						return dict;
				}
			}), $gren_lang$core$Dict$empty, flags);
};
var $gren_lang$core$Array$partition$ = function(fn, array) {
	return A3($gren_lang$core$Array$foldl, F2(function(val, _v0) {
				var trues = _v0.trues;
				var falses = _v0.falses;
				return fn(val) ? { falses: falses, trues: $gren_lang$core$Array$pushLast$(val, trues) } : { falses: $gren_lang$core$Array$pushLast$(val, falses), trues: trues };
			}), { falses: [  ], trues: [  ] }, array);
};
var $gren_lang$core$Array$partition = F2($gren_lang$core$Array$partition$);
var $gren_lang$compiler_node$CLI$Parser$run$ = function(tokens, appDef) {
	var _v0 = appDef.commands;
	var parse = _v0.a.parseFn;
	var _v1 = $gren_lang$core$Array$partition$(function(word) {
			return A2($gren_lang$core$String$startsWith, '--', word);
		}, tokens);
	var flags = _v1.trues;
	var _arguments = _v1.falses;
	if ((flags.length === 1) && (flags[0] === '--version')) {
		return $gren_lang$compiler_node$CLI$Parser$HelpText($gren_lang$compiler_node$CLI$PrettyPrinter$text(appDef.version));
	} else {
		var _v3 = $gren_lang$core$Array$popFirst(_arguments);
		if (_v3.$ === 'Just') {
			var _v4 = _v3.a;
			var command = _v4.first;
			var args = _v4.rest;
			return A4(parse, appDef.name, command, args, $gren_lang$compiler_node$CLI$Parser$buildFlagDict(flags));
		} else {
			return $gren_lang$compiler_node$CLI$Parser$HelpText($gren_lang$compiler_node$CLI$Parser$appHelpText(appDef));
		}
	}
};
var $gren_lang$compiler_node$CLI$Parser$run = F2($gren_lang$compiler_node$CLI$Parser$run$);
var $gren_lang$compiler_node$Compiler$PackageName$browser = $gren_lang$compiler_node$Compiler$PackageName$PackageName({ author: 'gren-lang', name: 'browser' });
var $gren_lang$compiler_node$Compiler$PackageName$core = $gren_lang$compiler_node$Compiler$PackageName$PackageName({ author: 'gren-lang', name: 'core' });
var $gren_lang$compiler_node$Compiler$PackageName$node = $gren_lang$compiler_node$Compiler$PackageName$PackageName({ author: 'gren-lang', name: 'node' });
var $author$project$Terminal$Init$dependenciesForPlatform = function(platform) {
	switch (platform.$) {
		case 'Common':
			return [ $gren_lang$compiler_node$Compiler$PackageName$core ];
		case 'Browser':
			return [ $gren_lang$compiler_node$Compiler$PackageName$core, $gren_lang$compiler_node$Compiler$PackageName$browser ];
		default:
			return [ $gren_lang$compiler_node$Compiler$PackageName$core, $gren_lang$compiler_node$Compiler$PackageName$node ];
	}
};
var $gren_lang$compiler_node$Compiler$License$bsd3 = $gren_lang$compiler_node$Compiler$License$License('BSD-3-Clause');
var $gren_lang$compiler_node$SemanticVersionRange$compatibleWith = function(ver) {
	return (ver.major < 1) ? $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: { major: ver.major, minor: ver.minor, patch: 0 }, upper: { major: ver.major, minor: ver.minor + 1, patch: 0 } }) : $gren_lang$compiler_node$SemanticVersionRange$SemanticVersionRange({ lower: { major: ver.major, minor: ver.minor, patch: 0 }, upper: { major: ver.major + 1, minor: 0, patch: 0 } });
};
var $author$project$Terminal$Init$generateGrenJson$ = function(config, deps) {
	var outline = config._package ? $gren_lang$compiler_node$Compiler$Outline$Pkg({ dependencies: A3($gren_lang$core$Array$foldl, F2(function(_v4, dict) {
					var name = _v4.name;
					var version = _v4.version;
					return $gren_lang$core$Dict$set$($gren_lang$compiler_node$Compiler$PackageName$toString(name), $gren_lang$compiler_node$Compiler$Outline$Version($gren_lang$compiler_node$SemanticVersionRange$compatibleWith(version)), dict);
				}), $gren_lang$core$Dict$empty, deps), exposedModules: $gren_lang$compiler_node$Compiler$Outline$ExposedArray([  ]), grenVersion: $gren_lang$compiler_node$SemanticVersionRange$compatibleWith($author$project$Meta$version), license: $gren_lang$compiler_node$Compiler$License$bsd3, name: $gren_lang$compiler_node$Compiler$PackageName$example, platform: config.platform, summary: '', version: { major: 1, minor: 0, patch: 0 } }) : $gren_lang$compiler_node$Compiler$Outline$App({ dependencies: { direct: A3($gren_lang$core$Array$foldl, F2(function(_v5, dict) {
					var name = _v5.name;
					var version = _v5.version;
					return $gren_lang$core$Dict$set$($gren_lang$compiler_node$Compiler$PackageName$toString(name), $gren_lang$compiler_node$Compiler$Outline$Version(version), dict);
				}), $gren_lang$core$Dict$empty, deps), indirect: $gren_lang$core$Dict$empty }, grenVersion: $author$project$Meta$version, platform: config.platform, sourceDirectories: [ $gren_lang$node$FileSystem$Path$fromPosixString('src') ] });
	return A2($gren_lang$core$Task$andThen, function(resolution) {
			var newOutline = function () {
				if (outline.$ === 'App') {
					var appOutline = outline.a;
					var originalDependencyNames = $gren_lang$core$Dict$keys(appOutline.dependencies.direct);
					var indirectDeps = $gren_lang$core$Dict$map$(F2(function(_v3, _package) {
								return $gren_lang$compiler_node$Compiler$Outline$Version(_package.outline.version);
							}), $gren_lang$core$Dict$keepIf$(F2(function(name, _v2) {
									return !$gren_lang$core$Array$member$(name, originalDependencyNames);
								}), resolution.dependencies));
					return $gren_lang$compiler_node$Compiler$Outline$App(_Utils_update(appOutline, { dependencies: _Utils_update(appOutline.dependencies, { indirect: indirectDeps }) }));
				} else {
					return outline;
				}
			}();
			var encodedOutline = A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$compiler_node$Compiler$Outline$toJson(newOutline));
			return $gren_lang$core$Task$map$(function(_v0) {
					return {  };
				}, $gren_lang$core$Task$mapError$(function(fsErr) {
						return $gren_lang$core$Debug$toString(fsErr);
					}, $gren_lang$node$FileSystem$writeFile$(config.fsPermission, $gren_lang$core$Bytes$fromString(encodedOutline), $gren_lang$node$FileSystem$Path$fromPosixString('gren.json'))));
		}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: config.interactive, stdin: config.stdin, stdout: config.stdout, useColor: config.useColor }, { outline: outline, projectPath: $gren_lang$node$FileSystem$Path$empty })));
};
var $author$project$Terminal$Init$generateGrenJson = F2($author$project$Terminal$Init$generateGrenJson$);
var $author$project$Terminal$Init$init = function(config) {
	var deps = $author$project$Terminal$Init$dependenciesForPlatform(config.platform);
	return A2($gren_lang$core$Task$onError, function(err) {
			return $gren_lang$core$Stream$Log$line$(config.stdout, err);
		}, A2($gren_lang$core$Task$andThen, $author$project$Terminal$Init$generateGrenJson(config), $gren_lang$core$Task$concurrent(A2($gren_lang$core$Array$map, function(packageName) {
						return A2($gren_lang$core$Task$andThen, function(maybeVsn) {
								if (maybeVsn.$ === 'Just') {
									var vsn = maybeVsn.a;
									return $gren_lang$core$Task$succeed({ name: packageName, version: vsn });
								} else {
									return $gren_lang$core$Task$fail('No version found for ' + $gren_lang$compiler_node$Compiler$PackageName$toString(packageName));
								}
							}, A2($gren_lang$core$Task$onError, function(_v0) {
									return $gren_lang$core$Task$fail('Something went wrong when retrieving version for ' + $gren_lang$compiler_node$Compiler$PackageName$toString(packageName));
								}, $author$project$Git$fetchLatestVersion$(config.cpPermission, packageName)));
					}, deps))));
};
var $author$project$Terminal$Init$run = function(config) {
	return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(_v2) {
				return $gren_lang$core$Stream$Log$line$(config.stdout, 'Error happened!');
			}, A2($gren_lang$core$Task$onError, function(_v1) {
					return A2($gren_lang$core$Task$andThen, function(confirmed) {
							return confirmed ? $author$project$Terminal$Init$init(config) : $gren_lang$core$Stream$Log$line$(config.stdout, 'Ok, I won\'t do anything.');
						}, $author$project$Terminal$User$confirm({ defaultValue: true, question: 'Hello! Gren projects always start with a <GREEN>gren.json</> file.\nI can create one for you.\n\nWould you like me to create a gren.json file now?', stdin: config.stdin, stdout: config.stdout }));
				}, A2($gren_lang$core$Task$andThen, function(_v0) {
						return $gren_lang$core$Stream$Log$line$(config.stdout, 'File exists!');
					}, $gren_lang$node$FileSystem$checkAccess$(config.fsPermission, [  ], $gren_lang$node$FileSystem$Path$fromPosixString('gren.json'))))));
};
var $gren_lang$core$Array$isEmpty = function(array) {
	return $gren_lang$core$Array$length(array) === 0;
};
var $author$project$Terminal$PackageBump$run$ = function(config, _v0) {
	var projectPath = _v0.projectPath;
	var outline = _v0.outline;
	if (outline.$ === 'App') {
		return $gren_lang$core$Task$fail('Can only use bump on packages');
	} else {
		var pkgOutline = outline.a;
		return $gren_lang$core$Task$map$(function(_v8) {
				var currentPackage = _v8.currentPackage;
				var publishedPackage = _v8.publishedPackage;
				var knownVersions = _v8.knownVersions;
				return { currentVersion: { dependencies: currentPackage.dependencies, outline: currentPackage.outline, rootSources: currentPackage.rootSources }, knownVersions: knownVersions, projectPath: projectPath, publishedVersion: { dependencies: publishedPackage.dependencies, outline: publishedPackage.outline, rootSources: publishedPackage.rootSources } };
			}, A2($gren_lang$core$Task$andThen, function(_v2) {
					var packageName = _v2.packageName;
					var packageVersion = _v2.packageVersion;
					var knownVersions = _v2.knownVersions;
					var currentPackage = _v2.currentPackage;
					var repoPath = $author$project$Terminal$PackageInstall$localRepoPath$(packageName, packageVersion, projectPath);
					return A2($gren_lang$core$Task$andThen, function(publishedOutline) {
							return $gren_lang$core$Task$map$(function(resolved) {
									return { currentPackage: currentPackage, knownVersions: knownVersions, publishedPackage: resolved };
								}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: config.interactive, stdin: config.stdin, stdout: config.stdout, useColor: config.useColor }, { outline: publishedOutline, projectPath: repoPath })));
						}, A2($gren_lang$core$Task$andThen, function(_v6) {
								return A2($gren_lang$core$Task$andThen, function(result) {
										if (result.$ === 'Ok') {
											var decodedOutline = result.a;
											return $gren_lang$core$Task$succeed(decodedOutline);
										} else {
											var err = result.a;
											return $gren_lang$core$Task$fail($gren_lang$core$Debug$toString(err));
										}
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readOutline$(config.fsPermission, $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), repoPath))));
							}, $gren_lang$core$Task$mapError$(function(_v5) {
									var stderr = _v5.stderr;
									return $gren_lang$core$Maybe$withDefault$('', $gren_lang$core$Bytes$toString(stderr));
								}, A2($gren_lang$core$Task$andThen, function(_v4) {
										return $author$project$Git$clonePackage$(config.cpPermission, repoPath, packageName, packageVersion);
									}, A2($gren_lang$core$Task$onError, function(_v3) {
											return $gren_lang$core$Task$succeed(repoPath);
										}, $gren_lang$node$FileSystem$remove$(config.fsPermission, { recursive: true }, repoPath))))));
				}, A2($gren_lang$core$Task$andThen, function(knownVersions) {
						return $gren_lang$core$Array$isEmpty(knownVersions) ? $gren_lang$core$Task$fail('No published versions found, you probably want 1.0.0') : ((!$gren_lang$core$Array$member$(pkgOutline.version, knownVersions)) ? $gren_lang$core$Task$fail('The version you\'re bumping from doesn\'t exist!') : $gren_lang$core$Task$map$(function(resolved) {
								return { currentPackage: resolved, knownVersions: knownVersions, packageName: pkgOutline.name, packageVersion: pkgOutline.version };
							}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: config.interactive, stdin: config.stdin, stdout: config.stdout, useColor: config.useColor }, { outline: outline, projectPath: projectPath }))));
					}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Git$fetchVersions$(config.cpPermission, pkgOutline.name)))));
	}
};
var $author$project$Terminal$PackageBump$run = F2($author$project$Terminal$PackageBump$run$);
var $author$project$Terminal$PackageOutdated$PackageInstallDebug = function (a) {
	return { $: 'PackageInstallDebug', a: a };
};
var $author$project$Terminal$PackageOutdated$run$ = function(config, _v0) {
	var projectPath = _v0.projectPath;
	var outline = _v0.outline;
	var grenJsonPath = $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), projectPath);
	var extractVersion = function(cons) {
		if (cons.$ === 'Version') {
			var v = cons.a;
			return $gren_lang$core$Maybe$Just(v);
		} else {
			return $gren_lang$core$Maybe$Nothing;
		}
	};
	var deps = function () {
		if (outline.$ === 'App') {
			var appOutline = outline.a;
			return $gren_lang$core$Dict$map$(F2(function(_v6, v) {
						return $gren_lang$compiler_node$SemanticVersionRange$fromExact(v);
					}), $gren_lang$core$Dict$mapAndKeepJust$(F2(function(_v5, v) {
							return extractVersion(v);
						}), $gren_lang$core$Dict$union$(appOutline.dependencies.direct, appOutline.dependencies.indirect)));
		} else {
			var pkgOutline = outline.a;
			return $gren_lang$core$Dict$mapAndKeepJust$(F2(function(_v7, v) {
						return extractVersion(v);
					}), pkgOutline.dependencies);
		}
	}();
	return A2($gren_lang$core$Task$andThen, function(vs) {
			if (_Utils_eq(vs, [  ])) {
				return $gren_lang$core$Stream$Log$line$(config.stdout, 'All dependencies are up to date.');
			} else {
				var plan = 'The plan is to update the following dependencies:\n\n' + (A3($gren_lang$core$Array$foldl, F2(function(_package, acc) {
							return acc + ('  ' + ($gren_lang$compiler_node$Compiler$PackageName$toString(_package.name) + (' ' + ($gren_lang$compiler_node$SemanticVersion$toString(_package.version) + '\n'))));
						}), '', vs) + '\nDo you want me to update the gren.json file accordingly? [Y/n]: ');
				return $gren_lang$core$Stream$Log$line$(config.stdout, plan);
			}
		}, $gren_lang$core$Task$map$(function(vs) {
				return $gren_lang$core$Array$mapAndKeepJust$(function(p) {
						var _v3 = $gren_lang$core$Array$last(p.versions);
						if (_v3.$ === 'Just') {
							var v = _v3.a;
							return $gren_lang$core$Maybe$Just({ name: p.name, version: v });
						} else {
							return $gren_lang$core$Maybe$Nothing;
						}
					}, vs);
			}, $gren_lang$core$Task$mapError$(function(_v2) {
					return $author$project$Terminal$PackageOutdated$PackageInstallDebug('failed to get versions');
				}, $gren_lang$core$Task$concurrent($gren_lang$core$Dict$foldl$(F3(function(packageStr, versionRange, tasks) {
								var _v1 = $gren_lang$compiler_node$Compiler$PackageName$fromString(packageStr);
								if (_v1.$ === 'Nothing') {
									return tasks;
								} else {
									var packageName = _v1.a;
									var task = $gren_lang$core$Task$map$(function(vs) {
											return { name: packageName, versions: vs };
										}, $gren_lang$core$Task$map$(function(vs) {
												return A2($gren_lang$core$Array$keepIf, function(v) {
														return _Utils_eq($gren_lang$compiler_node$SemanticVersion$compare$(v, $gren_lang$compiler_node$SemanticVersionRange$lowerBound(versionRange)), $gren_lang$core$Basics$GT);
													}, vs);
											}, $author$project$Git$fetchVersions$(config.cpPermission, packageName)));
									return $gren_lang$core$Array$pushLast$(task, tasks);
								}
							}), [  ], deps)))));
};
var $author$project$Terminal$PackageOutdated$run = F2($author$project$Terminal$PackageOutdated$run$);
var $author$project$Terminal$PackageUninstall$PackageInstallDebug = function (a) {
	return { $: 'PackageInstallDebug', a: a };
};
var $author$project$Terminal$PackageUninstall$run$ = function(config, _v0, requestedPackage) {
	var projectPath = _v0.projectPath;
	var outline = _v0.outline;
	var packageNameStr = $gren_lang$compiler_node$Compiler$PackageName$toString(requestedPackage);
	var grenJsonPath = $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), projectPath);
	if (outline.$ === 'App') {
		var appOutline = outline.a;
		var _v2 = { direct: $gren_lang$core$Dict$member$(packageNameStr, appOutline.dependencies.direct), transitive: $gren_lang$core$Dict$get$(packageNameStr, appOutline.dependencies.indirect) };
		if (!_v2.direct) {
			if (_v2.transitive.$ === 'Nothing') {
				var _v3 = _v2.transitive;
				return $gren_lang$core$Task$fail($author$project$Terminal$PackageUninstall$PackageInstallDebug('Package not installed'));
			} else {
				var packageVersion = _v2.transitive.a;
				return $gren_lang$core$Stream$Log$line$(config.stdout, 'Removing ' + packageNameStr);
			}
		} else {
			return A2($gren_lang$core$Task$andThen, function(resolved) {
					var originalPackages = $gren_lang$core$Dict$union$(appOutline.dependencies.direct, appOutline.dependencies.indirect);
					var newPackages = $gren_lang$core$Dict$keys(resolved.dependencies);
					var removedPackages = $gren_lang$core$Dict$keys($gren_lang$core$Dict$keepIf$(F2(function(k, _v9) {
									return !$gren_lang$core$Array$member$(k, newPackages);
								}), originalPackages));
					var plan = 'The plan is to remove the following dependencies:\n\n' + (A3($gren_lang$core$Array$foldl, F2(function(_package, acc) {
								return acc + ('  ' + (_package + '\n'));
							}), '', removedPackages) + '\nDo you want me to update the gren.json file accordingly? [Y/n]: ');
					var finalOutline = $gren_lang$compiler_node$Compiler$Outline$App(_Utils_update(appOutline, { dependencies: _Utils_update(appOutline.dependencies, { direct: $gren_lang$core$Dict$keepIf$(F2(function(k, _v7) {
											return $gren_lang$core$Array$member$(k, newPackages);
										}), appOutline.dependencies.direct), indirect: $gren_lang$core$Dict$keepIf$(F2(function(k, _v8) {
											return $gren_lang$core$Array$member$(k, newPackages);
										}), appOutline.dependencies.indirect) }) }));
					return A2($gren_lang$core$Task$andThen, function(_v6) {
							return $gren_lang$core$Stream$Log$line$(config.stdout, 'Done');
						}, A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Stream$Log$line$(config.stdout, 'Error: ' + err);
							}, A2($gren_lang$core$Task$andThen, function(newOutline) {
									return $gren_lang$core$Task$map$(function(_v5) {
											return {  };
										}, $gren_lang$core$Task$mapError$(function(fsErr) {
												return $gren_lang$core$Debug$toString(fsErr);
											}, $gren_lang$node$FileSystem$writeFile$(config.fsPermission, $gren_lang$core$Bytes$fromString(newOutline), grenJsonPath)));
								}, A2($gren_lang$core$Task$andThen, function(confirmed) {
										return confirmed ? $gren_lang$core$Task$succeed(A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$compiler_node$Compiler$Outline$toJson(finalOutline))) : $gren_lang$core$Task$fail('');
									}, $gren_lang$core$Task$mapError$(function(_v4) {
											return 'Stream error';
										}, $author$project$Terminal$User$confirm({ defaultValue: true, question: plan, stdin: config.stdin, stdout: config.stdout }))))));
				}, A2($gren_lang$core$Task$andThen, function(packageVersion) {
						return $gren_lang$core$Task$mapError$(function(err) {
								return $author$project$Terminal$PackageUninstall$PackageInstallDebug($gren_lang$core$Debug$toString(err));
							}, $author$project$Terminal$PackageInstall$run$(config, { outline: $gren_lang$compiler_node$Compiler$Outline$App(_Utils_update(appOutline, { dependencies: _Utils_update(appOutline.dependencies, { direct: $gren_lang$core$Dict$remove$(packageNameStr, appOutline.dependencies.direct) }) })), projectPath: projectPath }));
					}, $gren_lang$core$Stream$Log$line$(config.stdout, 'Removing ' + packageNameStr)));
		}
	} else {
		var pkgOutline = outline.a;
		return $gren_lang$core$Dict$member$(packageNameStr, pkgOutline.dependencies) ? $gren_lang$core$Stream$Log$line$(config.stdout, 'Removing ' + packageNameStr) : $gren_lang$core$Task$fail($author$project$Terminal$PackageUninstall$PackageInstallDebug('Package not installed'));
	}
};
var $author$project$Terminal$PackageUninstall$run = F3($author$project$Terminal$PackageUninstall$run$);
var $gren_lang$compiler_node$Compiler$Outline$defaultSummary = 'helpful summary of your project, less than 80 characters';
var $author$project$Terminal$PackageValidate$badSummary = function(summary) {
	return $gren_lang$core$String$isEmpty(summary) || _Utils_eq($gren_lang$compiler_node$Compiler$Outline$defaultSummary, summary);
};
var $gren_lang$core$Dict$findFirst$ = function(fn, dict) {
	findFirst:
	while (true) {
		if (dict.$ === 'RBEmpty_gren_builtin') {
			return $gren_lang$core$Maybe$Nothing;
		} else {
			var _v1 = dict.a;
			var key = _v1.key;
			var value = _v1.value;
			var left = _v1.left;
			var right = _v1.right;
			var _v2 = $gren_lang$core$Dict$findFirst$(fn, left);
			if (_v2.$ === 'Nothing') {
				if (A2(fn, key, value)) {
					return $gren_lang$core$Maybe$Just({ key: key, value: value });
				} else {
					var $temp$fn = fn,
					$temp$dict = right;
					fn = $temp$fn;
					dict = $temp$dict;
					continue findFirst;
				}
			} else {
				var foundValue = _v2;
				return foundValue;
			}
		}
	}
};
var $gren_lang$core$Dict$findFirst = F2($gren_lang$core$Dict$findFirst$);
var $gren_lang$core$Dict$any$ = function(fn, dict) {
	var _v0 = $gren_lang$core$Dict$findFirst$(fn, dict);
	if (_v0.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $gren_lang$core$Dict$any = F2($gren_lang$core$Dict$any$);
var $author$project$Terminal$PackageValidate$hasLocalDeps = function(dependencies) {
	return $gren_lang$core$Dict$any$(F2(function(_v0, cons) {
				if (cons.$ === 'LocalPath') {
					return true;
				} else {
					return false;
				}
			}), dependencies);
};
var $author$project$Git$hasLocalTag$ = function(permission, vsn) {
	return $gren_lang$core$Task$map$(function(_v0) {
			return {  };
		}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $gren_lang$node$ChildProcess$run$(permission, 'git', [ 'show', '--name-only', $gren_lang$compiler_node$SemanticVersion$toString(vsn) ], { environmentVariables: $gren_lang$node$ChildProcess$InheritEnvironmentVariables, maximumBytesWrittenToStreams: 4096, runDuration: $gren_lang$node$ChildProcess$Milliseconds(5000), shell: $gren_lang$node$ChildProcess$NoShell, workingDirectory: $gren_lang$node$ChildProcess$InheritWorkingDirectory })));
};
var $author$project$Git$hasLocalTag = F2($author$project$Git$hasLocalTag$);
var $author$project$Git$hasNoLocalChangesSinceTag$ = function(permission, vsn) {
	return $gren_lang$core$Task$map$(function(_v0) {
			return {  };
		}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $gren_lang$node$ChildProcess$run$(permission, 'git', [ 'diff-index', '--quiet', $gren_lang$compiler_node$SemanticVersion$toString(vsn) ], { environmentVariables: $gren_lang$node$ChildProcess$InheritEnvironmentVariables, maximumBytesWrittenToStreams: 4096, runDuration: $gren_lang$node$ChildProcess$Milliseconds(5000), shell: $gren_lang$node$ChildProcess$NoShell, workingDirectory: $gren_lang$node$ChildProcess$InheritWorkingDirectory })));
};
var $author$project$Git$hasNoLocalChangesSinceTag = F2($author$project$Git$hasNoLocalChangesSinceTag$);
var $gren_lang$core$Dict$all$ = function(fn, dict) {
	var _v0 = $gren_lang$core$Dict$findFirst$(F2(function(key, value) {
				return !A2(fn, key, value);
			}), dict);
	if (_v0.$ === 'Just') {
		return false;
	} else {
		return true;
	}
};
var $gren_lang$core$Dict$all = F2($gren_lang$core$Dict$all$);
var $author$project$Terminal$PackageValidate$noExposed = function(exposed) {
	if (exposed.$ === 'ExposedArray') {
		var modules = exposed.a;
		return $gren_lang$core$Array$isEmpty(modules);
	} else {
		var chunks = exposed.a;
		return $gren_lang$core$Dict$all$(F2(function(_v1, modules) {
					return $gren_lang$core$Array$isEmpty(modules);
				}), chunks);
	}
};
var $gren_lang$node$FileSystem$Path$appendPosixString$ = function(str, path) {
	return $gren_lang$node$FileSystem$Path$prepend$(path, $gren_lang$node$FileSystem$Path$fromPosixString(str));
};
var $gren_lang$node$FileSystem$Path$appendPosixString = F2($gren_lang$node$FileSystem$Path$appendPosixString$);
var $author$project$Terminal$PackageValidate$verifyLicense$ = function(permission, projectPath) {
	return $gren_lang$core$Task$map$(function(_v1) {
			return {  };
		}, $gren_lang$core$Task$mapError$(function(_v0) {
				return 'Couldn\'t read LICENSE';
			}, $gren_lang$node$FileSystem$checkAccess$(permission, [  ], $gren_lang$node$FileSystem$Path$appendPosixString$('LICENSE', projectPath))));
};
var $author$project$Terminal$PackageValidate$verifyLicense = F2($author$project$Terminal$PackageValidate$verifyLicense$);
var $gren_lang$core$Bytes$length = _Bytes_length;
var $author$project$Terminal$PackageValidate$verifyReadme$ = function(permission, projectPath) {
	var readmePath = $gren_lang$node$FileSystem$Path$appendPosixString$('README', projectPath);
	return A2($gren_lang$core$Task$andThen, function(content) {
			return ($gren_lang$core$Bytes$length(content) < 300) ? $gren_lang$core$Task$fail('Short readme') : $gren_lang$core$Task$succeed({  });
		}, $gren_lang$core$Task$mapError$(function(_v0) {
				return 'Couldn\'t read README';
			}, $gren_lang$node$FileSystem$readFile$(permission, readmePath)));
};
var $author$project$Terminal$PackageValidate$verifyReadme = F2($author$project$Terminal$PackageValidate$verifyReadme$);
var $author$project$Terminal$PackageValidate$verifyVersion$ = function(vsn, publishedVersions) {
	return $gren_lang$core$Array$isEmpty(publishedVersions) ? (((vsn.major === 1) && ((vsn.minor === 0) && (vsn.patch === 0))) ? $gren_lang$core$Task$succeed({  }) : $gren_lang$core$Task$fail('No published version and version isn\'t 1.0.0')) : $gren_lang$core$Task$succeed({  });
};
var $author$project$Terminal$PackageValidate$verifyVersion = F2($author$project$Terminal$PackageValidate$verifyVersion$);
var $author$project$Terminal$PackageValidate$run$ = function(config, _v0) {
	var projectPath = _v0.projectPath;
	var outline = _v0.outline;
	if (outline.$ === 'App') {
		return $gren_lang$core$Task$fail('Can only use validate on packages');
	} else {
		var pkgOutline = outline.a;
		return $author$project$Terminal$PackageValidate$noExposed(pkgOutline.exposedModules) ? $gren_lang$core$Task$fail('No exposed modules') : ($author$project$Terminal$PackageValidate$badSummary(pkgOutline.summary) ? $gren_lang$core$Task$fail('Bad summary') : ($author$project$Terminal$PackageValidate$hasLocalDeps(pkgOutline.dependencies) ? $gren_lang$core$Task$fail('Has local dependencies') : $gren_lang$core$Task$await$($gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Git$fetchVersions$(config.cpPermission, pkgOutline.name)), function(knownVersions) {
				return $gren_lang$core$Task$await$($author$project$Terminal$PackageValidate$verifyVersion$(pkgOutline.version, knownVersions), function(_v2) {
						return $gren_lang$core$Task$await$($author$project$Terminal$PackageValidate$verifyReadme$(config.fsPermission, projectPath), function(_v3) {
								return $gren_lang$core$Task$await$($author$project$Terminal$PackageValidate$verifyLicense$(config.fsPermission, projectPath), function(_v4) {
										return $gren_lang$core$Task$await$($gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Git$hasLocalTag$(config.cpPermission, pkgOutline.version)), function(_v5) {
												return $gren_lang$core$Task$await$($gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Git$hasNoLocalChangesSinceTag$(config.cpPermission, pkgOutline.version)), function(_v6) {
														return A2($gren_lang$core$Task$andThen, function(currentPackage) {
																var maybePreviousPackageVersion = $gren_lang$core$Array$last(A2($gren_lang$core$Array$sortWith, $gren_lang$compiler_node$SemanticVersion$compare, A2($gren_lang$core$Array$keepIf, function(v) {
																				return _Utils_eq($gren_lang$compiler_node$SemanticVersion$compare$(v, pkgOutline.version), $gren_lang$core$Basics$LT);
																			}, knownVersions)));
																if (maybePreviousPackageVersion.$ === 'Nothing') {
																	return $gren_lang$core$Task$succeed({ currentVersion: { dependencies: currentPackage.dependencies, outline: currentPackage.outline, rootSources: currentPackage.rootSources }, knownVersions: knownVersions, previousVersion: $gren_lang$core$Maybe$Nothing, projectPath: projectPath });
																} else {
																	var packageVersion = maybePreviousPackageVersion.a;
																	var repoPath = $author$project$Terminal$PackageInstall$localRepoPath$(pkgOutline.name, packageVersion, projectPath);
																	return $gren_lang$core$Task$map$(function(previousPackage) {
																			return { currentVersion: { dependencies: currentPackage.dependencies, outline: currentPackage.outline, rootSources: currentPackage.rootSources }, knownVersions: knownVersions, previousVersion: $gren_lang$core$Maybe$Just({ dependencies: previousPackage.dependencies, outline: previousPackage.outline, rootSources: previousPackage.rootSources }), projectPath: projectPath };
																		}, A2($gren_lang$core$Task$andThen, function(previousOutline) {
																				return $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: config.interactive, stdin: config.stdin, stdout: config.stdout, useColor: config.useColor }, { outline: previousOutline, projectPath: repoPath }));
																			}, A2($gren_lang$core$Task$andThen, function(_v11) {
																					return A2($gren_lang$core$Task$andThen, function(result) {
																							if (result.$ === 'Ok') {
																								var decodedOutline = result.a;
																								return $gren_lang$core$Task$succeed(decodedOutline);
																							} else {
																								var err = result.a;
																								return $gren_lang$core$Task$fail($gren_lang$core$Debug$toString(err));
																							}
																						}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readOutline$(config.fsPermission, $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), repoPath))));
																				}, $gren_lang$core$Task$mapError$(function(_v10) {
																						var stderr = _v10.stderr;
																						return $gren_lang$core$Maybe$withDefault$('', $gren_lang$core$Bytes$toString(stderr));
																					}, A2($gren_lang$core$Task$andThen, function(_v9) {
																							return $author$project$Git$clonePackage$(config.cpPermission, repoPath, pkgOutline.name, packageVersion);
																						}, A2($gren_lang$core$Task$onError, function(_v8) {
																								return $gren_lang$core$Task$succeed(repoPath);
																							}, $gren_lang$node$FileSystem$remove$(config.fsPermission, { recursive: true }, repoPath)))))));
																}
															}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: config.interactive, stdin: config.stdin, stdout: config.stdout, useColor: config.useColor }, { outline: outline, projectPath: projectPath })));
													});
											});
									});
							});
					});
			})));
	}
};
var $author$project$Terminal$PackageValidate$run = F2($author$project$Terminal$PackageValidate$run$);
var $author$project$Terminal$Paths$run$ = function(config, opts) {
	_v0$8:
	while (true) {
		if (opts.project) {
			if ((!opts.packageCache) && (!opts.backend)) {
				if (!opts.json) {
					return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(_v3) {
								return $gren_lang$core$Stream$Log$line$(config.stdout, 'Couldn\'t find project!');
							}, A2($gren_lang$core$Task$andThen, function(project) {
									return $gren_lang$core$Stream$Log$line$(config.stdout, config.pathToString(project));
								}, $gren_lang$compiler_node$Compiler$Paths$projectRoot(config.fsPermission))));
				} else {
					return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(_v4) {
								return $gren_lang$core$Stream$Log$line$(config.stdout, 'Couldn\'t find project!');
							}, A2($gren_lang$core$Task$andThen, function(project) {
									return $gren_lang$core$Stream$Log$line$(config.stdout, A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$core$Json$Encode$object([ { key: 'project', value: $gren_lang$core$Json$Encode$string(config.pathToString(project)) } ])));
								}, $gren_lang$compiler_node$Compiler$Paths$projectRoot(config.fsPermission))));
				}
			} else {
				break _v0$8;
			}
		} else {
			if (opts.packageCache) {
				if (!opts.backend) {
					if (!opts.json) {
						return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(_v5) {
									return $gren_lang$core$Stream$Log$line$(config.stdout, 'Couldn\'t find project!');
								}, A2($gren_lang$core$Task$andThen, function(project) {
										return $gren_lang$core$Stream$Log$line$(config.stdout, config.pathToString($gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren_packages'), project)));
									}, $gren_lang$compiler_node$Compiler$Paths$projectRoot(config.fsPermission))));
					} else {
						return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(_v6) {
									return $gren_lang$core$Stream$Log$line$(config.stdout, 'Couldn\'t find project!');
								}, A2($gren_lang$core$Task$andThen, function(project) {
										return $gren_lang$core$Stream$Log$line$(config.stdout, A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$core$Json$Encode$object([ { key: 'packageCache', value: $gren_lang$core$Json$Encode$string(config.pathToString($gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren_packages'), project))) } ])));
									}, $gren_lang$compiler_node$Compiler$Paths$projectRoot(config.fsPermission))));
					}
				} else {
					break _v0$8;
				}
			} else {
				if (!opts.backend) {
					if (!opts.json) {
						return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(_v1) {
									return $gren_lang$core$Stream$Log$line$(config.stdout, 'Couldn\'t find project!');
								}, A2($gren_lang$core$Task$andThen, function(project) {
										return $gren_lang$core$Stream$Log$line$(config.stdout, A2($gren_lang$core$String$join, '\n', [ 'project: ' + config.pathToString(project), 'package-cache: ' + config.pathToString($gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren_packages'), project)), 'backend: ' + config.pathToString(config.backendPath) ]));
									}, $gren_lang$compiler_node$Compiler$Paths$projectRoot(config.fsPermission))));
					} else {
						return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(_v2) {
									return $gren_lang$core$Stream$Log$line$(config.stdout, 'Couldn\'t find project!');
								}, A2($gren_lang$core$Task$andThen, function(project) {
										return $gren_lang$core$Stream$Log$line$(config.stdout, A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$core$Json$Encode$object([ { key: 'project', value: $gren_lang$core$Json$Encode$string(config.pathToString(project)) }, { key: 'packageCache', value: $gren_lang$core$Json$Encode$string(config.pathToString($gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren_packages'), project))) }, { key: 'backend', value: $gren_lang$core$Json$Encode$string(config.pathToString(config.backendPath)) } ])));
									}, $gren_lang$compiler_node$Compiler$Paths$projectRoot(config.fsPermission))));
					}
				} else {
					if (!opts.json) {
						return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(config.stdout, config.pathToString(config.backendPath)));
					} else {
						return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(config.stdout, A2($gren_lang$core$Json$Encode$encode, 4, $gren_lang$core$Json$Encode$object([ { key: 'backend', value: $gren_lang$core$Json$Encode$string(config.pathToString(config.backendPath)) } ]))));
					}
				}
			}
		}
	}
	return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(config.stdout, 'You can only use one of --project, --package-cache and --backend!'));
};
var $author$project$Terminal$Paths$run = F2($author$project$Terminal$Paths$run$);
var $author$project$Terminal$PackageDiff$installHiddenProject$ = function(config, projectPath, packageName, packageVersion) {
	var repoPath = $author$project$Terminal$PackageInstall$localRepoPath$(packageName, packageVersion, projectPath);
	return A2($gren_lang$core$Task$andThen, function(publishedOutline) {
			return $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: config.interactive, stdin: config.stdin, stdout: config.stdout, useColor: config.useColor }, { outline: publishedOutline, projectPath: repoPath }));
		}, A2($gren_lang$core$Task$andThen, function(_v3) {
				return A2($gren_lang$core$Task$andThen, function(result) {
						if (result.$ === 'Ok') {
							var decodedOutline = result.a;
							return $gren_lang$core$Task$succeed(decodedOutline);
						} else {
							var err = result.a;
							return $gren_lang$core$Task$fail($gren_lang$core$Debug$toString(err));
						}
					}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readOutline$(config.fsPermission, $gren_lang$node$FileSystem$Path$append$($gren_lang$node$FileSystem$Path$fromPosixString('gren.json'), repoPath))));
			}, $gren_lang$core$Task$mapError$(function(_v2) {
					var stderr = _v2.stderr;
					return $gren_lang$core$Maybe$withDefault$('', $gren_lang$core$Bytes$toString(stderr));
				}, A2($gren_lang$core$Task$andThen, function(_v1) {
						return $author$project$Git$clonePackage$(config.cpPermission, repoPath, packageName, packageVersion);
					}, A2($gren_lang$core$Task$onError, function(_v0) {
							return $gren_lang$core$Task$succeed(repoPath);
						}, $gren_lang$node$FileSystem$remove$(config.fsPermission, { recursive: true }, repoPath))))));
};
var $author$project$Terminal$PackageDiff$installHiddenProject = F4($author$project$Terminal$PackageDiff$installHiddenProject$);
var $gren_lang$core$Task$map2 = _Scheduler_map2;
var $author$project$Terminal$PackageDiff$runGlobal$ = function(config, packageName, lowerVersion, upperVersion) {
	return A2($gren_lang$core$Task$andThen, function(_v0) {
			var projectPath = _v0.projectPath;
			return A3($gren_lang$core$Task$map2, F2(function(firstPackage, secondPackage) {
						return { firstPackage: { dependencies: firstPackage.dependencies, outline: firstPackage.outline, rootSources: firstPackage.rootSources }, projectPath: projectPath, secondPackage: { dependencies: secondPackage.dependencies, outline: secondPackage.outline, rootSources: secondPackage.rootSources } };
					}), $author$project$Terminal$PackageDiff$installHiddenProject$(config, projectPath, packageName, lowerVersion), $author$project$Terminal$PackageDiff$installHiddenProject$(config, projectPath, packageName, upperVersion));
		}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(config.fsPermission)));
};
var $author$project$Terminal$PackageDiff$runGlobal = F4($author$project$Terminal$PackageDiff$runGlobal$);
var $author$project$Terminal$PackageDiff$runLocal$ = function(config, maybeVersion) {
	return $gren_lang$core$Task$map$(function(_v4) {
			var projectPath = _v4.projectPath;
			var currentPackage = _v4.currentPackage;
			var remotePackage = _v4.remotePackage;
			return { firstPackage: { dependencies: currentPackage.dependencies, outline: currentPackage.outline, rootSources: currentPackage.rootSources }, projectPath: projectPath, secondPackage: { dependencies: remotePackage.dependencies, outline: remotePackage.outline, rootSources: remotePackage.rootSources } };
		}, A2($gren_lang$core$Task$andThen, function(_v3) {
				var projectPath = _v3.projectPath;
				var packageName = _v3.packageName;
				var packageVersion = _v3.packageVersion;
				var currentPackage = _v3.currentPackage;
				return $gren_lang$core$Task$map$(function(resolved) {
						return { currentPackage: currentPackage, projectPath: projectPath, remotePackage: resolved };
					}, $author$project$Terminal$PackageDiff$installHiddenProject$(config, projectPath, packageName, packageVersion));
			}, A2($gren_lang$core$Task$andThen, function(_v0) {
					var projectPath = _v0.projectPath;
					var outline = _v0.outline;
					if (outline.$ === 'App') {
						return $gren_lang$core$Task$fail('Can only use bump on packages');
					} else {
						var pkgOutline = outline.a;
						var versionTask = function () {
							if (maybeVersion.$ === 'Just') {
								var v = maybeVersion.a;
								return $gren_lang$core$Task$succeed(v);
							} else {
								return A2($gren_lang$core$Task$andThen, function(knownVersions) {
										return $gren_lang$core$Array$isEmpty(knownVersions) ? $gren_lang$core$Task$fail('No published versions') : $gren_lang$core$Task$succeed($gren_lang$core$Maybe$withDefault$({ major: 1, minor: 0, patch: 0 }, $gren_lang$core$Array$last(knownVersions)));
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Git$fetchVersions$(config.cpPermission, pkgOutline.name)));
							}
						}();
						return A2($gren_lang$core$Task$andThen, function(remoteVersion) {
								return $gren_lang$core$Task$map$(function(resolved) {
										return { currentPackage: resolved, packageName: pkgOutline.name, packageVersion: remoteVersion, projectPath: projectPath };
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: config.cpPermission, fsPermission: config.fsPermission, interactive: config.interactive, stdin: config.stdin, stdout: config.stdout, useColor: config.useColor }, { outline: outline, projectPath: projectPath })));
							}, versionTask);
					}
				}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(config.fsPermission)))));
};
var $author$project$Terminal$PackageDiff$runLocal = F2($author$project$Terminal$PackageDiff$runLocal$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$stripColor = function(doc) {
	switch (doc.$) {
		case 'Empty':
			return doc;
		case 'Text':
			return doc;
		case 'Words':
			return doc;
		case 'Colorized':
			var colorizedDocument = doc.a.document;
			return colorizedDocument;
		case 'Indented':
			var document = doc.a;
			return $gren_lang$compiler_node$CLI$PrettyPrinter$Indented($gren_lang$compiler_node$CLI$PrettyPrinter$stripColor(document));
		case 'Block':
			var docs = doc.a;
			return $gren_lang$compiler_node$CLI$PrettyPrinter$Block(A2($gren_lang$core$Array$map, $gren_lang$compiler_node$CLI$PrettyPrinter$stripColor, docs));
		default:
			var docs = doc.a;
			return $gren_lang$compiler_node$CLI$PrettyPrinter$VerticalBlock(A2($gren_lang$core$Array$map, $gren_lang$compiler_node$CLI$PrettyPrinter$stripColor, docs));
	}
};
var $gren_lang$core$String$repeat = _String_repeat;
var $gren_lang$compiler_node$CLI$PrettyPrinter$addToWordSplitter$ = function(maxWidth, str, _v0) {
	addToWordSplitter:
	while (true) {
		var currentLine = _v0.currentLine;
		var lines = _v0.lines;
		if (_Utils_eq(currentLine, [  ])) {
			return { currentLine: [ str ], lines: lines };
		} else {
			var currentWidth = $gren_lang$core$String$count(A2($gren_lang$core$String$join, ' ', currentLine));
			if (_Utils_cmp($gren_lang$core$String$count(str) + currentWidth, maxWidth) > 0) {
				var $temp$maxWidth = maxWidth,
				$temp$str = str,
				$temp$_v0 = { currentLine: [  ], lines: $gren_lang$core$Array$pushLast$(currentLine, lines) };
				maxWidth = $temp$maxWidth;
				str = $temp$str;
				_v0 = $temp$_v0;
				continue addToWordSplitter;
			} else {
				return { currentLine: $gren_lang$core$Array$pushLast$(str, currentLine), lines: lines };
			}
		}
	}
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$addToWordSplitter = F3($gren_lang$compiler_node$CLI$PrettyPrinter$addToWordSplitter$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$ansiColorCode$ = function(clr, intense) {
	var baseValue = function () {
		switch (clr.$) {
			case 'Black':
				return 30;
			case 'Red':
				return 31;
			case 'Green':
				return 32;
			case 'Yellow':
				return 33;
			case 'Blue':
				return 34;
			case 'Magenta':
				return 35;
			case 'Cyan':
				return 36;
			default:
				return 37;
		}
	}();
	var appliedIntensity = intense ? (baseValue + 60) : baseValue;
	return $gren_lang$core$String$fromInt(appliedIntensity);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$ansiColorCode = F2($gren_lang$compiler_node$CLI$PrettyPrinter$ansiColorCode$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$ansiColorEscapePrefix = '\u001B[';
var $gren_lang$compiler_node$CLI$PrettyPrinter$emptyWordSplitter = { currentLine: [  ], lines: [  ] };
var $gren_lang$core$String$takeFirst$ = function(n, string) {
	return (n < 1) ? '' : A3($gren_lang$core$String$slice, 0, n, string);
};
var $gren_lang$core$String$takeFirst = F2($gren_lang$core$String$takeFirst$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$splitByLengthHelper$ = function(size, str, acc) {
	splitByLengthHelper:
	while (true) {
		if (str === '') {
			return acc;
		} else {
			var rest = $gren_lang$core$String$dropFirst$(size, str);
			var first = $gren_lang$core$String$takeFirst$(size, str);
			var $temp$size = size,
			$temp$str = rest,
			$temp$acc = $gren_lang$core$Array$pushLast$(first, acc);
			size = $temp$size;
			str = $temp$str;
			acc = $temp$acc;
			continue splitByLengthHelper;
		}
	}
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$splitByLengthHelper = F3($gren_lang$compiler_node$CLI$PrettyPrinter$splitByLengthHelper$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$splitByLength$ = function(size, str) {
	return $gren_lang$compiler_node$CLI$PrettyPrinter$splitByLengthHelper$(size, str, [  ]);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$splitByLength = F2($gren_lang$compiler_node$CLI$PrettyPrinter$splitByLength$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper$ = function(indentPrefix, nextIndent, maxColumns, newlineSeparator, doc) {
	toStringHelper:
	while (true) {
		switch (doc.$) {
			case 'Empty':
				return '';
			case 'Text':
				var str = doc.a;
				var indentedText = _Utils_ap(indentPrefix, str);
				return (_Utils_cmp($gren_lang$core$String$count(indentedText), maxColumns) > 0) ? A2($gren_lang$core$String$join, newlineSeparator, $gren_lang$compiler_node$CLI$PrettyPrinter$splitByLength$(maxColumns, indentedText)) : indentedText;
			case 'Words':
				var parts = doc.a;
				var maxColumnsAfterIndent = maxColumns - $gren_lang$core$String$count(indentPrefix);
				var wordSplitter = A3($gren_lang$core$Array$foldl, $gren_lang$compiler_node$CLI$PrettyPrinter$addToWordSplitter(maxColumnsAfterIndent), $gren_lang$compiler_node$CLI$PrettyPrinter$emptyWordSplitter, parts);
				return A2($gren_lang$core$String$join, newlineSeparator, A2($gren_lang$core$Array$map, function(line) {
							return _Utils_ap(indentPrefix, A2($gren_lang$core$String$join, ' ', line));
						}, $gren_lang$core$Array$pushLast$(wordSplitter.currentLine, wordSplitter.lines)));
			case 'Colorized':
				var _v1 = doc.a;
				var clr = _v1.color;
				var intense = _v1.intense;
				var document = _v1.document;
				return A2($gren_lang$core$String$join, '', [ $gren_lang$compiler_node$CLI$PrettyPrinter$ansiColorEscapePrefix + ($gren_lang$compiler_node$CLI$PrettyPrinter$ansiColorCode$(clr, intense) + 'm'), $gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper$(indentPrefix, nextIndent, maxColumns, newlineSeparator, document), $gren_lang$compiler_node$CLI$PrettyPrinter$ansiColorEscapePrefix + '39m' ]);
			case 'Indented':
				var document = doc.a;
				var $temp$indentPrefix = nextIndent(indentPrefix),
				$temp$nextIndent = nextIndent,
				$temp$maxColumns = maxColumns,
				$temp$newlineSeparator = newlineSeparator,
				$temp$doc = document;
				indentPrefix = $temp$indentPrefix;
				nextIndent = $temp$nextIndent;
				maxColumns = $temp$maxColumns;
				newlineSeparator = $temp$newlineSeparator;
				doc = $temp$doc;
				continue toStringHelper;
			case 'Block':
				var docs = doc.a;
				var _v2 = $gren_lang$core$Array$popFirst(docs);
				if (_v2.$ === 'Nothing') {
					return '';
				} else {
					var _v3 = _v2.a;
					var first = _v3.first;
					var rest = _v3.rest;
					return A2($gren_lang$core$String$join, '', $gren_lang$core$Array$pushFirst$($gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper$(indentPrefix, nextIndent, maxColumns, newlineSeparator, first), A2($gren_lang$core$Array$map, A4($gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper, '', $gren_lang$core$Basics$identity, maxColumns, newlineSeparator), rest)));
				}
			default:
				var docs = doc.a;
				return A2($gren_lang$core$String$join, newlineSeparator, A2($gren_lang$core$Array$map, A4($gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper, indentPrefix, nextIndent, maxColumns, newlineSeparator), docs));
		}
	}
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper = F5($gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper$);
var $gren_lang$compiler_node$CLI$PrettyPrinter$toStringWithOptions$ = function(_v0, doc) {
	var maxColumns = _v0.maxColumns;
	var indentationSize = _v0.indentationSize;
	var newlineSeparator = _v0.newlineSeparator;
	return $gren_lang$compiler_node$CLI$PrettyPrinter$toStringHelper$('', function(currentIndent) {
			return _Utils_ap(A2($gren_lang$core$String$repeat, indentationSize, ' '), currentIndent);
		}, maxColumns, newlineSeparator, doc);
};
var $gren_lang$compiler_node$CLI$PrettyPrinter$toStringWithOptions = F2($gren_lang$compiler_node$CLI$PrettyPrinter$toStringWithOptions$);
var $author$project$Main$parseUserArgs$ = function(model, compilerPath) {
	var colorFilter = model.useColor ? $gren_lang$core$Basics$identity : $gren_lang$compiler_node$CLI$PrettyPrinter$stripColor;
	var prettyTextToTerminal = function(doc) {
		return $gren_lang$compiler_node$CLI$PrettyPrinter$toStringWithOptions$(_Utils_update($gren_lang$compiler_node$CLI$PrettyPrinter$defaultOptions, { maxColumns: 80 }), colorFilter(doc));
	};
	var _v0 = $gren_lang$compiler_node$CLI$Parser$run$(model.args, $author$project$Terminal$Parser$parser);
	switch (_v0.$) {
		case 'UnknownCommand':
			var commandName = _v0.a;
			return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, 'I don\'t recognize this command: ' + commandName));
		case 'BadFlags':
			var err = _v0.a;
			return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, prettyTextToTerminal($gren_lang$compiler_node$CLI$Parser$flagErrorPrettified(err))));
		case 'BadArguments':
			var err = _v0.a;
			return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, prettyTextToTerminal($gren_lang$compiler_node$CLI$Parser$argumentErrorPrettified(err))));
		case 'HelpText':
			var prettifiedText = _v0.a;
			return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, prettyTextToTerminal(prettifiedText)));
		default:
			var parsedCommand = _v0.a;
			var initWithCommand = function(backendCommand) {
				return $gren_lang$node$ChildProcess$External(function(cpOpts) {
						return $author$project$Main$CompilerInitialized({ backendStreams: cpOpts.streams, encodedCommand: $gren_lang$compiler_node$Compiler$Backend$encodeCommand$({ interactiveSession: model.interactive, pathToString: model.pathToString }, backendCommand), quiet: false });
					});
			};
			switch (parsedCommand.$) {
				case 'Init':
					var flags = parsedCommand.a;
					return $author$project$Terminal$Init$run({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, _package: flags._package, platform: flags.platform, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor });
				case 'Repl':
					var flags = parsedCommand.a;
					return $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Task$succeed($gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, err)));
							}, $gren_lang$core$Task$map$(function(resolved) {
									return $gren_lang$compiler_node$Compiler$Backend$run$(model.cpPermission, { compilerPath: compilerPath, connection: initWithCommand($gren_lang$compiler_node$Compiler$Backend$Repl({ dependencies: resolved.dependencies, interpreter: flags.interpreter, outline: resolved.outline, projectPath: resolved.projectPath, rootSources: resolved.rootSources })), onComplete: $author$project$Main$CompilerRan, pathToString: model.pathToString, useColor: model.useColor });
								}, A2($gren_lang$core$Task$andThen, function(projectOutline) {
										return $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline));
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission))))));
				case 'Make':
					var flags = parsedCommand.a;
					return $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Task$succeed($gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, $gren_lang$core$Debug$toString(err))));
							}, $gren_lang$core$Task$map$(function(resolved) {
									return $gren_lang$compiler_node$Compiler$Backend$run$(model.cpPermission, { compilerPath: compilerPath, connection: initWithCommand($gren_lang$compiler_node$Compiler$Backend$Make({ dependencies: resolved.dependencies, entryPoints: flags.entryPoints, optimize: flags.optimize, outline: resolved.outline, output: flags.output, projectPath: resolved.projectPath, report: flags.report, rootSources: resolved.rootSources, sourcemaps: flags.sourcemaps })), onComplete: $author$project$Main$CompilerRan, pathToString: model.pathToString, useColor: model.useColor });
								}, A2($gren_lang$core$Task$andThen, function(projectOutline) {
										return $author$project$Terminal$PackageInstall$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline);
									}, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission)))));
				case 'Run':
					var moduleName = parsedCommand.a;
					return $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Task$succeed($gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, $gren_lang$core$Debug$toString(err))));
							}, $author$project$Terminal$Run$make({ compilerPath: compilerPath, cpPermission: model.cpPermission, fsPermission: model.fsPermission, moduleName: moduleName, onBackendInitialized: function(_v2) {
									var backendStreams = _v2.backendStreams;
									var encodedCommand = _v2.encodedCommand;
									return $author$project$Main$CompilerInitialized({ backendStreams: backendStreams, encodedCommand: encodedCommand, quiet: true });
								}, onCompiled: F2(function(outputPath, exitCode) {
										return $author$project$Main$CompiledForRun({ exitCode: exitCode, path: model.pathToString(outputPath) });
									}), pathToString: model.pathToString, useColor: model.useColor })));
				case 'Docs':
					var flags = parsedCommand.a;
					return $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Task$succeed($gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, err)));
							}, $gren_lang$core$Task$map$(function(resolved) {
									return $gren_lang$compiler_node$Compiler$Backend$run$(model.cpPermission, { compilerPath: compilerPath, connection: initWithCommand($gren_lang$compiler_node$Compiler$Backend$Docs({ dependencies: resolved.dependencies, outline: resolved.outline, output: flags.output, projectPath: resolved.projectPath, report: flags.report, rootSources: resolved.rootSources })), onComplete: $author$project$Main$CompilerRan, pathToString: model.pathToString, useColor: model.useColor });
								}, A2($gren_lang$core$Task$andThen, function(projectOutline) {
										return $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline));
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission))))));
				case 'PackageInstall':
					if (parsedCommand.a.$ === 'Nothing') {
						var _v3 = parsedCommand.a;
						return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(err) {
									return $gren_lang$core$Stream$Log$line$(model.stdout, $gren_lang$core$Debug$toString(err));
								}, A2($gren_lang$core$Task$andThen, function(err) {
										return $gren_lang$core$Stream$Log$line$(model.stdout, 'Done');
									}, A2($gren_lang$core$Task$andThen, function(projectOutline) {
											return $author$project$Terminal$PackageInstall$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline);
										}, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission)))));
					} else {
						var requestedPackage = parsedCommand.a.a;
						return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(err) {
									return $gren_lang$core$Stream$Log$line$(model.stdout, $gren_lang$core$Debug$toString(err));
								}, A2($gren_lang$core$Task$andThen, function(err) {
										return $gren_lang$core$Stream$Log$line$(model.stdout, 'Done');
									}, A2($gren_lang$core$Task$andThen, function(projectOutline) {
											return $author$project$Terminal$PackageInstall$addPackage$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline, requestedPackage);
										}, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission)))));
					}
				case 'PackageUninstall':
					var packageName = parsedCommand.a;
					return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Stream$Log$line$(model.stdout, $gren_lang$core$Debug$toString(err));
							}, A2($gren_lang$core$Task$andThen, function(err) {
									return $gren_lang$core$Stream$Log$line$(model.stdout, 'Done');
								}, A2($gren_lang$core$Task$andThen, function(projectOutline) {
										return $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageUninstall$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline, packageName));
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission))))));
				case 'PackageOutdated':
					return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Stream$Log$line$(model.stdout, $gren_lang$core$Debug$toString(err));
							}, A2($gren_lang$core$Task$andThen, function(err) {
									return $gren_lang$core$Stream$Log$line$(model.stdout, 'Done');
								}, A2($gren_lang$core$Task$andThen, function(projectOutline) {
										return $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageOutdated$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline));
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission))))));
				case 'PackageValidate':
					return $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Task$succeed($gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, err)));
							}, $gren_lang$core$Task$map$(function(backendFlags) {
									return $gren_lang$compiler_node$Compiler$Backend$run$(model.cpPermission, { compilerPath: compilerPath, connection: initWithCommand($gren_lang$compiler_node$Compiler$Backend$PackageValidate(backendFlags)), onComplete: $author$project$Main$CompilerRan, pathToString: model.pathToString, useColor: model.useColor });
								}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, A2($gren_lang$core$Task$andThen, function(projectOutline) {
											return $author$project$Terminal$PackageValidate$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline);
										}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission)))))));
				case 'PackageBump':
					return $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Task$succeed($gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, err)));
							}, $gren_lang$core$Task$map$(function(backendFlags) {
									return $gren_lang$compiler_node$Compiler$Backend$run$(model.cpPermission, { compilerPath: compilerPath, connection: initWithCommand($gren_lang$compiler_node$Compiler$Backend$PackageBump(backendFlags)), onComplete: $author$project$Main$CompilerRan, pathToString: model.pathToString, useColor: model.useColor });
								}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, A2($gren_lang$core$Task$andThen, function(projectOutline) {
											return $author$project$Terminal$PackageBump$run$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, projectOutline);
										}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission)))))));
				case 'PackageDiff':
					var args = parsedCommand.a;
					var diffTask = function () {
						switch (args.$) {
							case 'DiffLatest':
								return $author$project$Terminal$PackageDiff$runLocal$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, $gren_lang$core$Maybe$Nothing);
							case 'DiffVersion':
								var version = args.a;
								return $author$project$Terminal$PackageDiff$runLocal$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, $gren_lang$core$Maybe$Just(version));
							case 'DiffRange':
								var _v5 = args.a;
								var lower = _v5.lower;
								var upper = _v5.upper;
								return A2($gren_lang$core$Task$andThen, function(_v6) {
										var outline = _v6.outline;
										if (outline.$ === 'App') {
											return $gren_lang$core$Task$fail('Only supported on packages');
										} else {
											var pkgOutline = outline.a;
											return $author$project$Terminal$PackageDiff$runGlobal$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, pkgOutline.name, lower, upper);
										}
									}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, $author$project$Terminal$PackageInstall$readProjectOutline(model.fsPermission)));
							default:
								var _v8 = args.a;
								var _package = _v8._package;
								var lower = _v8.lower;
								var upper = _v8.upper;
								return $author$project$Terminal$PackageDiff$runGlobal$({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, interactive: model.interactive, stdin: model.stdin, stdout: model.stdout, useColor: model.useColor }, _package, lower, upper);
						}
					}();
					return $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(err) {
								return $gren_lang$core$Task$succeed($gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stdout, err)));
							}, $gren_lang$core$Task$map$(function(backendFlags) {
									return $gren_lang$compiler_node$Compiler$Backend$run$(model.cpPermission, { compilerPath: compilerPath, connection: initWithCommand($gren_lang$compiler_node$Compiler$Backend$PackageDiff(backendFlags)), onComplete: $author$project$Main$CompilerRan, pathToString: model.pathToString, useColor: model.useColor });
								}, $gren_lang$core$Task$mapError$($gren_lang$core$Debug$toString, diffTask))));
				default:
					var opts = parsedCommand.a;
					return $author$project$Terminal$Paths$run$({ backendPath: model.backendPath, fsPermission: model.fsPermission, pathToString: model.pathToString, stdout: model.stdout }, opts);
			}
	}
};
var $author$project$Main$parseUserArgs = F2($author$project$Main$parseUserArgs$);
var $gren_lang$node$ChildProcess$Integrated = function (a) {
	return { $: 'Integrated', a: a };
};
var $gren_lang$node$Node$getPlatform = $gren_lang$core$Task$map$($gren_lang$node$Node$platformFromString, _Node_getPlatform);
var $author$project$Terminal$Run$run = function(config) {
	return $gren_lang$core$Task$await$($gren_lang$node$Node$getPlatform, function(systemPlatform) {
			return $gren_lang$core$Task$await$($author$project$Terminal$Run$getProjectOutline(config.fsPermission), function(projectOutline) {
					var runWith = function(command) {
						return $gren_lang$core$Task$succeed($gren_lang$node$ChildProcess$spawn$(config.cpPermission, command, [ config.path ], $gren_lang$node$ChildProcess$defaultSpawnOptions$($gren_lang$node$ChildProcess$Integrated(config.onInit), config.onExit)));
					};
					var projectPlatform = function () {
						var _v2 = projectOutline.outline;
						if (_v2.$ === 'Pkg') {
							var outline_ = _v2.a;
							return outline_.platform;
						} else {
							var outline_ = _v2.a;
							return outline_.platform;
						}
					}();
					switch (projectPlatform.$) {
						case 'Node':
							return runWith('node');
						case 'Common':
							return $gren_lang$core$Task$fail($author$project$Terminal$Run$NotAnApplication);
						default:
							if (systemPlatform.$ === 'Win32') {
								return runWith('start');
							} else {
								return runWith('open');
							}
					}
				});
		});
};
var $author$project$Main$update$ = function(msg, model) {
	return { command: function () {
		switch (msg.$) {
			case 'ExistanceChecked':
				if (msg.a.existanceResult.$ === 'Err') {
					var _v1 = msg.a;
					var maybeRemotePath = _v1.maybeRemotePath;
					var localPath = _v1.localPath;
					if (maybeRemotePath.$ === 'Just') {
						var remotePath = maybeRemotePath.a;
						return $gren_lang$core$Task$attempt$(function(result) {
								return $author$project$Main$CompilerDownloaded({ downloadResult: result, localPath: localPath });
							}, A2($gren_lang$core$Task$andThen, function(_v3) {
									return $gren_lang$compiler_node$Compiler$Backend$download$(model.httpPermission, remotePath);
								}, $gren_lang$core$Stream$Log$line$(model.stdout, 'Compiler not found at ' + (model.pathToString(localPath) + '. Downloading...'))));
					} else {
						return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, 'Compiler not found at ' + model.pathToString(localPath)));
					}
				} else {
					var compilerPath = msg.a.existanceResult.a;
					return $author$project$Main$parseUserArgs$(model, compilerPath);
				}
			case 'CompilerDownloaded':
				if (msg.a.downloadResult.$ === 'Err') {
					if (msg.a.downloadResult.a.$ === 'BadStatus') {
						var _v4 = msg.a;
						var localPath = _v4.localPath;
						var err = _v4.downloadResult.a;
						var res = err.a;
						if (res.statusCode === 302) {
							var _v5 = $gren_lang$core$Dict$get$('location', res.headers);
							if ((_v5.$ === 'Just') && (_v5.a.length === 1)) {
								var location = _v5.a[0];
								return $gren_lang$core$Task$attempt$(function(result) {
										return $author$project$Main$CompilerDownloaded({ downloadResult: result, localPath: localPath });
									}, $gren_lang$compiler_node$Compiler$Backend$download$(model.httpPermission, location));
							} else {
								return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, 'Missing, or vague, \'location\' header in 302 response from server.'));
							}
						} else {
							return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, $gren_lang$node$HttpClient$errorToString(err)));
						}
					} else {
						var err = msg.a.downloadResult.a;
						return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, $gren_lang$node$HttpClient$errorToString(err)));
					}
				} else {
					var _v6 = msg.a;
					var localPath = _v6.localPath;
					var res = _v6.downloadResult.a;
					var cacheFolder = $gren_lang$core$Maybe$withDefault$($gren_lang$node$FileSystem$Path$empty, $gren_lang$node$FileSystem$Path$parentPath(localPath));
					return $gren_lang$core$Task$attempt$($author$project$Main$CompilerInstalled, A2($gren_lang$core$Task$andThen, function(binPath) {
								return $gren_lang$core$Task$map$(function(_v8) {
										return binPath;
									}, $gren_lang$core$Stream$Log$line$(model.stdout, 'Downloaded'));
							}, A2($gren_lang$core$Task$andThen, A2($gren_lang$node$FileSystem$changeAccess, model.fsPermission, { group: [ $gren_lang$node$FileSystem$Read, $gren_lang$node$FileSystem$Execute ], others: [ $gren_lang$node$FileSystem$Read, $gren_lang$node$FileSystem$Execute ], owner: [ $gren_lang$node$FileSystem$Read, $gren_lang$node$FileSystem$Write, $gren_lang$node$FileSystem$Execute ] }), A2($gren_lang$core$Task$andThen, function(_v7) {
										return $gren_lang$node$FileSystem$writeFile$(model.fsPermission, res.data, localPath);
									}, $gren_lang$node$FileSystem$makeDirectory$(model.fsPermission, { recursive: true }, cacheFolder)))));
				}
			case 'CompilerInstalled':
				if (msg.a.$ === 'Err') {
					var fsErr = msg.a.a;
					return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, 'Failed to install binary after download, due to error: ' + $gren_lang$node$FileSystem$errorToString(fsErr)));
				} else {
					var compilerPath = msg.a.a;
					return $author$project$Main$parseUserArgs$(model, compilerPath);
				}
			case 'CompilerInitialized':
				var _v9 = msg.a;
				var backendStreams = _v9.backendStreams;
				var encodedCommand = _v9.encodedCommand;
				var quiet = _v9.quiet;
				return $gren_lang$core$Platform$Cmd$batch([ $gren_lang$core$Task$attempt$($author$project$Main$RedirectTerminalIO, $gren_lang$core$Task$mapError$(function(err) {
								return { error: err, source: model.stdin, target: backendStreams.input };
							}, $gren_lang$core$Task$map$(function(_v10) {
									return { source: model.stdin, target: backendStreams.input };
								}, A2($gren_lang$core$Stream$write, encodedCommand, backendStreams.input)))), quiet ? $gren_lang$core$Platform$Cmd$none : $gren_lang$core$Task$attempt$($author$project$Main$RedirectTerminalIO, $gren_lang$core$Task$succeed({ source: backendStreams.output, target: model.stdout })), $gren_lang$core$Task$attempt$($author$project$Main$RedirectTerminalIO, $gren_lang$core$Task$succeed({ source: backendStreams.error, target: model.stderr })) ]);
			case 'CompilerRan':
				var exitCode = msg.a;
				return $gren_lang$node$Node$exitWithCode(exitCode);
			case 'CompiledForRun':
				var _v11 = msg.a;
				var path = _v11.path;
				var exitCode = _v11.exitCode;
				return (exitCode === 0) ? $gren_lang$core$Task$executeCmd(A2($gren_lang$core$Task$onError, function(error) {
							return $gren_lang$core$Task$map$(function(_v12) {
									return $gren_lang$node$Node$exitWithCode(1);
								}, $gren_lang$core$Stream$Log$line$(model.stderr, $gren_lang$core$Debug$toString(error)));
						}, $author$project$Terminal$Run$run({ cpPermission: model.cpPermission, fsPermission: model.fsPermission, onExit: $author$project$Main$RunExited, onInit: $author$project$Main$RunStarted, path: path }))) : $gren_lang$node$Node$exitWithCode(exitCode);
			case 'RunStarted':
				return $gren_lang$core$Platform$Cmd$none;
			case 'RunExited':
				var exitCode = msg.a;
				return $gren_lang$node$Node$exitWithCode(exitCode);
			default:
				if (msg.a.$ === 'Ok') {
					var streams = msg.a.a;
					return $gren_lang$core$Task$attempt$($author$project$Main$RedirectTerminalIO, $gren_lang$core$Task$mapError$(function(err) {
								return { error: err, source: streams.source, target: streams.target };
							}, $gren_lang$core$Task$map$(function(_v13) {
									return streams;
								}, A2($gren_lang$core$Task$andThen, function(str) {
										return A2($gren_lang$core$Stream$write, str, streams.target);
									}, $gren_lang$core$Stream$read(streams.source)))));
				} else {
					var _v14 = msg.a.a;
					var error = _v14.error;
					var source = _v14.source;
					var target = _v14.target;
					if (error.$ === 'Closed') {
						return $gren_lang$core$Task$execute(A2($gren_lang$core$Task$onError, function(err) {
									return $gren_lang$core$Stream$Log$line$(model.stderr, 'Failed to close stream:  ' + $gren_lang$core$Stream$errorToString(error));
								}, $gren_lang$core$Stream$closeWritable(target)));
					} else {
						return $gren_lang$core$Task$execute($gren_lang$core$Stream$Log$line$(model.stderr, 'Something went wrong when communicating with compiler backend: ' + $gren_lang$core$Stream$errorToString(error)));
					}
				}
		}
	}(), model: model };
};
var $author$project$Main$update = F2($author$project$Main$update$);
var $author$project$Main$main = $gren_lang$node$Node$defineProgram({ init: $author$project$Main$init, subscriptions: function(_v0) {
		return $gren_lang$core$Platform$Sub$none;
	}, update: $author$project$Main$update });
_Platform_export({'Main':{'init':$author$project$Main$main($gren_lang$core$Json$Decode$succeed({  }))}});}(this.module ? this.module.exports : this));
this.Gren.Main.init({});
}
catch (e)
{
console.error(e);
}
